// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_box2D_common_B2Settings
#include <box2D/common/B2Settings.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Mat22
#include <box2D/common/math/B2Mat22.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Math
#include <box2D/common/math/B2Math.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Sweep
#include <box2D/common/math/B2Sweep.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Transform
#include <box2D/common/math/B2Transform.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Vec2
#include <box2D/common/math/B2Vec2.h>
#endif
#ifndef INCLUDED_box2D_dynamics_B2Body
#include <box2D/dynamics/B2Body.h>
#endif
#ifndef INCLUDED_box2D_dynamics_B2TimeStep
#include <box2D/dynamics/B2TimeStep.h>
#endif
#ifndef INCLUDED_box2D_dynamics_joints_B2Joint
#include <box2D/dynamics/joints/B2Joint.h>
#endif
#ifndef INCLUDED_box2D_dynamics_joints_B2JointDef
#include <box2D/dynamics/joints/B2JointDef.h>
#endif
#ifndef INCLUDED_box2D_dynamics_joints_B2LineJoint
#include <box2D/dynamics/joints/B2LineJoint.h>
#endif
#ifndef INCLUDED_box2D_dynamics_joints_B2LineJointDef
#include <box2D/dynamics/joints/B2LineJointDef.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_046125791711432f_297_new,"box2D.dynamics.joints.B2LineJoint","new",0x739cc99c,"box2D.dynamics.joints.B2LineJoint.new","box2D/dynamics/joints/B2LineJoint.hx",297,0x501e3935)
HX_LOCAL_STACK_FRAME(_hx_pos_046125791711432f_102_getAnchorA,"box2D.dynamics.joints.B2LineJoint","getAnchorA",0xd08e587a,"box2D.dynamics.joints.B2LineJoint.getAnchorA","box2D/dynamics/joints/B2LineJoint.hx",102,0x501e3935)
HX_LOCAL_STACK_FRAME(_hx_pos_046125791711432f_106_getAnchorB,"box2D.dynamics.joints.B2LineJoint","getAnchorB",0xd08e587b,"box2D.dynamics.joints.B2LineJoint.getAnchorB","box2D/dynamics/joints/B2LineJoint.hx",106,0x501e3935)
HX_LOCAL_STACK_FRAME(_hx_pos_046125791711432f_112_getReactionForce,"box2D.dynamics.joints.B2LineJoint","getReactionForce",0x97c77050,"box2D.dynamics.joints.B2LineJoint.getReactionForce","box2D/dynamics/joints/B2LineJoint.hx",112,0x501e3935)
HX_LOCAL_STACK_FRAME(_hx_pos_046125791711432f_119_getReactionTorque,"box2D.dynamics.joints.B2LineJoint","getReactionTorque",0xcfc490c5,"box2D.dynamics.joints.B2LineJoint.getReactionTorque","box2D/dynamics/joints/B2LineJoint.hx",119,0x501e3935)
HX_LOCAL_STACK_FRAME(_hx_pos_046125791711432f_125_getJointTranslation,"box2D.dynamics.joints.B2LineJoint","getJointTranslation",0x344179b9,"box2D.dynamics.joints.B2LineJoint.getJointTranslation","box2D/dynamics/joints/B2LineJoint.hx",125,0x501e3935)
HX_LOCAL_STACK_FRAME(_hx_pos_046125791711432f_147_getJointSpeed,"box2D.dynamics.joints.B2LineJoint","getJointSpeed",0x23969a4f,"box2D.dynamics.joints.B2LineJoint.getJointSpeed","box2D/dynamics/joints/B2LineJoint.hx",147,0x501e3935)
HX_LOCAL_STACK_FRAME(_hx_pos_046125791711432f_198_isLimitEnabled,"box2D.dynamics.joints.B2LineJoint","isLimitEnabled",0x05ea71d4,"box2D.dynamics.joints.B2LineJoint.isLimitEnabled","box2D/dynamics/joints/B2LineJoint.hx",198,0x501e3935)
HX_LOCAL_STACK_FRAME(_hx_pos_046125791711432f_204_enableLimit,"box2D.dynamics.joints.B2LineJoint","enableLimit",0x7acefaf4,"box2D.dynamics.joints.B2LineJoint.enableLimit","box2D/dynamics/joints/B2LineJoint.hx",204,0x501e3935)
HX_LOCAL_STACK_FRAME(_hx_pos_046125791711432f_214_getLowerLimit,"box2D.dynamics.joints.B2LineJoint","getLowerLimit",0x758d69ec,"box2D.dynamics.joints.B2LineJoint.getLowerLimit","box2D/dynamics/joints/B2LineJoint.hx",214,0x501e3935)
HX_LOCAL_STACK_FRAME(_hx_pos_046125791711432f_221_getUpperLimit,"box2D.dynamics.joints.B2LineJoint","getUpperLimit",0x7abbeaeb,"box2D.dynamics.joints.B2LineJoint.getUpperLimit","box2D/dynamics/joints/B2LineJoint.hx",221,0x501e3935)
HX_LOCAL_STACK_FRAME(_hx_pos_046125791711432f_227_setLimits,"box2D.dynamics.joints.B2LineJoint","setLimits",0x84733856,"box2D.dynamics.joints.B2LineJoint.setLimits","box2D/dynamics/joints/B2LineJoint.hx",227,0x501e3935)
HX_LOCAL_STACK_FRAME(_hx_pos_046125791711432f_239_isMotorEnabled,"box2D.dynamics.joints.B2LineJoint","isMotorEnabled",0x0e2d3bda,"box2D.dynamics.joints.B2LineJoint.isMotorEnabled","box2D/dynamics/joints/B2LineJoint.hx",239,0x501e3935)
HX_LOCAL_STACK_FRAME(_hx_pos_046125791711432f_245_enableMotor,"box2D.dynamics.joints.B2LineJoint","enableMotor",0x12322c2e,"box2D.dynamics.joints.B2LineJoint.enableMotor","box2D/dynamics/joints/B2LineJoint.hx",245,0x501e3935)
HX_LOCAL_STACK_FRAME(_hx_pos_046125791711432f_254_setMotorSpeed,"box2D.dynamics.joints.B2LineJoint","setMotorSpeed",0x7b858950,"box2D.dynamics.joints.B2LineJoint.setMotorSpeed","box2D/dynamics/joints/B2LineJoint.hx",254,0x501e3935)
HX_LOCAL_STACK_FRAME(_hx_pos_046125791711432f_264_getMotorSpeed,"box2D.dynamics.joints.B2LineJoint","getMotorSpeed",0x367fa744,"box2D.dynamics.joints.B2LineJoint.getMotorSpeed","box2D/dynamics/joints/B2LineJoint.hx",264,0x501e3935)
HX_LOCAL_STACK_FRAME(_hx_pos_046125791711432f_271_setMaxMotorForce,"box2D.dynamics.joints.B2LineJoint","setMaxMotorForce",0x87bfd53c,"box2D.dynamics.joints.B2LineJoint.setMaxMotorForce","box2D/dynamics/joints/B2LineJoint.hx",271,0x501e3935)
HX_LOCAL_STACK_FRAME(_hx_pos_046125791711432f_282_getMaxMotorForce,"box2D.dynamics.joints.B2LineJoint","getMaxMotorForce",0x317de7c8,"box2D.dynamics.joints.B2LineJoint.getMaxMotorForce","box2D/dynamics/joints/B2LineJoint.hx",282,0x501e3935)
HX_LOCAL_STACK_FRAME(_hx_pos_046125791711432f_290_getMotorForce,"box2D.dynamics.joints.B2LineJoint","getMotorForce",0xb9aac1a8,"box2D.dynamics.joints.B2LineJoint.getMotorForce","box2D/dynamics/joints/B2LineJoint.hx",290,0x501e3935)
HX_LOCAL_STACK_FRAME(_hx_pos_046125791711432f_340_initVelocityConstraints,"box2D.dynamics.joints.B2LineJoint","initVelocityConstraints",0x87187865,"box2D.dynamics.joints.B2LineJoint.initVelocityConstraints","box2D/dynamics/joints/B2LineJoint.hx",340,0x501e3935)
HX_LOCAL_STACK_FRAME(_hx_pos_046125791711432f_482_solveVelocityConstraints,"box2D.dynamics.joints.B2LineJoint","solveVelocityConstraints",0x83142b5e,"box2D.dynamics.joints.B2LineJoint.solveVelocityConstraints","box2D/dynamics/joints/B2LineJoint.hx",482,0x501e3935)
HX_LOCAL_STACK_FRAME(_hx_pos_046125791711432f_604_solvePositionConstraints,"box2D.dynamics.joints.B2LineJoint","solvePositionConstraints",0xbaf04052,"box2D.dynamics.joints.B2LineJoint.solvePositionConstraints","box2D/dynamics/joints/B2LineJoint.hx",604,0x501e3935)
namespace box2D{
namespace dynamics{
namespace joints{

void B2LineJoint_obj::__construct( ::box2D::dynamics::joints::B2LineJointDef def){
            	HX_GC_STACKFRAME(&_hx_pos_046125791711432f_297_new)
HXLINE( 298)		super::__construct(def);
HXLINE( 300)		this->m_localAnchor1 =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 301)		this->m_localAnchor2 =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 302)		this->m_localXAxis1 =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 303)		this->m_localYAxis1 =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 305)		this->m_axis =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 306)		this->m_perp =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 308)		this->m_K =  ::box2D::common::math::B2Mat22_obj::__alloc( HX_CTX );
HXLINE( 309)		this->m_impulse =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 312)		 ::box2D::common::math::B2Mat22 tMat;
HXLINE( 313)		Float tX;
HXLINE( 314)		Float tY;
HXLINE( 316)		{
HXLINE( 316)			 ::box2D::common::math::B2Vec2 _this = this->m_localAnchor1;
HXDLIN( 316)			 ::box2D::common::math::B2Vec2 v = def->localAnchorA;
HXDLIN( 316)			_this->x = v->x;
HXDLIN( 316)			_this->y = v->y;
            		}
HXLINE( 317)		{
HXLINE( 317)			 ::box2D::common::math::B2Vec2 _this1 = this->m_localAnchor2;
HXDLIN( 317)			 ::box2D::common::math::B2Vec2 v1 = def->localAnchorB;
HXDLIN( 317)			_this1->x = v1->x;
HXDLIN( 317)			_this1->y = v1->y;
            		}
HXLINE( 318)		{
HXLINE( 318)			 ::box2D::common::math::B2Vec2 _this2 = this->m_localXAxis1;
HXDLIN( 318)			 ::box2D::common::math::B2Vec2 v2 = def->localAxisA;
HXDLIN( 318)			_this2->x = v2->x;
HXDLIN( 318)			_this2->y = v2->y;
            		}
HXLINE( 321)		this->m_localYAxis1->x = -(this->m_localXAxis1->y);
HXLINE( 322)		this->m_localYAxis1->y = this->m_localXAxis1->x;
HXLINE( 324)		{
HXLINE( 324)			 ::box2D::common::math::B2Vec2 _this3 = this->m_impulse;
HXDLIN( 324)			_this3->x = ((Float)0.0);
HXDLIN( 324)			_this3->y = ((Float)0.0);
            		}
HXLINE( 325)		this->m_motorMass = ((Float)0.0);
HXLINE( 326)		this->m_motorImpulse = ((Float)0.0);
HXLINE( 328)		this->m_lowerTranslation = def->lowerTranslation;
HXLINE( 329)		this->m_upperTranslation = def->upperTranslation;
HXLINE( 330)		this->m_maxMotorForce = def->maxMotorForce;
HXLINE( 331)		this->m_motorSpeed = def->motorSpeed;
HXLINE( 332)		this->m_enableLimit = def->enableLimit;
HXLINE( 333)		this->m_enableMotor = def->enableMotor;
HXLINE( 334)		this->m_limitState = (int)0;
HXLINE( 336)		{
HXLINE( 336)			 ::box2D::common::math::B2Vec2 _this4 = this->m_axis;
HXDLIN( 336)			_this4->x = ((Float)0.0);
HXDLIN( 336)			_this4->y = ((Float)0.0);
            		}
HXLINE( 337)		{
HXLINE( 337)			 ::box2D::common::math::B2Vec2 _this5 = this->m_perp;
HXDLIN( 337)			_this5->x = ((Float)0.0);
HXDLIN( 337)			_this5->y = ((Float)0.0);
            		}
            	}

Dynamic B2LineJoint_obj::__CreateEmpty() { return new B2LineJoint_obj; }

void *B2LineJoint_obj::_hx_vtable = 0;

Dynamic B2LineJoint_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< B2LineJoint_obj > _hx_result = new B2LineJoint_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool B2LineJoint_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x13310c20) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x13310c20;
	} else {
		return inClassId==(int)0x182344f0;
	}
}

 ::box2D::common::math::B2Vec2 B2LineJoint_obj::getAnchorA(){
            	HX_STACKFRAME(&_hx_pos_046125791711432f_102_getAnchorA)
HXDLIN( 102)		return this->m_bodyA->getWorldPoint(this->m_localAnchor1);
            	}


 ::box2D::common::math::B2Vec2 B2LineJoint_obj::getAnchorB(){
            	HX_STACKFRAME(&_hx_pos_046125791711432f_106_getAnchorB)
HXDLIN( 106)		return this->m_bodyB->getWorldPoint(this->m_localAnchor2);
            	}


 ::box2D::common::math::B2Vec2 B2LineJoint_obj::getReactionForce(Float inv_dt){
            	HX_GC_STACKFRAME(&_hx_pos_046125791711432f_112_getReactionForce)
HXDLIN( 112)		Float _hx_tmp = (this->m_impulse->x * this->m_perp->x);
HXDLIN( 112)		Float _hx_tmp1 = (inv_dt * (_hx_tmp + ((this->m_motorImpulse + this->m_impulse->y) * this->m_axis->x)));
HXLINE( 113)		Float _hx_tmp2 = (this->m_impulse->x * this->m_perp->y);
HXLINE( 112)		return  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,_hx_tmp1,(inv_dt * (_hx_tmp2 + ((this->m_motorImpulse + this->m_impulse->y) * this->m_axis->y))));
            	}


Float B2LineJoint_obj::getReactionTorque(Float inv_dt){
            	HX_STACKFRAME(&_hx_pos_046125791711432f_119_getReactionTorque)
HXDLIN( 119)		return (inv_dt * this->m_impulse->y);
            	}


Float B2LineJoint_obj::getJointTranslation(){
            	HX_STACKFRAME(&_hx_pos_046125791711432f_125_getJointTranslation)
HXLINE( 126)		 ::box2D::dynamics::B2Body bA = this->m_bodyA;
HXLINE( 127)		 ::box2D::dynamics::B2Body bB = this->m_bodyB;
HXLINE( 129)		 ::box2D::common::math::B2Mat22 tMat;
HXLINE( 131)		 ::box2D::common::math::B2Vec2 p1 = bA->getWorldPoint(this->m_localAnchor1);
HXLINE( 132)		 ::box2D::common::math::B2Vec2 p2 = bB->getWorldPoint(this->m_localAnchor2);
HXLINE( 134)		Float dX = (p2->x - p1->x);
HXLINE( 135)		Float dY = (p2->y - p1->y);
HXLINE( 137)		 ::box2D::common::math::B2Vec2 axis = bA->getWorldVector(this->m_localXAxis1);
HXLINE( 140)		Float translation = (axis->x * dX);
HXDLIN( 140)		Float translation1 = (translation + (axis->y * dY));
HXLINE( 141)		return translation1;
            	}


HX_DEFINE_DYNAMIC_FUNC0(B2LineJoint_obj,getJointTranslation,return )

Float B2LineJoint_obj::getJointSpeed(){
            	HX_STACKFRAME(&_hx_pos_046125791711432f_147_getJointSpeed)
HXLINE( 148)		 ::box2D::dynamics::B2Body bA = this->m_bodyA;
HXLINE( 149)		 ::box2D::dynamics::B2Body bB = this->m_bodyB;
HXLINE( 151)		 ::box2D::common::math::B2Mat22 tMat = bA->m_xf->R;
HXLINE( 155)		Float r1X = (this->m_localAnchor1->x - bA->m_sweep->localCenter->x);
HXLINE( 156)		Float r1Y = (this->m_localAnchor1->y - bA->m_sweep->localCenter->y);
HXLINE( 157)		Float tX = (tMat->col1->x * r1X);
HXDLIN( 157)		Float tX1 = (tX + (tMat->col2->x * r1Y));
HXLINE( 158)		Float r1Y1 = (tMat->col1->y * r1X);
HXDLIN( 158)		r1Y = (r1Y1 + (tMat->col2->y * r1Y));
HXLINE( 159)		r1X = tX1;
HXLINE( 161)		tMat = bB->m_xf->R;
HXLINE( 162)		Float r2X = (this->m_localAnchor2->x - bB->m_sweep->localCenter->x);
HXLINE( 163)		Float r2Y = (this->m_localAnchor2->y - bB->m_sweep->localCenter->y);
HXLINE( 164)		Float tX2 = (tMat->col1->x * r2X);
HXDLIN( 164)		tX1 = (tX2 + (tMat->col2->x * r2Y));
HXLINE( 165)		Float r2Y1 = (tMat->col1->y * r2X);
HXDLIN( 165)		r2Y = (r2Y1 + (tMat->col2->y * r2Y));
HXLINE( 166)		r2X = tX1;
HXLINE( 169)		Float p1X = (bA->m_sweep->c->x + r1X);
HXLINE( 170)		Float p1Y = (bA->m_sweep->c->y + r1Y);
HXLINE( 172)		Float p2X = (bB->m_sweep->c->x + r2X);
HXLINE( 173)		Float p2Y = (bB->m_sweep->c->y + r2Y);
HXLINE( 175)		Float dX = (p2X - p1X);
HXLINE( 176)		Float dY = (p2Y - p1Y);
HXLINE( 178)		 ::box2D::common::math::B2Vec2 axis = bA->getWorldVector(this->m_localXAxis1);
HXLINE( 180)		 ::box2D::common::math::B2Vec2 v1 = bA->m_linearVelocity;
HXLINE( 181)		 ::box2D::common::math::B2Vec2 v2 = bB->m_linearVelocity;
HXLINE( 182)		Float w1 = bA->m_angularVelocity;
HXLINE( 183)		Float w2 = bB->m_angularVelocity;
HXLINE( 188)		Float speed = (dX * (-(w1) * axis->y));
HXDLIN( 188)		Float speed1 = (speed + (dY * (w1 * axis->x)));
HXDLIN( 188)		Float axis1 = axis->x;
HXDLIN( 188)		Float v21 = v2->x;
HXDLIN( 188)		Float speed2 = ((v21 + (-(w2) * r2Y)) - v1->x);
HXDLIN( 188)		Float speed3 = (axis1 * (speed2 - (-(w1) * r1Y)));
HXDLIN( 188)		Float axis2 = axis->y;
HXDLIN( 188)		Float v22 = v2->y;
HXDLIN( 188)		Float speed4 = ((v22 + (w2 * r2X)) - v1->y);
HXDLIN( 188)		Float speed5 = (speed1 + (speed3 + (axis2 * (speed4 - (w1 * r1X)))));
HXLINE( 190)		return speed5;
            	}


HX_DEFINE_DYNAMIC_FUNC0(B2LineJoint_obj,getJointSpeed,return )

bool B2LineJoint_obj::isLimitEnabled(){
            	HX_STACKFRAME(&_hx_pos_046125791711432f_198_isLimitEnabled)
HXDLIN( 198)		return this->m_enableLimit;
            	}


HX_DEFINE_DYNAMIC_FUNC0(B2LineJoint_obj,isLimitEnabled,return )

void B2LineJoint_obj::enableLimit(bool flag){
            	HX_STACKFRAME(&_hx_pos_046125791711432f_204_enableLimit)
HXLINE( 205)		this->m_bodyA->setAwake(true);
HXLINE( 206)		this->m_bodyB->setAwake(true);
HXLINE( 207)		this->m_enableLimit = flag;
            	}


HX_DEFINE_DYNAMIC_FUNC1(B2LineJoint_obj,enableLimit,(void))

Float B2LineJoint_obj::getLowerLimit(){
            	HX_STACKFRAME(&_hx_pos_046125791711432f_214_getLowerLimit)
HXDLIN( 214)		return this->m_lowerTranslation;
            	}


HX_DEFINE_DYNAMIC_FUNC0(B2LineJoint_obj,getLowerLimit,return )

Float B2LineJoint_obj::getUpperLimit(){
            	HX_STACKFRAME(&_hx_pos_046125791711432f_221_getUpperLimit)
HXDLIN( 221)		return this->m_upperTranslation;
            	}


HX_DEFINE_DYNAMIC_FUNC0(B2LineJoint_obj,getUpperLimit,return )

void B2LineJoint_obj::setLimits(Float lower,Float upper){
            	HX_STACKFRAME(&_hx_pos_046125791711432f_227_setLimits)
HXLINE( 229)		this->m_bodyA->setAwake(true);
HXLINE( 230)		this->m_bodyB->setAwake(true);
HXLINE( 231)		this->m_lowerTranslation = lower;
HXLINE( 232)		this->m_upperTranslation = upper;
            	}


HX_DEFINE_DYNAMIC_FUNC2(B2LineJoint_obj,setLimits,(void))

bool B2LineJoint_obj::isMotorEnabled(){
            	HX_STACKFRAME(&_hx_pos_046125791711432f_239_isMotorEnabled)
HXDLIN( 239)		return this->m_enableMotor;
            	}


HX_DEFINE_DYNAMIC_FUNC0(B2LineJoint_obj,isMotorEnabled,return )

void B2LineJoint_obj::enableMotor(bool flag){
            	HX_STACKFRAME(&_hx_pos_046125791711432f_245_enableMotor)
HXLINE( 246)		this->m_bodyA->setAwake(true);
HXLINE( 247)		this->m_bodyB->setAwake(true);
HXLINE( 248)		this->m_enableMotor = flag;
            	}


HX_DEFINE_DYNAMIC_FUNC1(B2LineJoint_obj,enableMotor,(void))

void B2LineJoint_obj::setMotorSpeed(Float speed){
            	HX_STACKFRAME(&_hx_pos_046125791711432f_254_setMotorSpeed)
HXLINE( 255)		this->m_bodyA->setAwake(true);
HXLINE( 256)		this->m_bodyB->setAwake(true);
HXLINE( 257)		this->m_motorSpeed = speed;
            	}


HX_DEFINE_DYNAMIC_FUNC1(B2LineJoint_obj,setMotorSpeed,(void))

Float B2LineJoint_obj::getMotorSpeed(){
            	HX_STACKFRAME(&_hx_pos_046125791711432f_264_getMotorSpeed)
HXDLIN( 264)		return this->m_motorSpeed;
            	}


HX_DEFINE_DYNAMIC_FUNC0(B2LineJoint_obj,getMotorSpeed,return )

void B2LineJoint_obj::setMaxMotorForce(Float force){
            	HX_STACKFRAME(&_hx_pos_046125791711432f_271_setMaxMotorForce)
HXLINE( 272)		this->m_bodyA->setAwake(true);
HXLINE( 273)		this->m_bodyB->setAwake(true);
HXLINE( 274)		this->m_maxMotorForce = force;
            	}


HX_DEFINE_DYNAMIC_FUNC1(B2LineJoint_obj,setMaxMotorForce,(void))

Float B2LineJoint_obj::getMaxMotorForce(){
            	HX_STACKFRAME(&_hx_pos_046125791711432f_282_getMaxMotorForce)
HXDLIN( 282)		return this->m_maxMotorForce;
            	}


HX_DEFINE_DYNAMIC_FUNC0(B2LineJoint_obj,getMaxMotorForce,return )

Float B2LineJoint_obj::getMotorForce(){
            	HX_STACKFRAME(&_hx_pos_046125791711432f_290_getMotorForce)
HXDLIN( 290)		return this->m_motorImpulse;
            	}


HX_DEFINE_DYNAMIC_FUNC0(B2LineJoint_obj,getMotorForce,return )

void B2LineJoint_obj::initVelocityConstraints( ::box2D::dynamics::B2TimeStep step){
            	HX_STACKFRAME(&_hx_pos_046125791711432f_340_initVelocityConstraints)
HXLINE( 341)		 ::box2D::dynamics::B2Body bA = this->m_bodyA;
HXLINE( 342)		 ::box2D::dynamics::B2Body bB = this->m_bodyB;
HXLINE( 344)		 ::box2D::common::math::B2Mat22 tMat;
HXLINE( 345)		Float tX;
HXLINE( 347)		{
HXLINE( 347)			 ::box2D::common::math::B2Vec2 _this = this->m_localCenterA;
HXDLIN( 347)			 ::box2D::common::math::B2Vec2 v = bA->getLocalCenter();
HXDLIN( 347)			_this->x = v->x;
HXDLIN( 347)			_this->y = v->y;
            		}
HXLINE( 348)		{
HXLINE( 348)			 ::box2D::common::math::B2Vec2 _this1 = this->m_localCenterB;
HXDLIN( 348)			 ::box2D::common::math::B2Vec2 v1 = bB->getLocalCenter();
HXDLIN( 348)			_this1->x = v1->x;
HXDLIN( 348)			_this1->y = v1->y;
            		}
HXLINE( 350)		 ::box2D::common::math::B2Transform xf1 = bA->getTransform();
HXLINE( 351)		 ::box2D::common::math::B2Transform xf2 = bB->getTransform();
HXLINE( 355)		tMat = bA->m_xf->R;
HXLINE( 356)		Float r1X = (this->m_localAnchor1->x - this->m_localCenterA->x);
HXLINE( 357)		Float r1Y = (this->m_localAnchor1->y - this->m_localCenterA->y);
HXLINE( 358)		Float tX1 = (tMat->col1->x * r1X);
HXDLIN( 358)		tX = (tX1 + (tMat->col2->x * r1Y));
HXLINE( 359)		Float r1Y1 = (tMat->col1->y * r1X);
HXDLIN( 359)		r1Y = (r1Y1 + (tMat->col2->y * r1Y));
HXLINE( 360)		r1X = tX;
HXLINE( 362)		tMat = bB->m_xf->R;
HXLINE( 363)		Float r2X = (this->m_localAnchor2->x - this->m_localCenterB->x);
HXLINE( 364)		Float r2Y = (this->m_localAnchor2->y - this->m_localCenterB->y);
HXLINE( 365)		Float tX2 = (tMat->col1->x * r2X);
HXDLIN( 365)		tX = (tX2 + (tMat->col2->x * r2Y));
HXLINE( 366)		Float r2Y1 = (tMat->col1->y * r2X);
HXDLIN( 366)		r2Y = (r2Y1 + (tMat->col2->y * r2Y));
HXLINE( 367)		r2X = tX;
HXLINE( 370)		Float dX = (((bB->m_sweep->c->x + r2X) - bA->m_sweep->c->x) - r1X);
HXLINE( 371)		Float dY = (((bB->m_sweep->c->y + r2Y) - bA->m_sweep->c->y) - r1Y);
HXLINE( 373)		this->m_invMassA = bA->m_invMass;
HXLINE( 374)		this->m_invMassB = bB->m_invMass;
HXLINE( 375)		this->m_invIA = bA->m_invI;
HXLINE( 376)		this->m_invIB = bB->m_invI;
HXLINE( 379)		{
HXLINE( 380)			{
HXLINE( 380)				 ::box2D::common::math::B2Vec2 _this2 = this->m_axis;
HXDLIN( 380)				 ::box2D::common::math::B2Vec2 v2 = ::box2D::common::math::B2Math_obj::mulMV(xf1->R,this->m_localXAxis1,null());
HXDLIN( 380)				_this2->x = v2->x;
HXDLIN( 380)				_this2->y = v2->y;
            			}
HXLINE( 382)			Float _hx_tmp = ((dX + r1X) * this->m_axis->y);
HXDLIN( 382)			this->m_a1 = (_hx_tmp - ((dY + r1Y) * this->m_axis->x));
HXLINE( 384)			Float _hx_tmp1 = (r2X * this->m_axis->y);
HXDLIN( 384)			this->m_a2 = (_hx_tmp1 - (r2Y * this->m_axis->x));
HXLINE( 386)			Float _hx_tmp2 = (this->m_invMassA + this->m_invMassB);
HXDLIN( 386)			Float _hx_tmp3 = (_hx_tmp2 + ((this->m_invIA * this->m_a1) * this->m_a1));
HXDLIN( 386)			this->m_motorMass = (_hx_tmp3 + ((this->m_invIB * this->m_a2) * this->m_a2));
HXLINE( 387)			Float _hx_tmp4;
HXDLIN( 387)			if ((this->m_motorMass > ((Float)2.2250738585072014e-308))) {
HXLINE( 387)				_hx_tmp4 = ((Float)((Float)1.0) / (Float)this->m_motorMass);
            			}
            			else {
HXLINE( 387)				_hx_tmp4 = ((Float)0.0);
            			}
HXDLIN( 387)			this->m_motorMass = _hx_tmp4;
            		}
HXLINE( 391)		{
HXLINE( 392)			{
HXLINE( 392)				 ::box2D::common::math::B2Vec2 _this3 = this->m_perp;
HXDLIN( 392)				 ::box2D::common::math::B2Vec2 v3 = ::box2D::common::math::B2Math_obj::mulMV(xf1->R,this->m_localYAxis1,null());
HXDLIN( 392)				_this3->x = v3->x;
HXDLIN( 392)				_this3->y = v3->y;
            			}
HXLINE( 394)			Float _hx_tmp5 = ((dX + r1X) * this->m_perp->y);
HXDLIN( 394)			this->m_s1 = (_hx_tmp5 - ((dY + r1Y) * this->m_perp->x));
HXLINE( 396)			Float _hx_tmp6 = (r2X * this->m_perp->y);
HXDLIN( 396)			this->m_s2 = (_hx_tmp6 - (r2Y * this->m_perp->x));
HXLINE( 398)			Float m1 = this->m_invMassA;
HXLINE( 399)			Float m2 = this->m_invMassB;
HXLINE( 400)			Float i1 = this->m_invIA;
HXLINE( 401)			Float i2 = this->m_invIB;
HXLINE( 403)			Float _hx_tmp7 = ((m1 + m2) + ((i1 * this->m_s1) * this->m_s1));
HXDLIN( 403)			this->m_K->col1->x = (_hx_tmp7 + ((i2 * this->m_s2) * this->m_s2));
HXLINE( 404)			Float _hx_tmp8 = ((i1 * this->m_s1) * this->m_a1);
HXDLIN( 404)			this->m_K->col1->y = (_hx_tmp8 + ((i2 * this->m_s2) * this->m_a2));
HXLINE( 405)			this->m_K->col2->x = this->m_K->col1->y;
HXLINE( 406)			Float _hx_tmp9 = ((m1 + m2) + ((i1 * this->m_a1) * this->m_a1));
HXDLIN( 406)			this->m_K->col2->y = (_hx_tmp9 + ((i2 * this->m_a2) * this->m_a2));
            		}
HXLINE( 410)		if (this->m_enableLimit) {
HXLINE( 413)			Float jointTransition = (this->m_axis->x * dX);
HXDLIN( 413)			Float jointTransition1 = (jointTransition + (this->m_axis->y * dY));
HXLINE( 414)			Float _hx_tmp10 = ::box2D::common::math::B2Math_obj::abs((this->m_upperTranslation - this->m_lowerTranslation));
HXDLIN( 414)			if ((_hx_tmp10 < (((Float)2.0) * ::box2D::common::B2Settings_obj::b2_linearSlop))) {
HXLINE( 416)				this->m_limitState = (int)3;
            			}
            			else {
HXLINE( 418)				if ((jointTransition1 <= this->m_lowerTranslation)) {
HXLINE( 420)					if ((this->m_limitState != (int)1)) {
HXLINE( 422)						this->m_limitState = (int)1;
HXLINE( 423)						this->m_impulse->y = ((Float)0.0);
            					}
            				}
            				else {
HXLINE( 426)					if ((jointTransition1 >= this->m_upperTranslation)) {
HXLINE( 428)						if ((this->m_limitState != (int)2)) {
HXLINE( 430)							this->m_limitState = (int)2;
HXLINE( 431)							this->m_impulse->y = ((Float)0.0);
            						}
            					}
            					else {
HXLINE( 436)						this->m_limitState = (int)0;
HXLINE( 437)						this->m_impulse->y = ((Float)0.0);
            					}
            				}
            			}
            		}
            		else {
HXLINE( 442)			this->m_limitState = (int)0;
            		}
HXLINE( 445)		if ((this->m_enableMotor == false)) {
HXLINE( 447)			this->m_motorImpulse = ((Float)0.0);
            		}
HXLINE( 450)		if (step->warmStarting) {
HXLINE( 453)			 ::box2D::common::math::B2Vec2 _hx_tmp11 = this->m_impulse;
HXDLIN( 453)			_hx_tmp11->x = (_hx_tmp11->x * step->dtRatio);
HXLINE( 454)			 ::box2D::common::math::B2Vec2 _hx_tmp12 = this->m_impulse;
HXDLIN( 454)			_hx_tmp12->y = (_hx_tmp12->y * step->dtRatio);
HXLINE( 455)			 ::box2D::dynamics::joints::B2LineJoint _hx_tmp13 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 455)			_hx_tmp13->m_motorImpulse = (_hx_tmp13->m_motorImpulse * step->dtRatio);
HXLINE( 458)			Float PX = (this->m_impulse->x * this->m_perp->x);
HXDLIN( 458)			Float PX1 = (PX + ((this->m_motorImpulse + this->m_impulse->y) * this->m_axis->x));
HXLINE( 459)			Float PY = (this->m_impulse->x * this->m_perp->y);
HXDLIN( 459)			Float PY1 = (PY + ((this->m_motorImpulse + this->m_impulse->y) * this->m_axis->y));
HXLINE( 460)			Float L1 = (this->m_impulse->x * this->m_s1);
HXDLIN( 460)			Float L11 = (L1 + ((this->m_motorImpulse + this->m_impulse->y) * this->m_a1));
HXLINE( 461)			Float L2 = (this->m_impulse->x * this->m_s2);
HXDLIN( 461)			Float L21 = (L2 + ((this->m_motorImpulse + this->m_impulse->y) * this->m_a2));
HXLINE( 464)			 ::box2D::common::math::B2Vec2 bA1 = bA->m_linearVelocity;
HXDLIN( 464)			bA1->x = (bA1->x - (this->m_invMassA * PX1));
HXLINE( 465)			 ::box2D::common::math::B2Vec2 bA2 = bA->m_linearVelocity;
HXDLIN( 465)			bA2->y = (bA2->y - (this->m_invMassA * PY1));
HXLINE( 467)			 ::box2D::dynamics::B2Body bA3 = bA;
HXDLIN( 467)			bA3->m_angularVelocity = (bA3->m_angularVelocity - (this->m_invIA * L11));
HXLINE( 470)			 ::box2D::common::math::B2Vec2 bB1 = bB->m_linearVelocity;
HXDLIN( 470)			bB1->x = (bB1->x + (this->m_invMassB * PX1));
HXLINE( 471)			 ::box2D::common::math::B2Vec2 bB2 = bB->m_linearVelocity;
HXDLIN( 471)			bB2->y = (bB2->y + (this->m_invMassB * PY1));
HXLINE( 473)			 ::box2D::dynamics::B2Body bB3 = bB;
HXDLIN( 473)			bB3->m_angularVelocity = (bB3->m_angularVelocity + (this->m_invIB * L21));
            		}
            		else {
HXLINE( 477)			{
HXLINE( 477)				 ::box2D::common::math::B2Vec2 _this4 = this->m_impulse;
HXDLIN( 477)				_this4->x = ((Float)0.0);
HXDLIN( 477)				_this4->y = ((Float)0.0);
            			}
HXLINE( 478)			this->m_motorImpulse = ((Float)0.0);
            		}
            	}


void B2LineJoint_obj::solveVelocityConstraints( ::box2D::dynamics::B2TimeStep step){
            	HX_GC_STACKFRAME(&_hx_pos_046125791711432f_482_solveVelocityConstraints)
HXLINE( 483)		 ::box2D::dynamics::B2Body bA = this->m_bodyA;
HXLINE( 484)		 ::box2D::dynamics::B2Body bB = this->m_bodyB;
HXLINE( 486)		 ::box2D::common::math::B2Vec2 v1 = bA->m_linearVelocity;
HXLINE( 487)		Float w1 = bA->m_angularVelocity;
HXLINE( 488)		 ::box2D::common::math::B2Vec2 v2 = bB->m_linearVelocity;
HXLINE( 489)		Float w2 = bB->m_angularVelocity;
HXLINE( 491)		Float PX;
HXLINE( 492)		Float PY;
HXLINE( 493)		Float L1;
HXLINE( 494)		Float L2;
HXLINE( 497)		bool _hx_tmp;
HXDLIN( 497)		if (this->m_enableMotor) {
HXLINE( 497)			_hx_tmp = (this->m_limitState != (int)3);
            		}
            		else {
HXLINE( 497)			_hx_tmp = false;
            		}
HXDLIN( 497)		if (_hx_tmp) {
HXLINE( 500)			Float Cdot = this->m_axis->x;
HXDLIN( 500)			Float Cdot1 = (Cdot * (v2->x - v1->x));
HXDLIN( 500)			Float Cdot2 = this->m_axis->y;
HXDLIN( 500)			Float Cdot3 = (Cdot1 + (Cdot2 * (v2->y - v1->y)));
HXDLIN( 500)			Float Cdot4 = (Cdot3 + (this->m_a2 * w2));
HXDLIN( 500)			Float Cdot5 = (Cdot4 - (this->m_a1 * w1));
HXLINE( 501)			Float impulse = this->m_motorMass;
HXDLIN( 501)			Float impulse1 = (impulse * (this->m_motorSpeed - Cdot5));
HXLINE( 502)			Float oldImpulse = this->m_motorImpulse;
HXLINE( 503)			Float maxImpulse = (step->dt * this->m_maxMotorForce);
HXLINE( 504)			this->m_motorImpulse = ::box2D::common::math::B2Math_obj::clamp((this->m_motorImpulse + impulse1),-(maxImpulse),maxImpulse);
HXLINE( 505)			impulse1 = (this->m_motorImpulse - oldImpulse);
HXLINE( 507)			PX = (impulse1 * this->m_axis->x);
HXLINE( 508)			PY = (impulse1 * this->m_axis->y);
HXLINE( 509)			L1 = (impulse1 * this->m_a1);
HXLINE( 510)			L2 = (impulse1 * this->m_a2);
HXLINE( 512)			 ::box2D::common::math::B2Vec2 v11 = v1;
HXDLIN( 512)			v11->x = (v11->x - (this->m_invMassA * PX));
HXLINE( 513)			 ::box2D::common::math::B2Vec2 v12 = v1;
HXDLIN( 513)			v12->y = (v12->y - (this->m_invMassA * PY));
HXLINE( 514)			w1 = (w1 - (this->m_invIA * L1));
HXLINE( 516)			 ::box2D::common::math::B2Vec2 v21 = v2;
HXDLIN( 516)			v21->x = (v21->x + (this->m_invMassB * PX));
HXLINE( 517)			 ::box2D::common::math::B2Vec2 v22 = v2;
HXDLIN( 517)			v22->y = (v22->y + (this->m_invMassB * PY));
HXLINE( 518)			w2 = (w2 + (this->m_invIB * L2));
            		}
HXLINE( 522)		Float Cdot11 = this->m_perp->x;
HXDLIN( 522)		Float Cdot12 = (Cdot11 * (v2->x - v1->x));
HXDLIN( 522)		Float Cdot13 = this->m_perp->y;
HXDLIN( 522)		Float Cdot14 = (Cdot12 + (Cdot13 * (v2->y - v1->y)));
HXDLIN( 522)		Float Cdot15 = (Cdot14 + (this->m_s2 * w2));
HXDLIN( 522)		Float Cdot16 = (Cdot15 - (this->m_s1 * w1));
HXLINE( 524)		bool _hx_tmp1;
HXDLIN( 524)		if (this->m_enableLimit) {
HXLINE( 524)			_hx_tmp1 = (this->m_limitState != (int)0);
            		}
            		else {
HXLINE( 524)			_hx_tmp1 = false;
            		}
HXDLIN( 524)		if (_hx_tmp1) {
HXLINE( 528)			Float Cdot21 = this->m_axis->x;
HXDLIN( 528)			Float Cdot22 = (Cdot21 * (v2->x - v1->x));
HXDLIN( 528)			Float Cdot23 = this->m_axis->y;
HXDLIN( 528)			Float Cdot24 = (Cdot22 + (Cdot23 * (v2->y - v1->y)));
HXDLIN( 528)			Float Cdot25 = (Cdot24 + (this->m_a2 * w2));
HXDLIN( 528)			Float Cdot26 = (Cdot25 - (this->m_a1 * w1));
HXLINE( 530)			 ::box2D::common::math::B2Vec2 f1 = this->m_impulse->copy(null());
HXLINE( 531)			 ::box2D::common::math::B2Mat22 df = this->m_K;
HXDLIN( 531)			 ::box2D::common::math::B2Vec2 df1 = df->solve( ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null()),-(Cdot16),-(Cdot26));
HXLINE( 533)			this->m_impulse->add(df1);
HXLINE( 535)			if ((this->m_limitState == (int)1)) {
HXLINE( 537)				this->m_impulse->y = ::box2D::common::math::B2Math_obj::max(this->m_impulse->y,((Float)0.0));
            			}
            			else {
HXLINE( 539)				if ((this->m_limitState == (int)2)) {
HXLINE( 541)					this->m_impulse->y = ::box2D::common::math::B2Math_obj::min(this->m_impulse->y,((Float)0.0));
            				}
            			}
HXLINE( 545)			Float b = (-(Cdot16) - ((this->m_impulse->y - f1->y) * this->m_K->col2->x));
HXLINE( 546)			Float f2r;
HXLINE( 547)			if ((this->m_K->col1->x != ((Float)0.0))) {
HXLINE( 549)				f2r = (((Float)b / (Float)this->m_K->col1->x) + f1->x);
            			}
            			else {
HXLINE( 551)				f2r = f1->x;
            			}
HXLINE( 553)			this->m_impulse->x = f2r;
HXLINE( 555)			df1->x = (this->m_impulse->x - f1->x);
HXLINE( 556)			df1->y = (this->m_impulse->y - f1->y);
HXLINE( 558)			Float PX1 = (df1->x * this->m_perp->x);
HXDLIN( 558)			PX = (PX1 + (df1->y * this->m_axis->x));
HXLINE( 559)			Float PY1 = (df1->x * this->m_perp->y);
HXDLIN( 559)			PY = (PY1 + (df1->y * this->m_axis->y));
HXLINE( 560)			Float L11 = (df1->x * this->m_s1);
HXDLIN( 560)			L1 = (L11 + (df1->y * this->m_a1));
HXLINE( 561)			Float L21 = (df1->x * this->m_s2);
HXDLIN( 561)			L2 = (L21 + (df1->y * this->m_a2));
HXLINE( 563)			 ::box2D::common::math::B2Vec2 v13 = v1;
HXDLIN( 563)			v13->x = (v13->x - (this->m_invMassA * PX));
HXLINE( 564)			 ::box2D::common::math::B2Vec2 v14 = v1;
HXDLIN( 564)			v14->y = (v14->y - (this->m_invMassA * PY));
HXLINE( 565)			w1 = (w1 - (this->m_invIA * L1));
HXLINE( 567)			 ::box2D::common::math::B2Vec2 v23 = v2;
HXDLIN( 567)			v23->x = (v23->x + (this->m_invMassB * PX));
HXLINE( 568)			 ::box2D::common::math::B2Vec2 v24 = v2;
HXDLIN( 568)			v24->y = (v24->y + (this->m_invMassB * PY));
HXLINE( 569)			w2 = (w2 + (this->m_invIB * L2));
            		}
            		else {
HXLINE( 574)			Float df2;
HXLINE( 575)			if ((this->m_K->col1->x != ((Float)0.0))) {
HXLINE( 577)				df2 = ((Float)-(Cdot16) / (Float)this->m_K->col1->x);
            			}
            			else {
HXLINE( 579)				df2 = ((Float)0.0);
            			}
HXLINE( 581)			 ::box2D::common::math::B2Vec2 _hx_tmp2 = this->m_impulse;
HXDLIN( 581)			_hx_tmp2->x = (_hx_tmp2->x + df2);
HXLINE( 583)			PX = (df2 * this->m_perp->x);
HXLINE( 584)			PY = (df2 * this->m_perp->y);
HXLINE( 585)			L1 = (df2 * this->m_s1);
HXLINE( 586)			L2 = (df2 * this->m_s2);
HXLINE( 588)			 ::box2D::common::math::B2Vec2 v15 = v1;
HXDLIN( 588)			v15->x = (v15->x - (this->m_invMassA * PX));
HXLINE( 589)			 ::box2D::common::math::B2Vec2 v16 = v1;
HXDLIN( 589)			v16->y = (v16->y - (this->m_invMassA * PY));
HXLINE( 590)			w1 = (w1 - (this->m_invIA * L1));
HXLINE( 592)			 ::box2D::common::math::B2Vec2 v25 = v2;
HXDLIN( 592)			v25->x = (v25->x + (this->m_invMassB * PX));
HXLINE( 593)			 ::box2D::common::math::B2Vec2 v26 = v2;
HXDLIN( 593)			v26->y = (v26->y + (this->m_invMassB * PY));
HXLINE( 594)			w2 = (w2 + (this->m_invIB * L2));
            		}
HXLINE( 597)		{
HXLINE( 597)			 ::box2D::common::math::B2Vec2 _this = bA->m_linearVelocity;
HXDLIN( 597)			_this->x = v1->x;
HXDLIN( 597)			_this->y = v1->y;
            		}
HXLINE( 598)		bA->m_angularVelocity = w1;
HXLINE( 599)		{
HXLINE( 599)			 ::box2D::common::math::B2Vec2 _this1 = bB->m_linearVelocity;
HXDLIN( 599)			_this1->x = v2->x;
HXDLIN( 599)			_this1->y = v2->y;
            		}
HXLINE( 600)		bB->m_angularVelocity = w2;
            	}


bool B2LineJoint_obj::solvePositionConstraints(Float baumgarte){
            	HX_GC_STACKFRAME(&_hx_pos_046125791711432f_604_solvePositionConstraints)
HXLINE( 608)		Float limitC;
HXLINE( 609)		Float oldLimitImpulse;
HXLINE( 611)		 ::box2D::dynamics::B2Body bA = this->m_bodyA;
HXLINE( 612)		 ::box2D::dynamics::B2Body bB = this->m_bodyB;
HXLINE( 614)		 ::box2D::common::math::B2Vec2 c1 = bA->m_sweep->c;
HXLINE( 615)		Float a1 = bA->m_sweep->a;
HXLINE( 617)		 ::box2D::common::math::B2Vec2 c2 = bB->m_sweep->c;
HXLINE( 618)		Float a2 = bB->m_sweep->a;
HXLINE( 620)		 ::box2D::common::math::B2Mat22 tMat;
HXLINE( 621)		Float tX;
HXLINE( 623)		Float m1;
HXLINE( 624)		Float m2;
HXLINE( 625)		Float i1;
HXLINE( 626)		Float i2;
HXLINE( 629)		Float linearError = ((Float)0.0);
HXLINE( 630)		Float angularError = ((Float)0.0);
HXLINE( 631)		bool active = false;
HXLINE( 632)		Float C2 = ((Float)0.0);
HXLINE( 634)		 ::box2D::common::math::B2Mat22 R1 = ::box2D::common::math::B2Mat22_obj::fromAngle(a1);
HXLINE( 635)		 ::box2D::common::math::B2Mat22 R2 = ::box2D::common::math::B2Mat22_obj::fromAngle(a2);
HXLINE( 638)		tMat = R1;
HXLINE( 639)		Float r1X = (this->m_localAnchor1->x - this->m_localCenterA->x);
HXLINE( 640)		Float r1Y = (this->m_localAnchor1->y - this->m_localCenterA->y);
HXLINE( 641)		Float tX1 = (tMat->col1->x * r1X);
HXDLIN( 641)		tX = (tX1 + (tMat->col2->x * r1Y));
HXLINE( 642)		Float r1Y1 = (tMat->col1->y * r1X);
HXDLIN( 642)		r1Y = (r1Y1 + (tMat->col2->y * r1Y));
HXLINE( 643)		r1X = tX;
HXLINE( 645)		tMat = R2;
HXLINE( 646)		Float r2X = (this->m_localAnchor2->x - this->m_localCenterB->x);
HXLINE( 647)		Float r2Y = (this->m_localAnchor2->y - this->m_localCenterB->y);
HXLINE( 648)		Float tX2 = (tMat->col1->x * r2X);
HXDLIN( 648)		tX = (tX2 + (tMat->col2->x * r2Y));
HXLINE( 649)		Float r2Y1 = (tMat->col1->y * r2X);
HXDLIN( 649)		r2Y = (r2Y1 + (tMat->col2->y * r2Y));
HXLINE( 650)		r2X = tX;
HXLINE( 652)		Float dX = (((c2->x + r2X) - c1->x) - r1X);
HXLINE( 653)		Float dY = (((c2->y + r2Y) - c1->y) - r1Y);
HXLINE( 655)		if (this->m_enableLimit) {
HXLINE( 657)			this->m_axis = ::box2D::common::math::B2Math_obj::mulMV(R1,this->m_localXAxis1,null());
HXLINE( 660)			Float _hx_tmp = ((dX + r1X) * this->m_axis->y);
HXDLIN( 660)			this->m_a1 = (_hx_tmp - ((dY + r1Y) * this->m_axis->x));
HXLINE( 662)			Float _hx_tmp1 = (r2X * this->m_axis->y);
HXDLIN( 662)			this->m_a2 = (_hx_tmp1 - (r2Y * this->m_axis->x));
HXLINE( 664)			Float translation = (this->m_axis->x * dX);
HXDLIN( 664)			Float translation1 = (translation + (this->m_axis->y * dY));
HXLINE( 665)			Float _hx_tmp2 = ::box2D::common::math::B2Math_obj::abs((this->m_upperTranslation - this->m_lowerTranslation));
HXDLIN( 665)			if ((_hx_tmp2 < (((Float)2.0) * ::box2D::common::B2Settings_obj::b2_linearSlop))) {
HXLINE( 668)				C2 = ::box2D::common::math::B2Math_obj::clamp(translation1,-(::box2D::common::B2Settings_obj::b2_maxLinearCorrection),::box2D::common::B2Settings_obj::b2_maxLinearCorrection);
HXLINE( 669)				linearError = ::box2D::common::math::B2Math_obj::abs(translation1);
HXLINE( 670)				active = true;
            			}
            			else {
HXLINE( 672)				if ((translation1 <= this->m_lowerTranslation)) {
HXLINE( 675)					C2 = ::box2D::common::math::B2Math_obj::clamp(((translation1 - this->m_lowerTranslation) + ::box2D::common::B2Settings_obj::b2_linearSlop),-(::box2D::common::B2Settings_obj::b2_maxLinearCorrection),((Float)0.0));
HXLINE( 676)					linearError = (this->m_lowerTranslation - translation1);
HXLINE( 677)					active = true;
            				}
            				else {
HXLINE( 679)					if ((translation1 >= this->m_upperTranslation)) {
HXLINE( 682)						C2 = ::box2D::common::math::B2Math_obj::clamp(((translation1 - this->m_upperTranslation) + ::box2D::common::B2Settings_obj::b2_linearSlop),((Float)0.0),::box2D::common::B2Settings_obj::b2_maxLinearCorrection);
HXLINE( 683)						linearError = (translation1 - this->m_upperTranslation);
HXLINE( 684)						active = true;
            					}
            				}
            			}
            		}
HXLINE( 688)		this->m_perp = ::box2D::common::math::B2Math_obj::mulMV(R1,this->m_localYAxis1,null());
HXLINE( 691)		Float _hx_tmp3 = ((dX + r1X) * this->m_perp->y);
HXDLIN( 691)		this->m_s1 = (_hx_tmp3 - ((dY + r1Y) * this->m_perp->x));
HXLINE( 693)		Float _hx_tmp4 = (r2X * this->m_perp->y);
HXDLIN( 693)		this->m_s2 = (_hx_tmp4 - (r2Y * this->m_perp->x));
HXLINE( 695)		 ::box2D::common::math::B2Vec2 impulse =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 696)		Float C1 = (this->m_perp->x * dX);
HXDLIN( 696)		Float C11 = (C1 + (this->m_perp->y * dY));
HXLINE( 698)		linearError = ::box2D::common::math::B2Math_obj::max(linearError,::box2D::common::math::B2Math_obj::abs(C11));
HXLINE( 699)		angularError = ((Float)0.0);
HXLINE( 701)		if (active) {
HXLINE( 703)			m1 = this->m_invMassA;
HXLINE( 704)			m2 = this->m_invMassB;
HXLINE( 705)			i1 = this->m_invIA;
HXLINE( 706)			i2 = this->m_invIB;
HXLINE( 708)			Float _hx_tmp5 = ((m1 + m2) + ((i1 * this->m_s1) * this->m_s1));
HXDLIN( 708)			this->m_K->col1->x = (_hx_tmp5 + ((i2 * this->m_s2) * this->m_s2));
HXLINE( 709)			Float _hx_tmp6 = ((i1 * this->m_s1) * this->m_a1);
HXDLIN( 709)			this->m_K->col1->y = (_hx_tmp6 + ((i2 * this->m_s2) * this->m_a2));
HXLINE( 710)			this->m_K->col2->x = this->m_K->col1->y;
HXLINE( 711)			Float _hx_tmp7 = ((m1 + m2) + ((i1 * this->m_a1) * this->m_a1));
HXDLIN( 711)			this->m_K->col2->y = (_hx_tmp7 + ((i2 * this->m_a2) * this->m_a2));
HXLINE( 713)			this->m_K->solve(impulse,-(C11),-(C2));
            		}
            		else {
HXLINE( 717)			m1 = this->m_invMassA;
HXLINE( 718)			m2 = this->m_invMassB;
HXLINE( 719)			i1 = this->m_invIA;
HXLINE( 720)			i2 = this->m_invIB;
HXLINE( 722)			Float k11 = ((m1 + m2) + ((i1 * this->m_s1) * this->m_s1));
HXDLIN( 722)			Float k111 = (k11 + ((i2 * this->m_s2) * this->m_s2));
HXLINE( 724)			Float impulse1;
HXLINE( 725)			if ((k111 != ((Float)0.0))) {
HXLINE( 727)				impulse1 = ((Float)-(C11) / (Float)k111);
            			}
            			else {
HXLINE( 729)				impulse1 = ((Float)0.0);
            			}
HXLINE( 731)			impulse->x = impulse1;
HXLINE( 732)			impulse->y = ((Float)0.0);
            		}
HXLINE( 735)		Float PX = (impulse->x * this->m_perp->x);
HXDLIN( 735)		Float PX1 = (PX + (impulse->y * this->m_axis->x));
HXLINE( 736)		Float PY = (impulse->x * this->m_perp->y);
HXDLIN( 736)		Float PY1 = (PY + (impulse->y * this->m_axis->y));
HXLINE( 737)		Float L1 = (impulse->x * this->m_s1);
HXDLIN( 737)		Float L11 = (L1 + (impulse->y * this->m_a1));
HXLINE( 738)		Float L2 = (impulse->x * this->m_s2);
HXDLIN( 738)		Float L21 = (L2 + (impulse->y * this->m_a2));
HXLINE( 740)		 ::box2D::common::math::B2Vec2 c11 = c1;
HXDLIN( 740)		c11->x = (c11->x - (this->m_invMassA * PX1));
HXLINE( 741)		 ::box2D::common::math::B2Vec2 c12 = c1;
HXDLIN( 741)		c12->y = (c12->y - (this->m_invMassA * PY1));
HXLINE( 742)		a1 = (a1 - (this->m_invIA * L11));
HXLINE( 744)		 ::box2D::common::math::B2Vec2 c21 = c2;
HXDLIN( 744)		c21->x = (c21->x + (this->m_invMassB * PX1));
HXLINE( 745)		 ::box2D::common::math::B2Vec2 c22 = c2;
HXDLIN( 745)		c22->y = (c22->y + (this->m_invMassB * PY1));
HXLINE( 746)		a2 = (a2 + (this->m_invIB * L21));
HXLINE( 750)		bA->m_sweep->a = a1;
HXLINE( 752)		bB->m_sweep->a = a2;
HXLINE( 753)		bA->synchronizeTransform();
HXLINE( 754)		bB->synchronizeTransform();
HXLINE( 756)		if ((linearError <= ::box2D::common::B2Settings_obj::b2_linearSlop)) {
HXLINE( 756)			return (angularError <= ::box2D::common::B2Settings_obj::b2_angularSlop);
            		}
            		else {
HXLINE( 756)			return false;
            		}
HXDLIN( 756)		return false;
            	}



hx::ObjectPtr< B2LineJoint_obj > B2LineJoint_obj::__new( ::box2D::dynamics::joints::B2LineJointDef def) {
	hx::ObjectPtr< B2LineJoint_obj > __this = new B2LineJoint_obj();
	__this->__construct(def);
	return __this;
}

hx::ObjectPtr< B2LineJoint_obj > B2LineJoint_obj::__alloc(hx::Ctx *_hx_ctx, ::box2D::dynamics::joints::B2LineJointDef def) {
	B2LineJoint_obj *__this = (B2LineJoint_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(B2LineJoint_obj), true, "box2D.dynamics.joints.B2LineJoint"));
	*(void **)__this = B2LineJoint_obj::_hx_vtable;
	__this->__construct(def);
	return __this;
}

B2LineJoint_obj::B2LineJoint_obj()
{
}

void B2LineJoint_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(B2LineJoint);
	HX_MARK_MEMBER_NAME(m_localAnchor1,"m_localAnchor1");
	HX_MARK_MEMBER_NAME(m_localAnchor2,"m_localAnchor2");
	HX_MARK_MEMBER_NAME(m_localXAxis1,"m_localXAxis1");
	HX_MARK_MEMBER_NAME(m_localYAxis1,"m_localYAxis1");
	HX_MARK_MEMBER_NAME(m_axis,"m_axis");
	HX_MARK_MEMBER_NAME(m_perp,"m_perp");
	HX_MARK_MEMBER_NAME(m_s1,"m_s1");
	HX_MARK_MEMBER_NAME(m_s2,"m_s2");
	HX_MARK_MEMBER_NAME(m_a1,"m_a1");
	HX_MARK_MEMBER_NAME(m_a2,"m_a2");
	HX_MARK_MEMBER_NAME(m_K,"m_K");
	HX_MARK_MEMBER_NAME(m_impulse,"m_impulse");
	HX_MARK_MEMBER_NAME(m_motorMass,"m_motorMass");
	HX_MARK_MEMBER_NAME(m_motorImpulse,"m_motorImpulse");
	HX_MARK_MEMBER_NAME(m_lowerTranslation,"m_lowerTranslation");
	HX_MARK_MEMBER_NAME(m_upperTranslation,"m_upperTranslation");
	HX_MARK_MEMBER_NAME(m_maxMotorForce,"m_maxMotorForce");
	HX_MARK_MEMBER_NAME(m_motorSpeed,"m_motorSpeed");
	HX_MARK_MEMBER_NAME(m_enableLimit,"m_enableLimit");
	HX_MARK_MEMBER_NAME(m_enableMotor,"m_enableMotor");
	HX_MARK_MEMBER_NAME(m_limitState,"m_limitState");
	 ::box2D::dynamics::joints::B2Joint_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void B2LineJoint_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(m_localAnchor1,"m_localAnchor1");
	HX_VISIT_MEMBER_NAME(m_localAnchor2,"m_localAnchor2");
	HX_VISIT_MEMBER_NAME(m_localXAxis1,"m_localXAxis1");
	HX_VISIT_MEMBER_NAME(m_localYAxis1,"m_localYAxis1");
	HX_VISIT_MEMBER_NAME(m_axis,"m_axis");
	HX_VISIT_MEMBER_NAME(m_perp,"m_perp");
	HX_VISIT_MEMBER_NAME(m_s1,"m_s1");
	HX_VISIT_MEMBER_NAME(m_s2,"m_s2");
	HX_VISIT_MEMBER_NAME(m_a1,"m_a1");
	HX_VISIT_MEMBER_NAME(m_a2,"m_a2");
	HX_VISIT_MEMBER_NAME(m_K,"m_K");
	HX_VISIT_MEMBER_NAME(m_impulse,"m_impulse");
	HX_VISIT_MEMBER_NAME(m_motorMass,"m_motorMass");
	HX_VISIT_MEMBER_NAME(m_motorImpulse,"m_motorImpulse");
	HX_VISIT_MEMBER_NAME(m_lowerTranslation,"m_lowerTranslation");
	HX_VISIT_MEMBER_NAME(m_upperTranslation,"m_upperTranslation");
	HX_VISIT_MEMBER_NAME(m_maxMotorForce,"m_maxMotorForce");
	HX_VISIT_MEMBER_NAME(m_motorSpeed,"m_motorSpeed");
	HX_VISIT_MEMBER_NAME(m_enableLimit,"m_enableLimit");
	HX_VISIT_MEMBER_NAME(m_enableMotor,"m_enableMotor");
	HX_VISIT_MEMBER_NAME(m_limitState,"m_limitState");
	 ::box2D::dynamics::joints::B2Joint_obj::__Visit(HX_VISIT_ARG);
}

hx::Val B2LineJoint_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"m_K") ) { return hx::Val( m_K ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"m_s1") ) { return hx::Val( m_s1 ); }
		if (HX_FIELD_EQ(inName,"m_s2") ) { return hx::Val( m_s2 ); }
		if (HX_FIELD_EQ(inName,"m_a1") ) { return hx::Val( m_a1 ); }
		if (HX_FIELD_EQ(inName,"m_a2") ) { return hx::Val( m_a2 ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"m_axis") ) { return hx::Val( m_axis ); }
		if (HX_FIELD_EQ(inName,"m_perp") ) { return hx::Val( m_perp ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"setLimits") ) { return hx::Val( setLimits_dyn() ); }
		if (HX_FIELD_EQ(inName,"m_impulse") ) { return hx::Val( m_impulse ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"getAnchorA") ) { return hx::Val( getAnchorA_dyn() ); }
		if (HX_FIELD_EQ(inName,"getAnchorB") ) { return hx::Val( getAnchorB_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"enableLimit") ) { return hx::Val( enableLimit_dyn() ); }
		if (HX_FIELD_EQ(inName,"enableMotor") ) { return hx::Val( enableMotor_dyn() ); }
		if (HX_FIELD_EQ(inName,"m_motorMass") ) { return hx::Val( m_motorMass ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"m_motorSpeed") ) { return hx::Val( m_motorSpeed ); }
		if (HX_FIELD_EQ(inName,"m_limitState") ) { return hx::Val( m_limitState ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"getJointSpeed") ) { return hx::Val( getJointSpeed_dyn() ); }
		if (HX_FIELD_EQ(inName,"getLowerLimit") ) { return hx::Val( getLowerLimit_dyn() ); }
		if (HX_FIELD_EQ(inName,"getUpperLimit") ) { return hx::Val( getUpperLimit_dyn() ); }
		if (HX_FIELD_EQ(inName,"setMotorSpeed") ) { return hx::Val( setMotorSpeed_dyn() ); }
		if (HX_FIELD_EQ(inName,"getMotorSpeed") ) { return hx::Val( getMotorSpeed_dyn() ); }
		if (HX_FIELD_EQ(inName,"getMotorForce") ) { return hx::Val( getMotorForce_dyn() ); }
		if (HX_FIELD_EQ(inName,"m_localXAxis1") ) { return hx::Val( m_localXAxis1 ); }
		if (HX_FIELD_EQ(inName,"m_localYAxis1") ) { return hx::Val( m_localYAxis1 ); }
		if (HX_FIELD_EQ(inName,"m_enableLimit") ) { return hx::Val( m_enableLimit ); }
		if (HX_FIELD_EQ(inName,"m_enableMotor") ) { return hx::Val( m_enableMotor ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"isLimitEnabled") ) { return hx::Val( isLimitEnabled_dyn() ); }
		if (HX_FIELD_EQ(inName,"isMotorEnabled") ) { return hx::Val( isMotorEnabled_dyn() ); }
		if (HX_FIELD_EQ(inName,"m_localAnchor1") ) { return hx::Val( m_localAnchor1 ); }
		if (HX_FIELD_EQ(inName,"m_localAnchor2") ) { return hx::Val( m_localAnchor2 ); }
		if (HX_FIELD_EQ(inName,"m_motorImpulse") ) { return hx::Val( m_motorImpulse ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"m_maxMotorForce") ) { return hx::Val( m_maxMotorForce ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"getReactionForce") ) { return hx::Val( getReactionForce_dyn() ); }
		if (HX_FIELD_EQ(inName,"setMaxMotorForce") ) { return hx::Val( setMaxMotorForce_dyn() ); }
		if (HX_FIELD_EQ(inName,"getMaxMotorForce") ) { return hx::Val( getMaxMotorForce_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"getReactionTorque") ) { return hx::Val( getReactionTorque_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"m_lowerTranslation") ) { return hx::Val( m_lowerTranslation ); }
		if (HX_FIELD_EQ(inName,"m_upperTranslation") ) { return hx::Val( m_upperTranslation ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"getJointTranslation") ) { return hx::Val( getJointTranslation_dyn() ); }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"initVelocityConstraints") ) { return hx::Val( initVelocityConstraints_dyn() ); }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"solveVelocityConstraints") ) { return hx::Val( solveVelocityConstraints_dyn() ); }
		if (HX_FIELD_EQ(inName,"solvePositionConstraints") ) { return hx::Val( solvePositionConstraints_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val B2LineJoint_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"m_K") ) { m_K=inValue.Cast<  ::box2D::common::math::B2Mat22 >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"m_s1") ) { m_s1=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"m_s2") ) { m_s2=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"m_a1") ) { m_a1=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"m_a2") ) { m_a2=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"m_axis") ) { m_axis=inValue.Cast<  ::box2D::common::math::B2Vec2 >(); return inValue; }
		if (HX_FIELD_EQ(inName,"m_perp") ) { m_perp=inValue.Cast<  ::box2D::common::math::B2Vec2 >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"m_impulse") ) { m_impulse=inValue.Cast<  ::box2D::common::math::B2Vec2 >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"m_motorMass") ) { m_motorMass=inValue.Cast< Float >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"m_motorSpeed") ) { m_motorSpeed=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"m_limitState") ) { m_limitState=inValue.Cast< int >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"m_localXAxis1") ) { m_localXAxis1=inValue.Cast<  ::box2D::common::math::B2Vec2 >(); return inValue; }
		if (HX_FIELD_EQ(inName,"m_localYAxis1") ) { m_localYAxis1=inValue.Cast<  ::box2D::common::math::B2Vec2 >(); return inValue; }
		if (HX_FIELD_EQ(inName,"m_enableLimit") ) { m_enableLimit=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"m_enableMotor") ) { m_enableMotor=inValue.Cast< bool >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"m_localAnchor1") ) { m_localAnchor1=inValue.Cast<  ::box2D::common::math::B2Vec2 >(); return inValue; }
		if (HX_FIELD_EQ(inName,"m_localAnchor2") ) { m_localAnchor2=inValue.Cast<  ::box2D::common::math::B2Vec2 >(); return inValue; }
		if (HX_FIELD_EQ(inName,"m_motorImpulse") ) { m_motorImpulse=inValue.Cast< Float >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"m_maxMotorForce") ) { m_maxMotorForce=inValue.Cast< Float >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"m_lowerTranslation") ) { m_lowerTranslation=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"m_upperTranslation") ) { m_upperTranslation=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void B2LineJoint_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("m_localAnchor1","\x43","\x30","\xee","\x9e"));
	outFields->push(HX_HCSTRING("m_localAnchor2","\x44","\x30","\xee","\x9e"));
	outFields->push(HX_HCSTRING("m_localXAxis1","\x91","\x6a","\xba","\x8d"));
	outFields->push(HX_HCSTRING("m_localYAxis1","\xf0","\xc6","\x15","\xf4"));
	outFields->push(HX_HCSTRING("m_axis","\xf3","\x8c","\x70","\x88"));
	outFields->push(HX_HCSTRING("m_perp","\x45","\x5d","\x4c","\x92"));
	outFields->push(HX_HCSTRING("m_s1","\x30","\xbc","\x54","\x48"));
	outFields->push(HX_HCSTRING("m_s2","\x31","\xbc","\x54","\x48"));
	outFields->push(HX_HCSTRING("m_a1","\x82","\xac","\x54","\x48"));
	outFields->push(HX_HCSTRING("m_a2","\x83","\xac","\x54","\x48"));
	outFields->push(HX_HCSTRING("m_K","\xb9","\x08","\x53","\x00"));
	outFields->push(HX_HCSTRING("m_impulse","\xa3","\x5f","\x3f","\x78"));
	outFields->push(HX_HCSTRING("m_motorMass","\x77","\xc2","\x33","\xe8"));
	outFields->push(HX_HCSTRING("m_motorImpulse","\x12","\x63","\x1d","\xf1"));
	outFields->push(HX_HCSTRING("m_lowerTranslation","\xc2","\x1f","\x0a","\xc8"));
	outFields->push(HX_HCSTRING("m_upperTranslation","\x01","\xea","\xf9","\x0a"));
	outFields->push(HX_HCSTRING("m_maxMotorForce","\x68","\x42","\x63","\x1e"));
	outFields->push(HX_HCSTRING("m_motorSpeed","\xa4","\x68","\x5d","\xc3"));
	outFields->push(HX_HCSTRING("m_enableLimit","\xa6","\x83","\xcf","\x58"));
	outFields->push(HX_HCSTRING("m_enableMotor","\xe0","\xb4","\x32","\xf0"));
	outFields->push(HX_HCSTRING("m_limitState","\xa8","\x2a","\xe1","\x56"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo B2LineJoint_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::box2D::common::math::B2Vec2*/ ,(int)offsetof(B2LineJoint_obj,m_localAnchor1),HX_HCSTRING("m_localAnchor1","\x43","\x30","\xee","\x9e")},
	{hx::fsObject /*::box2D::common::math::B2Vec2*/ ,(int)offsetof(B2LineJoint_obj,m_localAnchor2),HX_HCSTRING("m_localAnchor2","\x44","\x30","\xee","\x9e")},
	{hx::fsObject /*::box2D::common::math::B2Vec2*/ ,(int)offsetof(B2LineJoint_obj,m_localXAxis1),HX_HCSTRING("m_localXAxis1","\x91","\x6a","\xba","\x8d")},
	{hx::fsObject /*::box2D::common::math::B2Vec2*/ ,(int)offsetof(B2LineJoint_obj,m_localYAxis1),HX_HCSTRING("m_localYAxis1","\xf0","\xc6","\x15","\xf4")},
	{hx::fsObject /*::box2D::common::math::B2Vec2*/ ,(int)offsetof(B2LineJoint_obj,m_axis),HX_HCSTRING("m_axis","\xf3","\x8c","\x70","\x88")},
	{hx::fsObject /*::box2D::common::math::B2Vec2*/ ,(int)offsetof(B2LineJoint_obj,m_perp),HX_HCSTRING("m_perp","\x45","\x5d","\x4c","\x92")},
	{hx::fsFloat,(int)offsetof(B2LineJoint_obj,m_s1),HX_HCSTRING("m_s1","\x30","\xbc","\x54","\x48")},
	{hx::fsFloat,(int)offsetof(B2LineJoint_obj,m_s2),HX_HCSTRING("m_s2","\x31","\xbc","\x54","\x48")},
	{hx::fsFloat,(int)offsetof(B2LineJoint_obj,m_a1),HX_HCSTRING("m_a1","\x82","\xac","\x54","\x48")},
	{hx::fsFloat,(int)offsetof(B2LineJoint_obj,m_a2),HX_HCSTRING("m_a2","\x83","\xac","\x54","\x48")},
	{hx::fsObject /*::box2D::common::math::B2Mat22*/ ,(int)offsetof(B2LineJoint_obj,m_K),HX_HCSTRING("m_K","\xb9","\x08","\x53","\x00")},
	{hx::fsObject /*::box2D::common::math::B2Vec2*/ ,(int)offsetof(B2LineJoint_obj,m_impulse),HX_HCSTRING("m_impulse","\xa3","\x5f","\x3f","\x78")},
	{hx::fsFloat,(int)offsetof(B2LineJoint_obj,m_motorMass),HX_HCSTRING("m_motorMass","\x77","\xc2","\x33","\xe8")},
	{hx::fsFloat,(int)offsetof(B2LineJoint_obj,m_motorImpulse),HX_HCSTRING("m_motorImpulse","\x12","\x63","\x1d","\xf1")},
	{hx::fsFloat,(int)offsetof(B2LineJoint_obj,m_lowerTranslation),HX_HCSTRING("m_lowerTranslation","\xc2","\x1f","\x0a","\xc8")},
	{hx::fsFloat,(int)offsetof(B2LineJoint_obj,m_upperTranslation),HX_HCSTRING("m_upperTranslation","\x01","\xea","\xf9","\x0a")},
	{hx::fsFloat,(int)offsetof(B2LineJoint_obj,m_maxMotorForce),HX_HCSTRING("m_maxMotorForce","\x68","\x42","\x63","\x1e")},
	{hx::fsFloat,(int)offsetof(B2LineJoint_obj,m_motorSpeed),HX_HCSTRING("m_motorSpeed","\xa4","\x68","\x5d","\xc3")},
	{hx::fsBool,(int)offsetof(B2LineJoint_obj,m_enableLimit),HX_HCSTRING("m_enableLimit","\xa6","\x83","\xcf","\x58")},
	{hx::fsBool,(int)offsetof(B2LineJoint_obj,m_enableMotor),HX_HCSTRING("m_enableMotor","\xe0","\xb4","\x32","\xf0")},
	{hx::fsInt,(int)offsetof(B2LineJoint_obj,m_limitState),HX_HCSTRING("m_limitState","\xa8","\x2a","\xe1","\x56")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *B2LineJoint_obj_sStaticStorageInfo = 0;
#endif

static ::String B2LineJoint_obj_sMemberFields[] = {
	HX_HCSTRING("getAnchorA","\x36","\x72","\x03","\x52"),
	HX_HCSTRING("getAnchorB","\x37","\x72","\x03","\x52"),
	HX_HCSTRING("getReactionForce","\x0c","\x7f","\x58","\x41"),
	HX_HCSTRING("getReactionTorque","\x89","\x66","\x20","\x85"),
	HX_HCSTRING("getJointTranslation","\x7d","\x48","\x91","\xd8"),
	HX_HCSTRING("getJointSpeed","\x13","\x3e","\xdb","\x3b"),
	HX_HCSTRING("isLimitEnabled","\x90","\x19","\xb5","\x29"),
	HX_HCSTRING("enableLimit","\xb8","\x65","\xd0","\x3f"),
	HX_HCSTRING("getLowerLimit","\xb0","\x0d","\xd2","\x8d"),
	HX_HCSTRING("getUpperLimit","\xaf","\x8e","\x00","\x93"),
	HX_HCSTRING("setLimits","\x1a","\xaa","\xa1","\x4b"),
	HX_HCSTRING("isMotorEnabled","\x96","\xe3","\xf7","\x31"),
	HX_HCSTRING("enableMotor","\xf2","\x96","\x33","\xd7"),
	HX_HCSTRING("setMotorSpeed","\x14","\x2d","\xca","\x93"),
	HX_HCSTRING("getMotorSpeed","\x08","\x4b","\xc4","\x4e"),
	HX_HCSTRING("setMaxMotorForce","\xf8","\xe3","\x50","\x31"),
	HX_HCSTRING("getMaxMotorForce","\x84","\xf6","\x0e","\xdb"),
	HX_HCSTRING("getMotorForce","\x6c","\x65","\xef","\xd1"),
	HX_HCSTRING("initVelocityConstraints","\x29","\xf9","\xf0","\x64"),
	HX_HCSTRING("solveVelocityConstraints","\x1a","\x56","\xac","\xc2"),
	HX_HCSTRING("solvePositionConstraints","\x0e","\x6b","\x88","\xfa"),
	HX_HCSTRING("m_localAnchor1","\x43","\x30","\xee","\x9e"),
	HX_HCSTRING("m_localAnchor2","\x44","\x30","\xee","\x9e"),
	HX_HCSTRING("m_localXAxis1","\x91","\x6a","\xba","\x8d"),
	HX_HCSTRING("m_localYAxis1","\xf0","\xc6","\x15","\xf4"),
	HX_HCSTRING("m_axis","\xf3","\x8c","\x70","\x88"),
	HX_HCSTRING("m_perp","\x45","\x5d","\x4c","\x92"),
	HX_HCSTRING("m_s1","\x30","\xbc","\x54","\x48"),
	HX_HCSTRING("m_s2","\x31","\xbc","\x54","\x48"),
	HX_HCSTRING("m_a1","\x82","\xac","\x54","\x48"),
	HX_HCSTRING("m_a2","\x83","\xac","\x54","\x48"),
	HX_HCSTRING("m_K","\xb9","\x08","\x53","\x00"),
	HX_HCSTRING("m_impulse","\xa3","\x5f","\x3f","\x78"),
	HX_HCSTRING("m_motorMass","\x77","\xc2","\x33","\xe8"),
	HX_HCSTRING("m_motorImpulse","\x12","\x63","\x1d","\xf1"),
	HX_HCSTRING("m_lowerTranslation","\xc2","\x1f","\x0a","\xc8"),
	HX_HCSTRING("m_upperTranslation","\x01","\xea","\xf9","\x0a"),
	HX_HCSTRING("m_maxMotorForce","\x68","\x42","\x63","\x1e"),
	HX_HCSTRING("m_motorSpeed","\xa4","\x68","\x5d","\xc3"),
	HX_HCSTRING("m_enableLimit","\xa6","\x83","\xcf","\x58"),
	HX_HCSTRING("m_enableMotor","\xe0","\xb4","\x32","\xf0"),
	HX_HCSTRING("m_limitState","\xa8","\x2a","\xe1","\x56"),
	::String(null()) };

static void B2LineJoint_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(B2LineJoint_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void B2LineJoint_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(B2LineJoint_obj::__mClass,"__mClass");
};

#endif

hx::Class B2LineJoint_obj::__mClass;

void B2LineJoint_obj::__register()
{
	hx::Object *dummy = new B2LineJoint_obj;
	B2LineJoint_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("box2D.dynamics.joints.B2LineJoint","\xaa","\x0b","\xe1","\x05");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = B2LineJoint_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(B2LineJoint_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< B2LineJoint_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = B2LineJoint_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = B2LineJoint_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = B2LineJoint_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace box2D
} // end namespace dynamics
} // end namespace joints
