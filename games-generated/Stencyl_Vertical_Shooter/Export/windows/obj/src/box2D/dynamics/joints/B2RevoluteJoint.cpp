// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_box2D_common_B2Settings
#include <box2D/common/B2Settings.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Mat22
#include <box2D/common/math/B2Mat22.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Mat33
#include <box2D/common/math/B2Mat33.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Math
#include <box2D/common/math/B2Math.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Sweep
#include <box2D/common/math/B2Sweep.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Transform
#include <box2D/common/math/B2Transform.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Vec2
#include <box2D/common/math/B2Vec2.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Vec3
#include <box2D/common/math/B2Vec3.h>
#endif
#ifndef INCLUDED_box2D_dynamics_B2Body
#include <box2D/dynamics/B2Body.h>
#endif
#ifndef INCLUDED_box2D_dynamics_B2TimeStep
#include <box2D/dynamics/B2TimeStep.h>
#endif
#ifndef INCLUDED_box2D_dynamics_joints_B2Joint
#include <box2D/dynamics/joints/B2Joint.h>
#endif
#ifndef INCLUDED_box2D_dynamics_joints_B2JointDef
#include <box2D/dynamics/joints/B2JointDef.h>
#endif
#ifndef INCLUDED_box2D_dynamics_joints_B2RevoluteJoint
#include <box2D/dynamics/joints/B2RevoluteJoint.h>
#endif
#ifndef INCLUDED_box2D_dynamics_joints_B2RevoluteJointDef
#include <box2D/dynamics/joints/B2RevoluteJointDef.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_48708f914c341c71_177_new,"box2D.dynamics.joints.B2RevoluteJoint","new",0xb354816a,"box2D.dynamics.joints.B2RevoluteJoint.new","box2D/dynamics/joints/B2RevoluteJoint.hx",177,0xefbcf9a7)
HX_LOCAL_STACK_FRAME(_hx_pos_48708f914c341c71_57_getAnchorA,"box2D.dynamics.joints.B2RevoluteJoint","getAnchorA",0x1be3566c,"box2D.dynamics.joints.B2RevoluteJoint.getAnchorA","box2D/dynamics/joints/B2RevoluteJoint.hx",57,0xefbcf9a7)
HX_LOCAL_STACK_FRAME(_hx_pos_48708f914c341c71_61_getAnchorB,"box2D.dynamics.joints.B2RevoluteJoint","getAnchorB",0x1be3566d,"box2D.dynamics.joints.B2RevoluteJoint.getAnchorB","box2D/dynamics/joints/B2RevoluteJoint.hx",61,0xefbcf9a7)
HX_LOCAL_STACK_FRAME(_hx_pos_48708f914c341c71_66_getReactionForce,"box2D.dynamics.joints.B2RevoluteJoint","getReactionForce",0x1fc26fc2,"box2D.dynamics.joints.B2RevoluteJoint.getReactionForce","box2D/dynamics/joints/B2RevoluteJoint.hx",66,0xefbcf9a7)
HX_LOCAL_STACK_FRAME(_hx_pos_48708f914c341c71_70_getReactionTorque,"box2D.dynamics.joints.B2RevoluteJoint","getReactionTorque",0x43691513,"box2D.dynamics.joints.B2RevoluteJoint.getReactionTorque","box2D/dynamics/joints/B2RevoluteJoint.hx",70,0xefbcf9a7)
HX_LOCAL_STACK_FRAME(_hx_pos_48708f914c341c71_79_getJointAngle,"box2D.dynamics.joints.B2RevoluteJoint","getJointAngle",0x212c0be9,"box2D.dynamics.joints.B2RevoluteJoint.getJointAngle","box2D/dynamics/joints/B2RevoluteJoint.hx",79,0xefbcf9a7)
HX_LOCAL_STACK_FRAME(_hx_pos_48708f914c341c71_88_getJointSpeed,"box2D.dynamics.joints.B2RevoluteJoint","getJointSpeed",0x7fb35f9d,"box2D.dynamics.joints.B2RevoluteJoint.getJointSpeed","box2D/dynamics/joints/B2RevoluteJoint.hx",88,0xefbcf9a7)
HX_LOCAL_STACK_FRAME(_hx_pos_48708f914c341c71_95_isLimitEnabled,"box2D.dynamics.joints.B2RevoluteJoint","isLimitEnabled",0x42fa50c6,"box2D.dynamics.joints.B2RevoluteJoint.isLimitEnabled","box2D/dynamics/joints/B2RevoluteJoint.hx",95,0xefbcf9a7)
HX_LOCAL_STACK_FRAME(_hx_pos_48708f914c341c71_102_enableLimit,"box2D.dynamics.joints.B2RevoluteJoint","enableLimit",0x19d830c2,"box2D.dynamics.joints.B2RevoluteJoint.enableLimit","box2D/dynamics/joints/B2RevoluteJoint.hx",102,0xefbcf9a7)
HX_LOCAL_STACK_FRAME(_hx_pos_48708f914c341c71_109_getLowerLimit,"box2D.dynamics.joints.B2RevoluteJoint","getLowerLimit",0xd1aa2f3a,"box2D.dynamics.joints.B2RevoluteJoint.getLowerLimit","box2D/dynamics/joints/B2RevoluteJoint.hx",109,0xefbcf9a7)
HX_LOCAL_STACK_FRAME(_hx_pos_48708f914c341c71_116_getUpperLimit,"box2D.dynamics.joints.B2RevoluteJoint","getUpperLimit",0xd6d8b039,"box2D.dynamics.joints.B2RevoluteJoint.getUpperLimit","box2D/dynamics/joints/B2RevoluteJoint.hx",116,0xefbcf9a7)
HX_LOCAL_STACK_FRAME(_hx_pos_48708f914c341c71_122_setLimits,"box2D.dynamics.joints.B2RevoluteJoint","setLimits",0x3593bea4,"box2D.dynamics.joints.B2RevoluteJoint.setLimits","box2D/dynamics/joints/B2RevoluteJoint.hx",122,0xefbcf9a7)
HX_LOCAL_STACK_FRAME(_hx_pos_48708f914c341c71_131_isMotorEnabled,"box2D.dynamics.joints.B2RevoluteJoint","isMotorEnabled",0x4b3d1acc,"box2D.dynamics.joints.B2RevoluteJoint.isMotorEnabled","box2D/dynamics/joints/B2RevoluteJoint.hx",131,0xefbcf9a7)
HX_LOCAL_STACK_FRAME(_hx_pos_48708f914c341c71_141_enableMotor,"box2D.dynamics.joints.B2RevoluteJoint","enableMotor",0xb13b61fc,"box2D.dynamics.joints.B2RevoluteJoint.enableMotor","box2D/dynamics/joints/B2RevoluteJoint.hx",141,0xefbcf9a7)
HX_LOCAL_STACK_FRAME(_hx_pos_48708f914c341c71_147_setMotorSpeed,"box2D.dynamics.joints.B2RevoluteJoint","setMotorSpeed",0xd7a24e9e,"box2D.dynamics.joints.B2RevoluteJoint.setMotorSpeed","box2D/dynamics/joints/B2RevoluteJoint.hx",147,0xefbcf9a7)
HX_LOCAL_STACK_FRAME(_hx_pos_48708f914c341c71_157_getMotorSpeed,"box2D.dynamics.joints.B2RevoluteJoint","getMotorSpeed",0x929c6c92,"box2D.dynamics.joints.B2RevoluteJoint.getMotorSpeed","box2D/dynamics/joints/B2RevoluteJoint.hx",157,0xefbcf9a7)
HX_LOCAL_STACK_FRAME(_hx_pos_48708f914c341c71_164_setMaxMotorTorque,"box2D.dynamics.joints.B2RevoluteJoint","setMaxMotorTorque",0x4cc8fea7,"box2D.dynamics.joints.B2RevoluteJoint.setMaxMotorTorque","box2D/dynamics/joints/B2RevoluteJoint.hx",164,0xefbcf9a7)
HX_LOCAL_STACK_FRAME(_hx_pos_48708f914c341c71_171_getMotorTorque,"box2D.dynamics.joints.B2RevoluteJoint","getMotorTorque",0x91d84b5f,"box2D.dynamics.joints.B2RevoluteJoint.getMotorTorque","box2D/dynamics/joints/B2RevoluteJoint.hx",171,0xefbcf9a7)
HX_LOCAL_STACK_FRAME(_hx_pos_48708f914c341c71_219_initVelocityConstraints,"box2D.dynamics.joints.B2RevoluteJoint","initVelocityConstraints",0x0a822b33,"box2D.dynamics.joints.B2RevoluteJoint.initVelocityConstraints","box2D/dynamics/joints/B2RevoluteJoint.hx",219,0xefbcf9a7)
HX_LOCAL_STACK_FRAME(_hx_pos_48708f914c341c71_351_solveVelocityConstraints,"box2D.dynamics.joints.B2RevoluteJoint","solveVelocityConstraints",0xfc26ecd0,"box2D.dynamics.joints.B2RevoluteJoint.solveVelocityConstraints","box2D/dynamics/joints/B2RevoluteJoint.hx",351,0xefbcf9a7)
HX_LOCAL_STACK_FRAME(_hx_pos_48708f914c341c71_500_solvePositionConstraints,"box2D.dynamics.joints.B2RevoluteJoint","solvePositionConstraints",0x340301c4,"box2D.dynamics.joints.B2RevoluteJoint.solvePositionConstraints","box2D/dynamics/joints/B2RevoluteJoint.hx",500,0xefbcf9a7)
HX_LOCAL_STACK_FRAME(_hx_pos_48708f914c341c71_499_boot,"box2D.dynamics.joints.B2RevoluteJoint","boot",0x2eb5bbe8,"box2D.dynamics.joints.B2RevoluteJoint.boot","box2D/dynamics/joints/B2RevoluteJoint.hx",499,0xefbcf9a7)
namespace box2D{
namespace dynamics{
namespace joints{

void B2RevoluteJoint_obj::__construct( ::box2D::dynamics::joints::B2RevoluteJointDef def){
            	HX_GC_STACKFRAME(&_hx_pos_48708f914c341c71_177_new)
HXLINE( 178)		super::__construct(def);
HXLINE( 180)		this->K =  ::box2D::common::math::B2Mat22_obj::__alloc( HX_CTX );
HXLINE( 181)		this->K1 =  ::box2D::common::math::B2Mat22_obj::__alloc( HX_CTX );
HXLINE( 182)		this->K2 =  ::box2D::common::math::B2Mat22_obj::__alloc( HX_CTX );
HXLINE( 183)		this->K3 =  ::box2D::common::math::B2Mat22_obj::__alloc( HX_CTX );
HXLINE( 185)		this->impulse3 =  ::box2D::common::math::B2Vec3_obj::__alloc( HX_CTX ,null(),null(),null());
HXLINE( 186)		this->impulse2 =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 187)		this->reduced =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 189)		this->m_localAnchor1 =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 190)		this->m_localAnchor2 =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 191)		this->m_impulse =  ::box2D::common::math::B2Vec3_obj::__alloc( HX_CTX ,null(),null(),null());
HXLINE( 192)		this->m_mass =  ::box2D::common::math::B2Mat33_obj::__alloc( HX_CTX ,null(),null(),null());
HXLINE( 196)		{
HXLINE( 196)			 ::box2D::common::math::B2Vec2 _this = this->m_localAnchor1;
HXDLIN( 196)			 ::box2D::common::math::B2Vec2 v = def->localAnchorA;
HXDLIN( 196)			_this->x = v->x;
HXDLIN( 196)			_this->y = v->y;
            		}
HXLINE( 198)		{
HXLINE( 198)			 ::box2D::common::math::B2Vec2 _this1 = this->m_localAnchor2;
HXDLIN( 198)			 ::box2D::common::math::B2Vec2 v1 = def->localAnchorB;
HXDLIN( 198)			_this1->x = v1->x;
HXDLIN( 198)			_this1->y = v1->y;
            		}
HXLINE( 200)		this->m_referenceAngle = def->referenceAngle;
HXLINE( 202)		this->m_impulse->setZero();
HXLINE( 203)		this->m_motorImpulse = ((Float)0.0);
HXLINE( 205)		this->m_lowerAngle = def->lowerAngle;
HXLINE( 206)		this->m_upperAngle = def->upperAngle;
HXLINE( 207)		this->m_maxMotorTorque = def->maxMotorTorque;
HXLINE( 208)		this->m_motorSpeed = def->motorSpeed;
HXLINE( 209)		this->m_enableLimit = def->enableLimit;
HXLINE( 210)		this->m_enableMotor = def->enableMotor;
HXLINE( 211)		this->m_limitState = (int)0;
            	}

Dynamic B2RevoluteJoint_obj::__CreateEmpty() { return new B2RevoluteJoint_obj; }

void *B2RevoluteJoint_obj::_hx_vtable = 0;

Dynamic B2RevoluteJoint_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< B2RevoluteJoint_obj > _hx_result = new B2RevoluteJoint_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool B2RevoluteJoint_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x13310c20) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x13310c20;
	} else {
		return inClassId==(int)0x6f07845a;
	}
}

 ::box2D::common::math::B2Vec2 B2RevoluteJoint_obj::getAnchorA(){
            	HX_STACKFRAME(&_hx_pos_48708f914c341c71_57_getAnchorA)
HXDLIN(  57)		return this->m_bodyA->getWorldPoint(this->m_localAnchor1);
            	}


 ::box2D::common::math::B2Vec2 B2RevoluteJoint_obj::getAnchorB(){
            	HX_STACKFRAME(&_hx_pos_48708f914c341c71_61_getAnchorB)
HXDLIN(  61)		return this->m_bodyB->getWorldPoint(this->m_localAnchor2);
            	}


 ::box2D::common::math::B2Vec2 B2RevoluteJoint_obj::getReactionForce(Float inv_dt){
            	HX_GC_STACKFRAME(&_hx_pos_48708f914c341c71_66_getReactionForce)
HXDLIN(  66)		Float _hx_tmp = (inv_dt * this->m_impulse->x);
HXDLIN(  66)		return  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,_hx_tmp,(inv_dt * this->m_impulse->y));
            	}


Float B2RevoluteJoint_obj::getReactionTorque(Float inv_dt){
            	HX_STACKFRAME(&_hx_pos_48708f914c341c71_70_getReactionTorque)
HXDLIN(  70)		return (inv_dt * this->m_impulse->z);
            	}


Float B2RevoluteJoint_obj::getJointAngle(){
            	HX_STACKFRAME(&_hx_pos_48708f914c341c71_79_getJointAngle)
HXDLIN(  79)		return ((this->m_bodyB->m_sweep->a - this->m_bodyA->m_sweep->a) - this->m_referenceAngle);
            	}


HX_DEFINE_DYNAMIC_FUNC0(B2RevoluteJoint_obj,getJointAngle,return )

Float B2RevoluteJoint_obj::getJointSpeed(){
            	HX_STACKFRAME(&_hx_pos_48708f914c341c71_88_getJointSpeed)
HXDLIN(  88)		return (this->m_bodyB->m_angularVelocity - this->m_bodyA->m_angularVelocity);
            	}


HX_DEFINE_DYNAMIC_FUNC0(B2RevoluteJoint_obj,getJointSpeed,return )

bool B2RevoluteJoint_obj::isLimitEnabled(){
            	HX_STACKFRAME(&_hx_pos_48708f914c341c71_95_isLimitEnabled)
HXDLIN(  95)		return this->m_enableLimit;
            	}


HX_DEFINE_DYNAMIC_FUNC0(B2RevoluteJoint_obj,isLimitEnabled,return )

void B2RevoluteJoint_obj::enableLimit(bool flag){
            	HX_STACKFRAME(&_hx_pos_48708f914c341c71_102_enableLimit)
HXDLIN( 102)		this->m_enableLimit = flag;
            	}


HX_DEFINE_DYNAMIC_FUNC1(B2RevoluteJoint_obj,enableLimit,(void))

Float B2RevoluteJoint_obj::getLowerLimit(){
            	HX_STACKFRAME(&_hx_pos_48708f914c341c71_109_getLowerLimit)
HXDLIN( 109)		return this->m_lowerAngle;
            	}


HX_DEFINE_DYNAMIC_FUNC0(B2RevoluteJoint_obj,getLowerLimit,return )

Float B2RevoluteJoint_obj::getUpperLimit(){
            	HX_STACKFRAME(&_hx_pos_48708f914c341c71_116_getUpperLimit)
HXDLIN( 116)		return this->m_upperAngle;
            	}


HX_DEFINE_DYNAMIC_FUNC0(B2RevoluteJoint_obj,getUpperLimit,return )

void B2RevoluteJoint_obj::setLimits(Float lower,Float upper){
            	HX_STACKFRAME(&_hx_pos_48708f914c341c71_122_setLimits)
HXLINE( 124)		this->m_lowerAngle = lower;
HXLINE( 125)		this->m_upperAngle = upper;
            	}


HX_DEFINE_DYNAMIC_FUNC2(B2RevoluteJoint_obj,setLimits,(void))

bool B2RevoluteJoint_obj::isMotorEnabled(){
            	HX_STACKFRAME(&_hx_pos_48708f914c341c71_131_isMotorEnabled)
HXLINE( 132)		this->m_bodyA->setAwake(true);
HXLINE( 133)		this->m_bodyB->setAwake(true);
HXLINE( 134)		return this->m_enableMotor;
            	}


HX_DEFINE_DYNAMIC_FUNC0(B2RevoluteJoint_obj,isMotorEnabled,return )

void B2RevoluteJoint_obj::enableMotor(bool flag){
            	HX_STACKFRAME(&_hx_pos_48708f914c341c71_141_enableMotor)
HXDLIN( 141)		this->m_enableMotor = flag;
            	}


HX_DEFINE_DYNAMIC_FUNC1(B2RevoluteJoint_obj,enableMotor,(void))

void B2RevoluteJoint_obj::setMotorSpeed(Float speed){
            	HX_STACKFRAME(&_hx_pos_48708f914c341c71_147_setMotorSpeed)
HXLINE( 148)		this->m_bodyA->setAwake(true);
HXLINE( 149)		this->m_bodyB->setAwake(true);
HXLINE( 150)		this->m_motorSpeed = speed;
            	}


HX_DEFINE_DYNAMIC_FUNC1(B2RevoluteJoint_obj,setMotorSpeed,(void))

Float B2RevoluteJoint_obj::getMotorSpeed(){
            	HX_STACKFRAME(&_hx_pos_48708f914c341c71_157_getMotorSpeed)
HXDLIN( 157)		return this->m_motorSpeed;
            	}


HX_DEFINE_DYNAMIC_FUNC0(B2RevoluteJoint_obj,getMotorSpeed,return )

void B2RevoluteJoint_obj::setMaxMotorTorque(Float torque){
            	HX_STACKFRAME(&_hx_pos_48708f914c341c71_164_setMaxMotorTorque)
HXDLIN( 164)		this->m_maxMotorTorque = torque;
            	}


HX_DEFINE_DYNAMIC_FUNC1(B2RevoluteJoint_obj,setMaxMotorTorque,(void))

Float B2RevoluteJoint_obj::getMotorTorque(){
            	HX_STACKFRAME(&_hx_pos_48708f914c341c71_171_getMotorTorque)
HXDLIN( 171)		return this->m_maxMotorTorque;
            	}


HX_DEFINE_DYNAMIC_FUNC0(B2RevoluteJoint_obj,getMotorTorque,return )

void B2RevoluteJoint_obj::initVelocityConstraints( ::box2D::dynamics::B2TimeStep step){
            	HX_STACKFRAME(&_hx_pos_48708f914c341c71_219_initVelocityConstraints)
HXLINE( 220)		 ::box2D::dynamics::B2Body bA = this->m_bodyA;
HXLINE( 221)		 ::box2D::dynamics::B2Body bB = this->m_bodyB;
HXLINE( 223)		 ::box2D::common::math::B2Mat22 tMat;
HXLINE( 224)		Float tX;
HXLINE( 226)		bool _hx_tmp;
HXDLIN( 226)		if (!(this->m_enableMotor)) {
HXLINE( 226)			_hx_tmp = this->m_enableLimit;
            		}
            		else {
HXLINE( 226)			_hx_tmp = true;
            		}
HXLINE( 237)		tMat = bA->m_xf->R;
HXLINE( 238)		Float r1X = (this->m_localAnchor1->x - bA->m_sweep->localCenter->x);
HXLINE( 239)		Float r1Y = (this->m_localAnchor1->y - bA->m_sweep->localCenter->y);
HXLINE( 240)		Float tX1 = (tMat->col1->x * r1X);
HXDLIN( 240)		tX = (tX1 + (tMat->col2->x * r1Y));
HXLINE( 241)		Float r1Y1 = (tMat->col1->y * r1X);
HXDLIN( 241)		r1Y = (r1Y1 + (tMat->col2->y * r1Y));
HXLINE( 242)		r1X = tX;
HXLINE( 244)		tMat = bB->m_xf->R;
HXLINE( 245)		Float r2X = (this->m_localAnchor2->x - bB->m_sweep->localCenter->x);
HXLINE( 246)		Float r2Y = (this->m_localAnchor2->y - bB->m_sweep->localCenter->y);
HXLINE( 247)		Float tX2 = (tMat->col1->x * r2X);
HXDLIN( 247)		tX = (tX2 + (tMat->col2->x * r2Y));
HXLINE( 248)		Float r2Y1 = (tMat->col1->y * r2X);
HXDLIN( 248)		r2Y = (r2Y1 + (tMat->col2->y * r2Y));
HXLINE( 249)		r2X = tX;
HXLINE( 260)		Float m1 = bA->m_invMass;
HXLINE( 261)		Float m2 = bB->m_invMass;
HXLINE( 262)		Float i1 = bA->m_invI;
HXLINE( 263)		Float i2 = bB->m_invI;
HXLINE( 265)		this->m_mass->col1->x = (((m1 + m2) + ((r1Y * r1Y) * i1)) + ((r2Y * r2Y) * i2));
HXLINE( 266)		this->m_mass->col2->x = (((-(r1Y) * r1X) * i1) - ((r2Y * r2X) * i2));
HXLINE( 267)		this->m_mass->col3->x = ((-(r1Y) * i1) - (r2Y * i2));
HXLINE( 268)		this->m_mass->col1->y = this->m_mass->col2->x;
HXLINE( 269)		this->m_mass->col2->y = (((m1 + m2) + ((r1X * r1X) * i1)) + ((r2X * r2X) * i2));
HXLINE( 270)		this->m_mass->col3->y = ((r1X * i1) + (r2X * i2));
HXLINE( 271)		this->m_mass->col1->z = this->m_mass->col3->x;
HXLINE( 272)		this->m_mass->col2->z = this->m_mass->col3->y;
HXLINE( 273)		this->m_mass->col3->z = (i1 + i2);
HXLINE( 276)		this->m_motorMass = ((Float)((Float)1.0) / (Float)(i1 + i2));
HXLINE( 278)		if ((this->m_enableMotor == false)) {
HXLINE( 280)			this->m_motorImpulse = ((Float)0.0);
            		}
HXLINE( 283)		if (this->m_enableLimit) {
HXLINE( 286)			Float jointAngle = ((bB->m_sweep->a - bA->m_sweep->a) - this->m_referenceAngle);
HXLINE( 287)			Float _hx_tmp1 = ::box2D::common::math::B2Math_obj::abs((this->m_upperAngle - this->m_lowerAngle));
HXDLIN( 287)			if ((_hx_tmp1 < (((Float)2.0) * ::box2D::common::B2Settings_obj::b2_angularSlop))) {
HXLINE( 289)				this->m_limitState = (int)3;
            			}
            			else {
HXLINE( 291)				if ((jointAngle <= this->m_lowerAngle)) {
HXLINE( 293)					if ((this->m_limitState != (int)1)) {
HXLINE( 295)						this->m_impulse->z = ((Float)0.0);
            					}
HXLINE( 297)					this->m_limitState = (int)1;
            				}
            				else {
HXLINE( 299)					if ((jointAngle >= this->m_upperAngle)) {
HXLINE( 301)						if ((this->m_limitState != (int)2)) {
HXLINE( 303)							this->m_impulse->z = ((Float)0.0);
            						}
HXLINE( 305)						this->m_limitState = (int)2;
            					}
            					else {
HXLINE( 309)						this->m_limitState = (int)0;
HXLINE( 310)						this->m_impulse->z = ((Float)0.0);
            					}
            				}
            			}
            		}
            		else {
HXLINE( 315)			this->m_limitState = (int)0;
            		}
HXLINE( 319)		if (step->warmStarting) {
HXLINE( 322)			 ::box2D::common::math::B2Vec3 _hx_tmp2 = this->m_impulse;
HXDLIN( 322)			_hx_tmp2->x = (_hx_tmp2->x * step->dtRatio);
HXLINE( 323)			 ::box2D::common::math::B2Vec3 _hx_tmp3 = this->m_impulse;
HXDLIN( 323)			_hx_tmp3->y = (_hx_tmp3->y * step->dtRatio);
HXLINE( 324)			 ::box2D::dynamics::joints::B2RevoluteJoint _hx_tmp4 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 324)			_hx_tmp4->m_motorImpulse = (_hx_tmp4->m_motorImpulse * step->dtRatio);
HXLINE( 326)			Float PX = this->m_impulse->x;
HXLINE( 327)			Float PY = this->m_impulse->y;
HXLINE( 330)			 ::box2D::common::math::B2Vec2 bA1 = bA->m_linearVelocity;
HXDLIN( 330)			bA1->x = (bA1->x - (m1 * PX));
HXLINE( 331)			 ::box2D::common::math::B2Vec2 bA2 = bA->m_linearVelocity;
HXDLIN( 331)			bA2->y = (bA2->y - (m1 * PY));
HXLINE( 333)			 ::box2D::dynamics::B2Body bA3 = bA;
HXDLIN( 333)			bA3->m_angularVelocity = (bA3->m_angularVelocity - (i1 * ((((r1X * PY) - (r1Y * PX)) + this->m_motorImpulse) + this->m_impulse->z)));
HXLINE( 336)			 ::box2D::common::math::B2Vec2 bB1 = bB->m_linearVelocity;
HXDLIN( 336)			bB1->x = (bB1->x + (m2 * PX));
HXLINE( 337)			 ::box2D::common::math::B2Vec2 bB2 = bB->m_linearVelocity;
HXDLIN( 337)			bB2->y = (bB2->y + (m2 * PY));
HXLINE( 339)			 ::box2D::dynamics::B2Body bB3 = bB;
HXDLIN( 339)			bB3->m_angularVelocity = (bB3->m_angularVelocity + (i2 * ((((r2X * PY) - (r2Y * PX)) + this->m_motorImpulse) + this->m_impulse->z)));
            		}
            		else {
HXLINE( 343)			this->m_impulse->setZero();
HXLINE( 344)			this->m_motorImpulse = ((Float)0.0);
            		}
            	}


void B2RevoluteJoint_obj::solveVelocityConstraints( ::box2D::dynamics::B2TimeStep step){
            	HX_STACKFRAME(&_hx_pos_48708f914c341c71_351_solveVelocityConstraints)
HXLINE( 352)		 ::box2D::dynamics::B2Body bA = this->m_bodyA;
HXLINE( 353)		 ::box2D::dynamics::B2Body bB = this->m_bodyB;
HXLINE( 355)		 ::box2D::common::math::B2Mat22 tMat;
HXLINE( 356)		Float tX;
HXLINE( 358)		Float newImpulse;
HXLINE( 359)		Float r1X;
HXLINE( 360)		Float r1Y;
HXLINE( 361)		Float r2X;
HXLINE( 362)		Float r2Y;
HXLINE( 364)		 ::box2D::common::math::B2Vec2 v1 = bA->m_linearVelocity;
HXLINE( 365)		Float w1 = bA->m_angularVelocity;
HXLINE( 366)		 ::box2D::common::math::B2Vec2 v2 = bB->m_linearVelocity;
HXLINE( 367)		Float w2 = bB->m_angularVelocity;
HXLINE( 369)		Float m1 = bA->m_invMass;
HXLINE( 370)		Float m2 = bB->m_invMass;
HXLINE( 371)		Float i1 = bA->m_invI;
HXLINE( 372)		Float i2 = bB->m_invI;
HXLINE( 375)		bool _hx_tmp;
HXDLIN( 375)		if (this->m_enableMotor) {
HXLINE( 375)			_hx_tmp = (this->m_limitState != (int)3);
            		}
            		else {
HXLINE( 375)			_hx_tmp = false;
            		}
HXDLIN( 375)		if (_hx_tmp) {
HXLINE( 377)			Float Cdot = ((w2 - w1) - this->m_motorSpeed);
HXLINE( 378)			Float impulse = (this->m_motorMass * -(Cdot));
HXLINE( 379)			Float oldImpulse = this->m_motorImpulse;
HXLINE( 380)			Float maxImpulse = (step->dt * this->m_maxMotorTorque);
HXLINE( 382)			this->m_motorImpulse = ::box2D::common::math::B2Math_obj::clamp((this->m_motorImpulse + impulse),-(maxImpulse),maxImpulse);
HXLINE( 383)			impulse = (this->m_motorImpulse - oldImpulse);
HXLINE( 385)			w1 = (w1 - (i1 * impulse));
HXLINE( 386)			w2 = (w2 + (i2 * impulse));
            		}
HXLINE( 390)		bool _hx_tmp1;
HXDLIN( 390)		if (this->m_enableLimit) {
HXLINE( 390)			_hx_tmp1 = (this->m_limitState != (int)0);
            		}
            		else {
HXLINE( 390)			_hx_tmp1 = false;
            		}
HXDLIN( 390)		if (_hx_tmp1) {
HXLINE( 393)			tMat = bA->m_xf->R;
HXLINE( 394)			r1X = (this->m_localAnchor1->x - bA->m_sweep->localCenter->x);
HXLINE( 395)			r1Y = (this->m_localAnchor1->y - bA->m_sweep->localCenter->y);
HXLINE( 396)			Float tX1 = (tMat->col1->x * r1X);
HXDLIN( 396)			tX = (tX1 + (tMat->col2->x * r1Y));
HXLINE( 397)			Float r1Y1 = (tMat->col1->y * r1X);
HXDLIN( 397)			r1Y = (r1Y1 + (tMat->col2->y * r1Y));
HXLINE( 398)			r1X = tX;
HXLINE( 400)			tMat = bB->m_xf->R;
HXLINE( 401)			r2X = (this->m_localAnchor2->x - bB->m_sweep->localCenter->x);
HXLINE( 402)			r2Y = (this->m_localAnchor2->y - bB->m_sweep->localCenter->y);
HXLINE( 403)			Float tX2 = (tMat->col1->x * r2X);
HXDLIN( 403)			tX = (tX2 + (tMat->col2->x * r2Y));
HXLINE( 404)			Float r2Y1 = (tMat->col1->y * r2X);
HXDLIN( 404)			r2Y = (r2Y1 + (tMat->col2->y * r2Y));
HXLINE( 405)			r2X = tX;
HXLINE( 409)			Float v21 = v2->x;
HXDLIN( 409)			Float Cdot1X = ((v21 + (-(w2) * r2Y)) - v1->x);
HXDLIN( 409)			Float Cdot1X1 = (Cdot1X - (-(w1) * r1Y));
HXLINE( 410)			Float v22 = v2->y;
HXDLIN( 410)			Float Cdot1Y = ((v22 + (w2 * r2X)) - v1->y);
HXDLIN( 410)			Float Cdot1Y1 = (Cdot1Y - (w1 * r1X));
HXLINE( 411)			Float Cdot2 = (w2 - w1);
HXLINE( 413)			this->m_mass->solve33(this->impulse3,-(Cdot1X1),-(Cdot1Y1),-(Cdot2));
HXLINE( 415)			if ((this->m_limitState == (int)3)) {
HXLINE( 417)				this->m_impulse->add(this->impulse3);
            			}
            			else {
HXLINE( 419)				if ((this->m_limitState == (int)1)) {
HXLINE( 421)					newImpulse = (this->m_impulse->z + this->impulse3->z);
HXLINE( 422)					if ((newImpulse < ((Float)0.0))) {
HXLINE( 424)						this->m_mass->solve22(this->reduced,-(Cdot1X1),-(Cdot1Y1));
HXLINE( 425)						this->impulse3->x = this->reduced->x;
HXLINE( 426)						this->impulse3->y = this->reduced->y;
HXLINE( 427)						this->impulse3->z = -(this->m_impulse->z);
HXLINE( 428)						 ::box2D::common::math::B2Vec3 _hx_tmp2 = this->m_impulse;
HXDLIN( 428)						_hx_tmp2->x = (_hx_tmp2->x + this->reduced->x);
HXLINE( 429)						 ::box2D::common::math::B2Vec3 _hx_tmp3 = this->m_impulse;
HXDLIN( 429)						_hx_tmp3->y = (_hx_tmp3->y + this->reduced->y);
HXLINE( 430)						this->m_impulse->z = ((Float)0.0);
            					}
            				}
            				else {
HXLINE( 433)					if ((this->m_limitState == (int)2)) {
HXLINE( 435)						newImpulse = (this->m_impulse->z + this->impulse3->z);
HXLINE( 436)						if ((newImpulse > ((Float)0.0))) {
HXLINE( 438)							this->m_mass->solve22(this->reduced,-(Cdot1X1),-(Cdot1Y1));
HXLINE( 439)							this->impulse3->x = this->reduced->x;
HXLINE( 440)							this->impulse3->y = this->reduced->y;
HXLINE( 441)							this->impulse3->z = -(this->m_impulse->z);
HXLINE( 442)							 ::box2D::common::math::B2Vec3 _hx_tmp4 = this->m_impulse;
HXDLIN( 442)							_hx_tmp4->x = (_hx_tmp4->x + this->reduced->x);
HXLINE( 443)							 ::box2D::common::math::B2Vec3 _hx_tmp5 = this->m_impulse;
HXDLIN( 443)							_hx_tmp5->y = (_hx_tmp5->y + this->reduced->y);
HXLINE( 444)							this->m_impulse->z = ((Float)0.0);
            						}
            					}
            				}
            			}
HXLINE( 448)			 ::box2D::common::math::B2Vec2 v11 = v1;
HXDLIN( 448)			v11->x = (v11->x - (m1 * this->impulse3->x));
HXLINE( 449)			 ::box2D::common::math::B2Vec2 v12 = v1;
HXDLIN( 449)			v12->y = (v12->y - (m1 * this->impulse3->y));
HXLINE( 450)			Float w11 = (r1X * this->impulse3->y);
HXDLIN( 450)			w1 = (w1 - (i1 * ((w11 - (r1Y * this->impulse3->x)) + this->impulse3->z)));
HXLINE( 452)			 ::box2D::common::math::B2Vec2 v23 = v2;
HXDLIN( 452)			v23->x = (v23->x + (m2 * this->impulse3->x));
HXLINE( 453)			 ::box2D::common::math::B2Vec2 v24 = v2;
HXDLIN( 453)			v24->y = (v24->y + (m2 * this->impulse3->y));
HXLINE( 454)			Float w21 = (r2X * this->impulse3->y);
HXDLIN( 454)			w2 = (w2 + (i2 * ((w21 - (r2Y * this->impulse3->x)) + this->impulse3->z)));
            		}
            		else {
HXLINE( 459)			tMat = bA->m_xf->R;
HXLINE( 460)			r1X = (this->m_localAnchor1->x - bA->m_sweep->localCenter->x);
HXLINE( 461)			r1Y = (this->m_localAnchor1->y - bA->m_sweep->localCenter->y);
HXLINE( 462)			Float tX3 = (tMat->col1->x * r1X);
HXDLIN( 462)			tX = (tX3 + (tMat->col2->x * r1Y));
HXLINE( 463)			Float r1Y2 = (tMat->col1->y * r1X);
HXDLIN( 463)			r1Y = (r1Y2 + (tMat->col2->y * r1Y));
HXLINE( 464)			r1X = tX;
HXLINE( 466)			tMat = bB->m_xf->R;
HXLINE( 467)			r2X = (this->m_localAnchor2->x - bB->m_sweep->localCenter->x);
HXLINE( 468)			r2Y = (this->m_localAnchor2->y - bB->m_sweep->localCenter->y);
HXLINE( 469)			Float tX4 = (tMat->col1->x * r2X);
HXDLIN( 469)			tX = (tX4 + (tMat->col2->x * r2Y));
HXLINE( 470)			Float r2Y2 = (tMat->col1->y * r2X);
HXDLIN( 470)			r2Y = (r2Y2 + (tMat->col2->y * r2Y));
HXLINE( 471)			r2X = tX;
HXLINE( 474)			Float v25 = v2->x;
HXDLIN( 474)			Float CdotX = ((v25 + (-(w2) * r2Y)) - v1->x);
HXDLIN( 474)			Float CdotX1 = (CdotX - (-(w1) * r1Y));
HXLINE( 475)			Float v26 = v2->y;
HXDLIN( 475)			Float CdotY = ((v26 + (w2 * r2X)) - v1->y);
HXDLIN( 475)			Float CdotY1 = (CdotY - (w1 * r1X));
HXLINE( 477)			this->m_mass->solve22(this->impulse2,-(CdotX1),-(CdotY1));
HXLINE( 479)			 ::box2D::common::math::B2Vec3 _hx_tmp6 = this->m_impulse;
HXDLIN( 479)			_hx_tmp6->x = (_hx_tmp6->x + this->impulse2->x);
HXLINE( 480)			 ::box2D::common::math::B2Vec3 _hx_tmp7 = this->m_impulse;
HXDLIN( 480)			_hx_tmp7->y = (_hx_tmp7->y + this->impulse2->y);
HXLINE( 482)			 ::box2D::common::math::B2Vec2 v13 = v1;
HXDLIN( 482)			v13->x = (v13->x - (m1 * this->impulse2->x));
HXLINE( 483)			 ::box2D::common::math::B2Vec2 v14 = v1;
HXDLIN( 483)			v14->y = (v14->y - (m1 * this->impulse2->y));
HXLINE( 485)			Float w12 = (r1X * this->impulse2->y);
HXDLIN( 485)			w1 = (w1 - (i1 * (w12 - (r1Y * this->impulse2->x))));
HXLINE( 487)			 ::box2D::common::math::B2Vec2 v27 = v2;
HXDLIN( 487)			v27->x = (v27->x + (m2 * this->impulse2->x));
HXLINE( 488)			 ::box2D::common::math::B2Vec2 v28 = v2;
HXDLIN( 488)			v28->y = (v28->y + (m2 * this->impulse2->y));
HXLINE( 490)			Float w22 = (r2X * this->impulse2->y);
HXDLIN( 490)			w2 = (w2 + (i2 * (w22 - (r2Y * this->impulse2->x))));
            		}
HXLINE( 493)		{
HXLINE( 493)			 ::box2D::common::math::B2Vec2 _this = bA->m_linearVelocity;
HXDLIN( 493)			_this->x = v1->x;
HXDLIN( 493)			_this->y = v1->y;
            		}
HXLINE( 494)		bA->m_angularVelocity = w1;
HXLINE( 495)		{
HXLINE( 495)			 ::box2D::common::math::B2Vec2 _this1 = bB->m_linearVelocity;
HXDLIN( 495)			_this1->x = v2->x;
HXDLIN( 495)			_this1->y = v2->y;
            		}
HXLINE( 496)		bB->m_angularVelocity = w2;
            	}


bool B2RevoluteJoint_obj::solvePositionConstraints(Float baumgarte){
            	HX_STACKFRAME(&_hx_pos_48708f914c341c71_500_solvePositionConstraints)
HXLINE( 504)		Float oldLimitImpulse;
HXLINE( 505)		Float C;
HXLINE( 507)		 ::box2D::common::math::B2Mat22 tMat;
HXLINE( 509)		 ::box2D::dynamics::B2Body bA = this->m_bodyA;
HXLINE( 510)		 ::box2D::dynamics::B2Body bB = this->m_bodyB;
HXLINE( 512)		Float angularError = ((Float)0.0);
HXLINE( 513)		Float positionError = ((Float)0.0);
HXLINE( 515)		Float tX;
HXLINE( 517)		Float impulseX;
HXLINE( 518)		Float impulseY;
HXLINE( 521)		bool _hx_tmp;
HXDLIN( 521)		if (this->m_enableLimit) {
HXLINE( 521)			_hx_tmp = (this->m_limitState != (int)0);
            		}
            		else {
HXLINE( 521)			_hx_tmp = false;
            		}
HXDLIN( 521)		if (_hx_tmp) {
HXLINE( 523)			Float angle = ((bB->m_sweep->a - bA->m_sweep->a) - this->m_referenceAngle);
HXLINE( 524)			Float limitImpulse = ((Float)0.0);
HXLINE( 526)			if ((this->m_limitState == (int)3)) {
HXLINE( 529)				C = ::box2D::common::math::B2Math_obj::clamp((angle - this->m_lowerAngle),-(::box2D::common::B2Settings_obj::b2_maxAngularCorrection),::box2D::common::B2Settings_obj::b2_maxAngularCorrection);
HXLINE( 530)				limitImpulse = (-(this->m_motorMass) * C);
HXLINE( 531)				angularError = ::box2D::common::math::B2Math_obj::abs(C);
            			}
            			else {
HXLINE( 533)				if ((this->m_limitState == (int)1)) {
HXLINE( 535)					C = (angle - this->m_lowerAngle);
HXLINE( 536)					angularError = -(C);
HXLINE( 539)					C = ::box2D::common::math::B2Math_obj::clamp((C + ::box2D::common::B2Settings_obj::b2_angularSlop),-(::box2D::common::B2Settings_obj::b2_maxAngularCorrection),((Float)0.0));
HXLINE( 540)					limitImpulse = (-(this->m_motorMass) * C);
            				}
            				else {
HXLINE( 542)					if ((this->m_limitState == (int)2)) {
HXLINE( 544)						C = (angle - this->m_upperAngle);
HXLINE( 545)						angularError = C;
HXLINE( 548)						C = ::box2D::common::math::B2Math_obj::clamp((C - ::box2D::common::B2Settings_obj::b2_angularSlop),((Float)0.0),::box2D::common::B2Settings_obj::b2_maxAngularCorrection);
HXLINE( 549)						limitImpulse = (-(this->m_motorMass) * C);
            					}
            				}
            			}
HXLINE( 552)			 ::box2D::common::math::B2Sweep bA1 = bA->m_sweep;
HXDLIN( 552)			bA1->a = (bA1->a - (bA->m_invI * limitImpulse));
HXLINE( 553)			 ::box2D::common::math::B2Sweep bB1 = bB->m_sweep;
HXDLIN( 553)			bB1->a = (bB1->a + (bB->m_invI * limitImpulse));
HXLINE( 555)			bA->synchronizeTransform();
HXLINE( 556)			bB->synchronizeTransform();
            		}
HXLINE( 560)		{
HXLINE( 562)			tMat = bA->m_xf->R;
HXLINE( 563)			Float r1X = (this->m_localAnchor1->x - bA->m_sweep->localCenter->x);
HXLINE( 564)			Float r1Y = (this->m_localAnchor1->y - bA->m_sweep->localCenter->y);
HXLINE( 565)			Float tX1 = (tMat->col1->x * r1X);
HXDLIN( 565)			tX = (tX1 + (tMat->col2->x * r1Y));
HXLINE( 566)			Float r1Y1 = (tMat->col1->y * r1X);
HXDLIN( 566)			r1Y = (r1Y1 + (tMat->col2->y * r1Y));
HXLINE( 567)			r1X = tX;
HXLINE( 569)			tMat = bB->m_xf->R;
HXLINE( 570)			Float r2X = (this->m_localAnchor2->x - bB->m_sweep->localCenter->x);
HXLINE( 571)			Float r2Y = (this->m_localAnchor2->y - bB->m_sweep->localCenter->y);
HXLINE( 572)			Float tX2 = (tMat->col1->x * r2X);
HXDLIN( 572)			tX = (tX2 + (tMat->col2->x * r2Y));
HXLINE( 573)			Float r2Y1 = (tMat->col1->y * r2X);
HXDLIN( 573)			r2Y = (r2Y1 + (tMat->col2->y * r2Y));
HXLINE( 574)			r2X = tX;
HXLINE( 577)			Float CX = (((bB->m_sweep->c->x + r2X) - bA->m_sweep->c->x) - r1X);
HXLINE( 578)			Float CY = (((bB->m_sweep->c->y + r2Y) - bA->m_sweep->c->y) - r1Y);
HXLINE( 579)			Float CLengthSquared = ((CX * CX) + (CY * CY));
HXLINE( 580)			Float CLength = ::Math_obj::sqrt(CLengthSquared);
HXLINE( 581)			positionError = CLength;
HXLINE( 583)			Float invMass1 = bA->m_invMass;
HXLINE( 584)			Float invMass2 = bB->m_invMass;
HXLINE( 585)			Float invI1 = bA->m_invI;
HXLINE( 586)			Float invI2 = bB->m_invI;
HXLINE( 589)			Float k_allowedStretch = (((Float)10.0) * ::box2D::common::B2Settings_obj::b2_linearSlop);
HXLINE( 590)			if ((CLengthSquared > (k_allowedStretch * k_allowedStretch))) {
HXLINE( 594)				Float uX = ((Float)CX / (Float)CLength);
HXLINE( 595)				Float uY = ((Float)CY / (Float)CLength);
HXLINE( 596)				Float k = (invMass1 + invMass2);
HXLINE( 598)				Float m = ((Float)((Float)1.0) / (Float)k);
HXLINE( 599)				impulseX = (m * -(CX));
HXLINE( 600)				impulseY = (m * -(CY));
HXLINE( 601)				Float k_beta = ((Float)0.5);
HXLINE( 602)				 ::box2D::common::math::B2Vec2 bA2 = bA->m_sweep->c;
HXDLIN( 602)				bA2->x = (bA2->x - ((k_beta * invMass1) * impulseX));
HXLINE( 603)				 ::box2D::common::math::B2Vec2 bA3 = bA->m_sweep->c;
HXDLIN( 603)				bA3->y = (bA3->y - ((k_beta * invMass1) * impulseY));
HXLINE( 604)				 ::box2D::common::math::B2Vec2 bB2 = bB->m_sweep->c;
HXDLIN( 604)				bB2->x = (bB2->x + ((k_beta * invMass2) * impulseX));
HXLINE( 605)				 ::box2D::common::math::B2Vec2 bB3 = bB->m_sweep->c;
HXDLIN( 605)				bB3->y = (bB3->y + ((k_beta * invMass2) * impulseY));
HXLINE( 608)				CX = (((bB->m_sweep->c->x + r2X) - bA->m_sweep->c->x) - r1X);
HXLINE( 609)				CY = (((bB->m_sweep->c->y + r2Y) - bA->m_sweep->c->y) - r1Y);
            			}
HXLINE( 613)			this->K1->col1->x = (invMass1 + invMass2);
HXDLIN( 613)			this->K1->col2->x = ((Float)0.0);
HXLINE( 614)			this->K1->col1->y = ((Float)0.0);
HXDLIN( 614)			this->K1->col2->y = (invMass1 + invMass2);
HXLINE( 617)			this->K2->col1->x = ((invI1 * r1Y) * r1Y);
HXDLIN( 617)			this->K2->col2->x = ((-(invI1) * r1X) * r1Y);
HXLINE( 618)			this->K2->col1->y = ((-(invI1) * r1X) * r1Y);
HXDLIN( 618)			this->K2->col2->y = ((invI1 * r1X) * r1X);
HXLINE( 621)			this->K3->col1->x = ((invI2 * r2Y) * r2Y);
HXDLIN( 621)			this->K3->col2->x = ((-(invI2) * r2X) * r2Y);
HXLINE( 622)			this->K3->col1->y = ((-(invI2) * r2X) * r2Y);
HXDLIN( 622)			this->K3->col2->y = ((invI2 * r2X) * r2X);
HXLINE( 625)			this->K->setM(this->K1);
HXLINE( 626)			this->K->addM(this->K2);
HXLINE( 627)			this->K->addM(this->K3);
HXLINE( 629)			this->K->solve(::box2D::dynamics::joints::B2RevoluteJoint_obj::tImpulse,-(CX),-(CY));
HXLINE( 630)			impulseX = ::box2D::dynamics::joints::B2RevoluteJoint_obj::tImpulse->x;
HXLINE( 631)			impulseY = ::box2D::dynamics::joints::B2RevoluteJoint_obj::tImpulse->y;
HXLINE( 634)			 ::box2D::common::math::B2Vec2 bA4 = bA->m_sweep->c;
HXDLIN( 634)			bA4->x = (bA4->x - (bA->m_invMass * impulseX));
HXLINE( 635)			 ::box2D::common::math::B2Vec2 bA5 = bA->m_sweep->c;
HXDLIN( 635)			bA5->y = (bA5->y - (bA->m_invMass * impulseY));
HXLINE( 637)			 ::box2D::common::math::B2Sweep bA6 = bA->m_sweep;
HXDLIN( 637)			Float bA7 = bA->m_invI;
HXDLIN( 637)			bA6->a = (bA6->a - (bA7 * ((r1X * impulseY) - (r1Y * impulseX))));
HXLINE( 640)			 ::box2D::common::math::B2Vec2 bB4 = bB->m_sweep->c;
HXDLIN( 640)			bB4->x = (bB4->x + (bB->m_invMass * impulseX));
HXLINE( 641)			 ::box2D::common::math::B2Vec2 bB5 = bB->m_sweep->c;
HXDLIN( 641)			bB5->y = (bB5->y + (bB->m_invMass * impulseY));
HXLINE( 643)			 ::box2D::common::math::B2Sweep bB6 = bB->m_sweep;
HXDLIN( 643)			Float bB7 = bB->m_invI;
HXDLIN( 643)			bB6->a = (bB6->a + (bB7 * ((r2X * impulseY) - (r2Y * impulseX))));
HXLINE( 645)			bA->synchronizeTransform();
HXLINE( 646)			bB->synchronizeTransform();
            		}
HXLINE( 649)		if ((positionError <= ::box2D::common::B2Settings_obj::b2_linearSlop)) {
HXLINE( 649)			return (angularError <= ::box2D::common::B2Settings_obj::b2_angularSlop);
            		}
            		else {
HXLINE( 649)			return false;
            		}
HXDLIN( 649)		return false;
            	}


 ::box2D::common::math::B2Vec2 B2RevoluteJoint_obj::tImpulse;


hx::ObjectPtr< B2RevoluteJoint_obj > B2RevoluteJoint_obj::__new( ::box2D::dynamics::joints::B2RevoluteJointDef def) {
	hx::ObjectPtr< B2RevoluteJoint_obj > __this = new B2RevoluteJoint_obj();
	__this->__construct(def);
	return __this;
}

hx::ObjectPtr< B2RevoluteJoint_obj > B2RevoluteJoint_obj::__alloc(hx::Ctx *_hx_ctx, ::box2D::dynamics::joints::B2RevoluteJointDef def) {
	B2RevoluteJoint_obj *__this = (B2RevoluteJoint_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(B2RevoluteJoint_obj), true, "box2D.dynamics.joints.B2RevoluteJoint"));
	*(void **)__this = B2RevoluteJoint_obj::_hx_vtable;
	__this->__construct(def);
	return __this;
}

B2RevoluteJoint_obj::B2RevoluteJoint_obj()
{
}

void B2RevoluteJoint_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(B2RevoluteJoint);
	HX_MARK_MEMBER_NAME(K,"K");
	HX_MARK_MEMBER_NAME(K1,"K1");
	HX_MARK_MEMBER_NAME(K2,"K2");
	HX_MARK_MEMBER_NAME(K3,"K3");
	HX_MARK_MEMBER_NAME(impulse3,"impulse3");
	HX_MARK_MEMBER_NAME(impulse2,"impulse2");
	HX_MARK_MEMBER_NAME(reduced,"reduced");
	HX_MARK_MEMBER_NAME(m_localAnchor1,"m_localAnchor1");
	HX_MARK_MEMBER_NAME(m_localAnchor2,"m_localAnchor2");
	HX_MARK_MEMBER_NAME(m_impulse,"m_impulse");
	HX_MARK_MEMBER_NAME(m_motorImpulse,"m_motorImpulse");
	HX_MARK_MEMBER_NAME(m_mass,"m_mass");
	HX_MARK_MEMBER_NAME(m_motorMass,"m_motorMass");
	HX_MARK_MEMBER_NAME(m_enableMotor,"m_enableMotor");
	HX_MARK_MEMBER_NAME(m_maxMotorTorque,"m_maxMotorTorque");
	HX_MARK_MEMBER_NAME(m_motorSpeed,"m_motorSpeed");
	HX_MARK_MEMBER_NAME(m_enableLimit,"m_enableLimit");
	HX_MARK_MEMBER_NAME(m_referenceAngle,"m_referenceAngle");
	HX_MARK_MEMBER_NAME(m_lowerAngle,"m_lowerAngle");
	HX_MARK_MEMBER_NAME(m_upperAngle,"m_upperAngle");
	HX_MARK_MEMBER_NAME(m_limitState,"m_limitState");
	 ::box2D::dynamics::joints::B2Joint_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void B2RevoluteJoint_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(K,"K");
	HX_VISIT_MEMBER_NAME(K1,"K1");
	HX_VISIT_MEMBER_NAME(K2,"K2");
	HX_VISIT_MEMBER_NAME(K3,"K3");
	HX_VISIT_MEMBER_NAME(impulse3,"impulse3");
	HX_VISIT_MEMBER_NAME(impulse2,"impulse2");
	HX_VISIT_MEMBER_NAME(reduced,"reduced");
	HX_VISIT_MEMBER_NAME(m_localAnchor1,"m_localAnchor1");
	HX_VISIT_MEMBER_NAME(m_localAnchor2,"m_localAnchor2");
	HX_VISIT_MEMBER_NAME(m_impulse,"m_impulse");
	HX_VISIT_MEMBER_NAME(m_motorImpulse,"m_motorImpulse");
	HX_VISIT_MEMBER_NAME(m_mass,"m_mass");
	HX_VISIT_MEMBER_NAME(m_motorMass,"m_motorMass");
	HX_VISIT_MEMBER_NAME(m_enableMotor,"m_enableMotor");
	HX_VISIT_MEMBER_NAME(m_maxMotorTorque,"m_maxMotorTorque");
	HX_VISIT_MEMBER_NAME(m_motorSpeed,"m_motorSpeed");
	HX_VISIT_MEMBER_NAME(m_enableLimit,"m_enableLimit");
	HX_VISIT_MEMBER_NAME(m_referenceAngle,"m_referenceAngle");
	HX_VISIT_MEMBER_NAME(m_lowerAngle,"m_lowerAngle");
	HX_VISIT_MEMBER_NAME(m_upperAngle,"m_upperAngle");
	HX_VISIT_MEMBER_NAME(m_limitState,"m_limitState");
	 ::box2D::dynamics::joints::B2Joint_obj::__Visit(HX_VISIT_ARG);
}

hx::Val B2RevoluteJoint_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"K") ) { return hx::Val( K ); }
		break;
	case 2:
		if (HX_FIELD_EQ(inName,"K1") ) { return hx::Val( K1 ); }
		if (HX_FIELD_EQ(inName,"K2") ) { return hx::Val( K2 ); }
		if (HX_FIELD_EQ(inName,"K3") ) { return hx::Val( K3 ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"m_mass") ) { return hx::Val( m_mass ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"reduced") ) { return hx::Val( reduced ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"impulse3") ) { return hx::Val( impulse3 ); }
		if (HX_FIELD_EQ(inName,"impulse2") ) { return hx::Val( impulse2 ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"setLimits") ) { return hx::Val( setLimits_dyn() ); }
		if (HX_FIELD_EQ(inName,"m_impulse") ) { return hx::Val( m_impulse ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"getAnchorA") ) { return hx::Val( getAnchorA_dyn() ); }
		if (HX_FIELD_EQ(inName,"getAnchorB") ) { return hx::Val( getAnchorB_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"enableLimit") ) { return hx::Val( enableLimit_dyn() ); }
		if (HX_FIELD_EQ(inName,"enableMotor") ) { return hx::Val( enableMotor_dyn() ); }
		if (HX_FIELD_EQ(inName,"m_motorMass") ) { return hx::Val( m_motorMass ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"m_motorSpeed") ) { return hx::Val( m_motorSpeed ); }
		if (HX_FIELD_EQ(inName,"m_lowerAngle") ) { return hx::Val( m_lowerAngle ); }
		if (HX_FIELD_EQ(inName,"m_upperAngle") ) { return hx::Val( m_upperAngle ); }
		if (HX_FIELD_EQ(inName,"m_limitState") ) { return hx::Val( m_limitState ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"getJointAngle") ) { return hx::Val( getJointAngle_dyn() ); }
		if (HX_FIELD_EQ(inName,"getJointSpeed") ) { return hx::Val( getJointSpeed_dyn() ); }
		if (HX_FIELD_EQ(inName,"getLowerLimit") ) { return hx::Val( getLowerLimit_dyn() ); }
		if (HX_FIELD_EQ(inName,"getUpperLimit") ) { return hx::Val( getUpperLimit_dyn() ); }
		if (HX_FIELD_EQ(inName,"setMotorSpeed") ) { return hx::Val( setMotorSpeed_dyn() ); }
		if (HX_FIELD_EQ(inName,"getMotorSpeed") ) { return hx::Val( getMotorSpeed_dyn() ); }
		if (HX_FIELD_EQ(inName,"m_enableMotor") ) { return hx::Val( m_enableMotor ); }
		if (HX_FIELD_EQ(inName,"m_enableLimit") ) { return hx::Val( m_enableLimit ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"isLimitEnabled") ) { return hx::Val( isLimitEnabled_dyn() ); }
		if (HX_FIELD_EQ(inName,"isMotorEnabled") ) { return hx::Val( isMotorEnabled_dyn() ); }
		if (HX_FIELD_EQ(inName,"getMotorTorque") ) { return hx::Val( getMotorTorque_dyn() ); }
		if (HX_FIELD_EQ(inName,"m_localAnchor1") ) { return hx::Val( m_localAnchor1 ); }
		if (HX_FIELD_EQ(inName,"m_localAnchor2") ) { return hx::Val( m_localAnchor2 ); }
		if (HX_FIELD_EQ(inName,"m_motorImpulse") ) { return hx::Val( m_motorImpulse ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"getReactionForce") ) { return hx::Val( getReactionForce_dyn() ); }
		if (HX_FIELD_EQ(inName,"m_maxMotorTorque") ) { return hx::Val( m_maxMotorTorque ); }
		if (HX_FIELD_EQ(inName,"m_referenceAngle") ) { return hx::Val( m_referenceAngle ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"getReactionTorque") ) { return hx::Val( getReactionTorque_dyn() ); }
		if (HX_FIELD_EQ(inName,"setMaxMotorTorque") ) { return hx::Val( setMaxMotorTorque_dyn() ); }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"initVelocityConstraints") ) { return hx::Val( initVelocityConstraints_dyn() ); }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"solveVelocityConstraints") ) { return hx::Val( solveVelocityConstraints_dyn() ); }
		if (HX_FIELD_EQ(inName,"solvePositionConstraints") ) { return hx::Val( solvePositionConstraints_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool B2RevoluteJoint_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"tImpulse") ) { outValue = ( tImpulse ); return true; }
	}
	return false;
}

hx::Val B2RevoluteJoint_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"K") ) { K=inValue.Cast<  ::box2D::common::math::B2Mat22 >(); return inValue; }
		break;
	case 2:
		if (HX_FIELD_EQ(inName,"K1") ) { K1=inValue.Cast<  ::box2D::common::math::B2Mat22 >(); return inValue; }
		if (HX_FIELD_EQ(inName,"K2") ) { K2=inValue.Cast<  ::box2D::common::math::B2Mat22 >(); return inValue; }
		if (HX_FIELD_EQ(inName,"K3") ) { K3=inValue.Cast<  ::box2D::common::math::B2Mat22 >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"m_mass") ) { m_mass=inValue.Cast<  ::box2D::common::math::B2Mat33 >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"reduced") ) { reduced=inValue.Cast<  ::box2D::common::math::B2Vec2 >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"impulse3") ) { impulse3=inValue.Cast<  ::box2D::common::math::B2Vec3 >(); return inValue; }
		if (HX_FIELD_EQ(inName,"impulse2") ) { impulse2=inValue.Cast<  ::box2D::common::math::B2Vec2 >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"m_impulse") ) { m_impulse=inValue.Cast<  ::box2D::common::math::B2Vec3 >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"m_motorMass") ) { m_motorMass=inValue.Cast< Float >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"m_motorSpeed") ) { m_motorSpeed=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"m_lowerAngle") ) { m_lowerAngle=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"m_upperAngle") ) { m_upperAngle=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"m_limitState") ) { m_limitState=inValue.Cast< int >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"m_enableMotor") ) { m_enableMotor=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"m_enableLimit") ) { m_enableLimit=inValue.Cast< bool >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"m_localAnchor1") ) { m_localAnchor1=inValue.Cast<  ::box2D::common::math::B2Vec2 >(); return inValue; }
		if (HX_FIELD_EQ(inName,"m_localAnchor2") ) { m_localAnchor2=inValue.Cast<  ::box2D::common::math::B2Vec2 >(); return inValue; }
		if (HX_FIELD_EQ(inName,"m_motorImpulse") ) { m_motorImpulse=inValue.Cast< Float >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"m_maxMotorTorque") ) { m_maxMotorTorque=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"m_referenceAngle") ) { m_referenceAngle=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool B2RevoluteJoint_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"tImpulse") ) { tImpulse=ioValue.Cast<  ::box2D::common::math::B2Vec2 >(); return true; }
	}
	return false;
}

void B2RevoluteJoint_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("K","\x4b","\x00","\x00","\x00"));
	outFields->push(HX_HCSTRING("K1","\x86","\x41","\x00","\x00"));
	outFields->push(HX_HCSTRING("K2","\x87","\x41","\x00","\x00"));
	outFields->push(HX_HCSTRING("K3","\x88","\x41","\x00","\x00"));
	outFields->push(HX_HCSTRING("impulse3","\xde","\x4d","\xe9","\x97"));
	outFields->push(HX_HCSTRING("impulse2","\xdd","\x4d","\xe9","\x97"));
	outFields->push(HX_HCSTRING("reduced","\xfe","\xc3","\x4d","\xc8"));
	outFields->push(HX_HCSTRING("m_localAnchor1","\x43","\x30","\xee","\x9e"));
	outFields->push(HX_HCSTRING("m_localAnchor2","\x44","\x30","\xee","\x9e"));
	outFields->push(HX_HCSTRING("m_impulse","\xa3","\x5f","\x3f","\x78"));
	outFields->push(HX_HCSTRING("m_motorImpulse","\x12","\x63","\x1d","\xf1"));
	outFields->push(HX_HCSTRING("m_mass","\x46","\xb1","\x4d","\x90"));
	outFields->push(HX_HCSTRING("m_motorMass","\x77","\xc2","\x33","\xe8"));
	outFields->push(HX_HCSTRING("m_enableMotor","\xe0","\xb4","\x32","\xf0"));
	outFields->push(HX_HCSTRING("m_maxMotorTorque","\xad","\x93","\x80","\x11"));
	outFields->push(HX_HCSTRING("m_motorSpeed","\xa4","\x68","\x5d","\xc3"));
	outFields->push(HX_HCSTRING("m_enableLimit","\xa6","\x83","\xcf","\x58"));
	outFields->push(HX_HCSTRING("m_referenceAngle","\xda","\x56","\x05","\xf4"));
	outFields->push(HX_HCSTRING("m_lowerAngle","\xe4","\x4f","\x4c","\xb0"));
	outFields->push(HX_HCSTRING("m_upperAngle","\xe3","\xd0","\x7a","\xb5"));
	outFields->push(HX_HCSTRING("m_limitState","\xa8","\x2a","\xe1","\x56"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo B2RevoluteJoint_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::box2D::common::math::B2Mat22*/ ,(int)offsetof(B2RevoluteJoint_obj,K),HX_HCSTRING("K","\x4b","\x00","\x00","\x00")},
	{hx::fsObject /*::box2D::common::math::B2Mat22*/ ,(int)offsetof(B2RevoluteJoint_obj,K1),HX_HCSTRING("K1","\x86","\x41","\x00","\x00")},
	{hx::fsObject /*::box2D::common::math::B2Mat22*/ ,(int)offsetof(B2RevoluteJoint_obj,K2),HX_HCSTRING("K2","\x87","\x41","\x00","\x00")},
	{hx::fsObject /*::box2D::common::math::B2Mat22*/ ,(int)offsetof(B2RevoluteJoint_obj,K3),HX_HCSTRING("K3","\x88","\x41","\x00","\x00")},
	{hx::fsObject /*::box2D::common::math::B2Vec3*/ ,(int)offsetof(B2RevoluteJoint_obj,impulse3),HX_HCSTRING("impulse3","\xde","\x4d","\xe9","\x97")},
	{hx::fsObject /*::box2D::common::math::B2Vec2*/ ,(int)offsetof(B2RevoluteJoint_obj,impulse2),HX_HCSTRING("impulse2","\xdd","\x4d","\xe9","\x97")},
	{hx::fsObject /*::box2D::common::math::B2Vec2*/ ,(int)offsetof(B2RevoluteJoint_obj,reduced),HX_HCSTRING("reduced","\xfe","\xc3","\x4d","\xc8")},
	{hx::fsObject /*::box2D::common::math::B2Vec2*/ ,(int)offsetof(B2RevoluteJoint_obj,m_localAnchor1),HX_HCSTRING("m_localAnchor1","\x43","\x30","\xee","\x9e")},
	{hx::fsObject /*::box2D::common::math::B2Vec2*/ ,(int)offsetof(B2RevoluteJoint_obj,m_localAnchor2),HX_HCSTRING("m_localAnchor2","\x44","\x30","\xee","\x9e")},
	{hx::fsObject /*::box2D::common::math::B2Vec3*/ ,(int)offsetof(B2RevoluteJoint_obj,m_impulse),HX_HCSTRING("m_impulse","\xa3","\x5f","\x3f","\x78")},
	{hx::fsFloat,(int)offsetof(B2RevoluteJoint_obj,m_motorImpulse),HX_HCSTRING("m_motorImpulse","\x12","\x63","\x1d","\xf1")},
	{hx::fsObject /*::box2D::common::math::B2Mat33*/ ,(int)offsetof(B2RevoluteJoint_obj,m_mass),HX_HCSTRING("m_mass","\x46","\xb1","\x4d","\x90")},
	{hx::fsFloat,(int)offsetof(B2RevoluteJoint_obj,m_motorMass),HX_HCSTRING("m_motorMass","\x77","\xc2","\x33","\xe8")},
	{hx::fsBool,(int)offsetof(B2RevoluteJoint_obj,m_enableMotor),HX_HCSTRING("m_enableMotor","\xe0","\xb4","\x32","\xf0")},
	{hx::fsFloat,(int)offsetof(B2RevoluteJoint_obj,m_maxMotorTorque),HX_HCSTRING("m_maxMotorTorque","\xad","\x93","\x80","\x11")},
	{hx::fsFloat,(int)offsetof(B2RevoluteJoint_obj,m_motorSpeed),HX_HCSTRING("m_motorSpeed","\xa4","\x68","\x5d","\xc3")},
	{hx::fsBool,(int)offsetof(B2RevoluteJoint_obj,m_enableLimit),HX_HCSTRING("m_enableLimit","\xa6","\x83","\xcf","\x58")},
	{hx::fsFloat,(int)offsetof(B2RevoluteJoint_obj,m_referenceAngle),HX_HCSTRING("m_referenceAngle","\xda","\x56","\x05","\xf4")},
	{hx::fsFloat,(int)offsetof(B2RevoluteJoint_obj,m_lowerAngle),HX_HCSTRING("m_lowerAngle","\xe4","\x4f","\x4c","\xb0")},
	{hx::fsFloat,(int)offsetof(B2RevoluteJoint_obj,m_upperAngle),HX_HCSTRING("m_upperAngle","\xe3","\xd0","\x7a","\xb5")},
	{hx::fsInt,(int)offsetof(B2RevoluteJoint_obj,m_limitState),HX_HCSTRING("m_limitState","\xa8","\x2a","\xe1","\x56")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo B2RevoluteJoint_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*::box2D::common::math::B2Vec2*/ ,(void *) &B2RevoluteJoint_obj::tImpulse,HX_HCSTRING("tImpulse","\xa1","\x2e","\xea","\x25")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String B2RevoluteJoint_obj_sMemberFields[] = {
	HX_HCSTRING("getAnchorA","\x36","\x72","\x03","\x52"),
	HX_HCSTRING("getAnchorB","\x37","\x72","\x03","\x52"),
	HX_HCSTRING("getReactionForce","\x0c","\x7f","\x58","\x41"),
	HX_HCSTRING("getReactionTorque","\x89","\x66","\x20","\x85"),
	HX_HCSTRING("getJointAngle","\x5f","\xea","\x53","\xdd"),
	HX_HCSTRING("getJointSpeed","\x13","\x3e","\xdb","\x3b"),
	HX_HCSTRING("isLimitEnabled","\x90","\x19","\xb5","\x29"),
	HX_HCSTRING("enableLimit","\xb8","\x65","\xd0","\x3f"),
	HX_HCSTRING("getLowerLimit","\xb0","\x0d","\xd2","\x8d"),
	HX_HCSTRING("getUpperLimit","\xaf","\x8e","\x00","\x93"),
	HX_HCSTRING("setLimits","\x1a","\xaa","\xa1","\x4b"),
	HX_HCSTRING("isMotorEnabled","\x96","\xe3","\xf7","\x31"),
	HX_HCSTRING("enableMotor","\xf2","\x96","\x33","\xd7"),
	HX_HCSTRING("setMotorSpeed","\x14","\x2d","\xca","\x93"),
	HX_HCSTRING("getMotorSpeed","\x08","\x4b","\xc4","\x4e"),
	HX_HCSTRING("setMaxMotorTorque","\x1d","\x50","\x80","\x8e"),
	HX_HCSTRING("getMotorTorque","\x29","\x14","\x93","\x78"),
	HX_HCSTRING("K","\x4b","\x00","\x00","\x00"),
	HX_HCSTRING("K1","\x86","\x41","\x00","\x00"),
	HX_HCSTRING("K2","\x87","\x41","\x00","\x00"),
	HX_HCSTRING("K3","\x88","\x41","\x00","\x00"),
	HX_HCSTRING("initVelocityConstraints","\x29","\xf9","\xf0","\x64"),
	HX_HCSTRING("impulse3","\xde","\x4d","\xe9","\x97"),
	HX_HCSTRING("impulse2","\xdd","\x4d","\xe9","\x97"),
	HX_HCSTRING("reduced","\xfe","\xc3","\x4d","\xc8"),
	HX_HCSTRING("solveVelocityConstraints","\x1a","\x56","\xac","\xc2"),
	HX_HCSTRING("solvePositionConstraints","\x0e","\x6b","\x88","\xfa"),
	HX_HCSTRING("m_localAnchor1","\x43","\x30","\xee","\x9e"),
	HX_HCSTRING("m_localAnchor2","\x44","\x30","\xee","\x9e"),
	HX_HCSTRING("m_impulse","\xa3","\x5f","\x3f","\x78"),
	HX_HCSTRING("m_motorImpulse","\x12","\x63","\x1d","\xf1"),
	HX_HCSTRING("m_mass","\x46","\xb1","\x4d","\x90"),
	HX_HCSTRING("m_motorMass","\x77","\xc2","\x33","\xe8"),
	HX_HCSTRING("m_enableMotor","\xe0","\xb4","\x32","\xf0"),
	HX_HCSTRING("m_maxMotorTorque","\xad","\x93","\x80","\x11"),
	HX_HCSTRING("m_motorSpeed","\xa4","\x68","\x5d","\xc3"),
	HX_HCSTRING("m_enableLimit","\xa6","\x83","\xcf","\x58"),
	HX_HCSTRING("m_referenceAngle","\xda","\x56","\x05","\xf4"),
	HX_HCSTRING("m_lowerAngle","\xe4","\x4f","\x4c","\xb0"),
	HX_HCSTRING("m_upperAngle","\xe3","\xd0","\x7a","\xb5"),
	HX_HCSTRING("m_limitState","\xa8","\x2a","\xe1","\x56"),
	::String(null()) };

static void B2RevoluteJoint_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(B2RevoluteJoint_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(B2RevoluteJoint_obj::tImpulse,"tImpulse");
};

#ifdef HXCPP_VISIT_ALLOCS
static void B2RevoluteJoint_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(B2RevoluteJoint_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(B2RevoluteJoint_obj::tImpulse,"tImpulse");
};

#endif

hx::Class B2RevoluteJoint_obj::__mClass;

static ::String B2RevoluteJoint_obj_sStaticFields[] = {
	HX_HCSTRING("tImpulse","\xa1","\x2e","\xea","\x25"),
	::String(null())
};

void B2RevoluteJoint_obj::__register()
{
	hx::Object *dummy = new B2RevoluteJoint_obj;
	B2RevoluteJoint_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("box2D.dynamics.joints.B2RevoluteJoint","\x78","\x44","\x91","\x20");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &B2RevoluteJoint_obj::__GetStatic;
	__mClass->mSetStaticField = &B2RevoluteJoint_obj::__SetStatic;
	__mClass->mMarkFunc = B2RevoluteJoint_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(B2RevoluteJoint_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(B2RevoluteJoint_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< B2RevoluteJoint_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = B2RevoluteJoint_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = B2RevoluteJoint_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = B2RevoluteJoint_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void B2RevoluteJoint_obj::__boot()
{
{
            	HX_GC_STACKFRAME(&_hx_pos_48708f914c341c71_499_boot)
HXDLIN( 499)		tImpulse =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
            	}
}

} // end namespace box2D
} // end namespace dynamics
} // end namespace joints
