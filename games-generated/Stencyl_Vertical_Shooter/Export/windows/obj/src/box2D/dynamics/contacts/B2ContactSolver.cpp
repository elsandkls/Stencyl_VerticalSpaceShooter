// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_box2D_collision_B2Manifold
#include <box2D/collision/B2Manifold.h>
#endif
#ifndef INCLUDED_box2D_collision_B2ManifoldPoint
#include <box2D/collision/B2ManifoldPoint.h>
#endif
#ifndef INCLUDED_box2D_collision_B2WorldManifold
#include <box2D/collision/B2WorldManifold.h>
#endif
#ifndef INCLUDED_box2D_collision_shapes_B2Shape
#include <box2D/collision/shapes/B2Shape.h>
#endif
#ifndef INCLUDED_box2D_common_B2Settings
#include <box2D/common/B2Settings.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Mat22
#include <box2D/common/math/B2Mat22.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Math
#include <box2D/common/math/B2Math.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Sweep
#include <box2D/common/math/B2Sweep.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Transform
#include <box2D/common/math/B2Transform.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Vec2
#include <box2D/common/math/B2Vec2.h>
#endif
#ifndef INCLUDED_box2D_dynamics_B2Body
#include <box2D/dynamics/B2Body.h>
#endif
#ifndef INCLUDED_box2D_dynamics_B2Fixture
#include <box2D/dynamics/B2Fixture.h>
#endif
#ifndef INCLUDED_box2D_dynamics_B2TimeStep
#include <box2D/dynamics/B2TimeStep.h>
#endif
#ifndef INCLUDED_box2D_dynamics_contacts_B2Contact
#include <box2D/dynamics/contacts/B2Contact.h>
#endif
#ifndef INCLUDED_box2D_dynamics_contacts_B2ContactConstraint
#include <box2D/dynamics/contacts/B2ContactConstraint.h>
#endif
#ifndef INCLUDED_box2D_dynamics_contacts_B2ContactConstraintPoint
#include <box2D/dynamics/contacts/B2ContactConstraintPoint.h>
#endif
#ifndef INCLUDED_box2D_dynamics_contacts_B2ContactSolver
#include <box2D/dynamics/contacts/B2ContactSolver.h>
#endif
#ifndef INCLUDED_box2D_dynamics_contacts_B2PositionSolverManifold
#include <box2D/dynamics/contacts/B2PositionSolverManifold.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_7c129a85634d5b74_43_new,"box2D.dynamics.contacts.B2ContactSolver","new",0x08cbbf63,"box2D.dynamics.contacts.B2ContactSolver.new","box2D/dynamics/contacts/B2ContactSolver.hx",43,0x75c0a5ce)
HX_LOCAL_STACK_FRAME(_hx_pos_7c129a85634d5b74_50_initialize,"box2D.dynamics.contacts.B2ContactSolver","initialize",0xb54678ad,"box2D.dynamics.contacts.B2ContactSolver.initialize","box2D/dynamics/contacts/B2ContactSolver.hx",50,0x75c0a5ce)
HX_LOCAL_STACK_FRAME(_hx_pos_7c129a85634d5b74_224_initVelocityConstraints,"box2D.dynamics.contacts.B2ContactSolver","initVelocityConstraints",0xac9c9bac,"box2D.dynamics.contacts.B2ContactSolver.initVelocityConstraints","box2D/dynamics/contacts/B2ContactSolver.hx",224,0x75c0a5ce)
HX_LOCAL_STACK_FRAME(_hx_pos_7c129a85634d5b74_287_solveVelocityConstraints,"box2D.dynamics.contacts.B2ContactSolver","solveVelocityConstraints",0x312ee637,"box2D.dynamics.contacts.B2ContactSolver.solveVelocityConstraints","box2D/dynamics/contacts/B2ContactSolver.hx",287,0x75c0a5ce)
HX_LOCAL_STACK_FRAME(_hx_pos_7c129a85634d5b74_743_finalizeVelocityConstraints,"box2D.dynamics.contacts.B2ContactSolver","finalizeVelocityConstraints",0xcbb61f5e,"box2D.dynamics.contacts.B2ContactSolver.finalizeVelocityConstraints","box2D/dynamics/contacts/B2ContactSolver.hx",743,0x75c0a5ce)
HX_LOCAL_STACK_FRAME(_hx_pos_7c129a85634d5b74_864_solvePositionConstraints,"box2D.dynamics.contacts.B2ContactSolver","solvePositionConstraints",0x690afb2b,"box2D.dynamics.contacts.B2ContactSolver.solvePositionConstraints","box2D/dynamics/contacts/B2ContactSolver.hx",864,0x75c0a5ce)
HX_LOCAL_STACK_FRAME(_hx_pos_7c129a85634d5b74_40_boot,"box2D.dynamics.contacts.B2ContactSolver","boot",0xa194b7cf,"box2D.dynamics.contacts.B2ContactSolver.boot","box2D/dynamics/contacts/B2ContactSolver.hx",40,0x75c0a5ce)
HX_LOCAL_STACK_FRAME(_hx_pos_7c129a85634d5b74_48_boot,"box2D.dynamics.contacts.B2ContactSolver","boot",0xa194b7cf,"box2D.dynamics.contacts.B2ContactSolver.boot","box2D/dynamics/contacts/B2ContactSolver.hx",48,0x75c0a5ce)
HX_LOCAL_STACK_FRAME(_hx_pos_7c129a85634d5b74_862_boot,"box2D.dynamics.contacts.B2ContactSolver","boot",0xa194b7cf,"box2D.dynamics.contacts.B2ContactSolver.boot","box2D/dynamics/contacts/B2ContactSolver.hx",862,0x75c0a5ce)
namespace box2D{
namespace dynamics{
namespace contacts{

void B2ContactSolver_obj::__construct(){
            	HX_GC_STACKFRAME(&_hx_pos_7c129a85634d5b74_43_new)
HXLINE(  44)		this->m_step =  ::box2D::dynamics::B2TimeStep_obj::__alloc( HX_CTX );
HXLINE(  45)		this->m_constraints = ::Array_obj< ::Dynamic>::__new();
            	}

Dynamic B2ContactSolver_obj::__CreateEmpty() { return new B2ContactSolver_obj; }

void *B2ContactSolver_obj::_hx_vtable = 0;

Dynamic B2ContactSolver_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< B2ContactSolver_obj > _hx_result = new B2ContactSolver_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool B2ContactSolver_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x4512d83f;
}

void B2ContactSolver_obj::initialize( ::box2D::dynamics::B2TimeStep step,::Array< ::Dynamic> contacts,int contactCount, ::Dynamic allocator){
            	HX_GC_STACKFRAME(&_hx_pos_7c129a85634d5b74_50_initialize)
HXLINE(  51)		 ::box2D::dynamics::contacts::B2Contact contact;
HXLINE(  53)		this->m_step->set(step);
HXLINE(  55)		this->m_allocator = allocator;
HXLINE(  57)		int i;
HXLINE(  58)		 ::box2D::common::math::B2Vec2 tVec;
HXLINE(  59)		 ::box2D::common::math::B2Mat22 tMat;
HXLINE(  61)		this->m_constraintCount = contactCount;
HXLINE(  64)		while((this->m_constraints->length < this->m_constraintCount)){
HXLINE(  66)			::Array< ::Dynamic> _hx_tmp = this->m_constraints;
HXDLIN(  66)			int _hx_tmp1 = this->m_constraints->length;
HXDLIN(  66)			_hx_tmp[_hx_tmp1] =  ::box2D::dynamics::contacts::B2ContactConstraint_obj::__alloc( HX_CTX );
            		}
HXLINE(  69)		{
HXLINE(  69)			int _g1 = (int)0;
HXDLIN(  69)			int _g = contactCount;
HXDLIN(  69)			while((_g1 < _g)){
HXLINE(  69)				_g1 = (_g1 + (int)1);
HXDLIN(  69)				int i1 = (_g1 - (int)1);
HXLINE(  71)				contact = contacts->__get(i1).StaticCast<  ::box2D::dynamics::contacts::B2Contact >();
HXLINE(  72)				 ::box2D::dynamics::B2Fixture fixtureA = contact->m_fixtureA;
HXLINE(  73)				 ::box2D::dynamics::B2Fixture fixtureB = contact->m_fixtureB;
HXLINE(  74)				 ::box2D::collision::shapes::B2Shape shapeA = fixtureA->m_shape;
HXLINE(  75)				 ::box2D::collision::shapes::B2Shape shapeB = fixtureB->m_shape;
HXLINE(  76)				Float radiusA = shapeA->m_radius;
HXLINE(  77)				Float radiusB = shapeB->m_radius;
HXLINE(  78)				 ::box2D::dynamics::B2Body bodyA = fixtureA->m_body;
HXLINE(  79)				 ::box2D::dynamics::B2Body bodyB = fixtureB->m_body;
HXLINE(  80)				 ::box2D::collision::B2Manifold manifold = contact->getManifold();
HXLINE(  82)				Float friction = fixtureA->getFriction();
HXDLIN(  82)				Float friction1 = ::box2D::common::B2Settings_obj::b2MixFriction(friction,fixtureB->getFriction());
HXLINE(  83)				Float restitution = fixtureA->getRestitution();
HXDLIN(  83)				Float restitution1 = ::box2D::common::B2Settings_obj::b2MixRestitution(restitution,fixtureB->getRestitution());
HXLINE(  86)				Float vAX = bodyA->m_linearVelocity->x;
HXLINE(  87)				Float vAY = bodyA->m_linearVelocity->y;
HXLINE(  89)				Float vBX = bodyB->m_linearVelocity->x;
HXLINE(  90)				Float vBY = bodyB->m_linearVelocity->y;
HXLINE(  91)				Float wA = bodyA->m_angularVelocity;
HXLINE(  92)				Float wB = bodyB->m_angularVelocity;
HXLINE(  94)				::box2D::common::B2Settings_obj::b2Assert((manifold->m_pointCount > (int)0));
HXLINE(  96)				::box2D::dynamics::contacts::B2ContactSolver_obj::s_worldManifold->initialize(manifold,bodyA->m_xf,radiusA,bodyB->m_xf,radiusB);
HXLINE(  98)				Float normalX = ::box2D::dynamics::contacts::B2ContactSolver_obj::s_worldManifold->m_normal->x;
HXLINE(  99)				Float normalY = ::box2D::dynamics::contacts::B2ContactSolver_obj::s_worldManifold->m_normal->y;
HXLINE( 101)				 ::box2D::dynamics::contacts::B2ContactConstraint cc = this->m_constraints->__get(i1).StaticCast<  ::box2D::dynamics::contacts::B2ContactConstraint >();
HXLINE( 102)				cc->bodyA = bodyA;
HXLINE( 103)				cc->bodyB = bodyB;
HXLINE( 104)				cc->manifold = manifold;
HXLINE( 106)				cc->normal->x = normalX;
HXLINE( 107)				cc->normal->y = normalY;
HXLINE( 108)				cc->pointCount = manifold->m_pointCount;
HXLINE( 109)				cc->friction = friction1;
HXLINE( 110)				cc->restitution = restitution1;
HXLINE( 112)				cc->localPlaneNormal->x = manifold->m_localPlaneNormal->x;
HXLINE( 113)				cc->localPlaneNormal->y = manifold->m_localPlaneNormal->y;
HXLINE( 114)				cc->localPoint->x = manifold->m_localPoint->x;
HXLINE( 115)				cc->localPoint->y = manifold->m_localPoint->y;
HXLINE( 116)				cc->radius = (radiusA + radiusB);
HXLINE( 117)				cc->type = manifold->m_type;
HXLINE( 119)				{
HXLINE( 119)					int _g3 = (int)0;
HXDLIN( 119)					int _g2 = cc->pointCount;
HXDLIN( 119)					while((_g3 < _g2)){
HXLINE( 119)						_g3 = (_g3 + (int)1);
HXDLIN( 119)						int k = (_g3 - (int)1);
HXLINE( 121)						 ::box2D::collision::B2ManifoldPoint cp = manifold->m_points->__get(k).StaticCast<  ::box2D::collision::B2ManifoldPoint >();
HXLINE( 122)						 ::box2D::dynamics::contacts::B2ContactConstraintPoint ccp = cc->points->__get(k).StaticCast<  ::box2D::dynamics::contacts::B2ContactConstraintPoint >();
HXLINE( 124)						ccp->normalImpulse = cp->m_normalImpulse;
HXLINE( 125)						ccp->tangentImpulse = cp->m_tangentImpulse;
HXLINE( 127)						{
HXLINE( 127)							 ::box2D::common::math::B2Vec2 _this = ccp->localPoint;
HXDLIN( 127)							 ::box2D::common::math::B2Vec2 v = cp->m_localPoint;
HXDLIN( 127)							_this->x = v->x;
HXDLIN( 127)							_this->y = v->y;
            						}
HXLINE( 129)						Float rAX = (ccp->rA->x = (::box2D::dynamics::contacts::B2ContactSolver_obj::s_worldManifold->m_points->__get(k).StaticCast<  ::box2D::common::math::B2Vec2 >()->x - bodyA->m_sweep->c->x));
HXLINE( 130)						Float rAY = (ccp->rA->y = (::box2D::dynamics::contacts::B2ContactSolver_obj::s_worldManifold->m_points->__get(k).StaticCast<  ::box2D::common::math::B2Vec2 >()->y - bodyA->m_sweep->c->y));
HXLINE( 131)						Float rBX = (ccp->rB->x = (::box2D::dynamics::contacts::B2ContactSolver_obj::s_worldManifold->m_points->__get(k).StaticCast<  ::box2D::common::math::B2Vec2 >()->x - bodyB->m_sweep->c->x));
HXLINE( 132)						Float rBY = (ccp->rB->y = (::box2D::dynamics::contacts::B2ContactSolver_obj::s_worldManifold->m_points->__get(k).StaticCast<  ::box2D::common::math::B2Vec2 >()->y - bodyB->m_sweep->c->y));
HXLINE( 134)						Float rnA = ((rAX * normalY) - (rAY * normalX));
HXLINE( 135)						Float rnB = ((rBX * normalY) - (rBY * normalX));
HXLINE( 137)						rnA = (rnA * rnA);
HXLINE( 138)						rnB = (rnB * rnB);
HXLINE( 140)						Float kNormal = (bodyA->m_invMass + bodyB->m_invMass);
HXDLIN( 140)						Float kNormal1 = (kNormal + (bodyA->m_invI * rnA));
HXDLIN( 140)						Float kNormal2 = (kNormal1 + (bodyB->m_invI * rnB));
HXLINE( 142)						ccp->normalMass = ((Float)((Float)1.0) / (Float)kNormal2);
HXLINE( 144)						Float kEqualized = (bodyA->m_mass * bodyA->m_invMass);
HXDLIN( 144)						Float kEqualized1 = (kEqualized + (bodyB->m_mass * bodyB->m_invMass));
HXLINE( 145)						Float kEqualized2 = ((bodyA->m_mass * bodyA->m_invI) * rnA);
HXDLIN( 145)						kEqualized1 = (kEqualized1 + (kEqualized2 + ((bodyB->m_mass * bodyB->m_invI) * rnB)));
HXLINE( 147)						ccp->equalizedMass = ((Float)((Float)1.0) / (Float)kEqualized1);
HXLINE( 150)						Float tangentX = normalY;
HXLINE( 151)						Float tangentY = -(normalX);
HXLINE( 154)						Float rtA = ((rAX * tangentY) - (rAY * tangentX));
HXLINE( 156)						Float rtB = ((rBX * tangentY) - (rBY * tangentX));
HXLINE( 158)						rtA = (rtA * rtA);
HXLINE( 159)						rtB = (rtB * rtB);
HXLINE( 161)						Float kTangent = (bodyA->m_invMass + bodyB->m_invMass);
HXDLIN( 161)						Float kTangent1 = (kTangent + (bodyA->m_invI * rtA));
HXDLIN( 161)						Float kTangent2 = (kTangent1 + (bodyB->m_invI * rtB));
HXLINE( 163)						ccp->tangentMass = ((Float)((Float)1.0) / (Float)kTangent2);
HXLINE( 166)						ccp->velocityBias = ((Float)0.0);
HXLINE( 168)						Float tX = (((vBX + (-(wB) * rBY)) - vAX) - (-(wA) * rAY));
HXLINE( 169)						Float tY = (((vBY + (wB * rBX)) - vAY) - (wA * rAX));
HXLINE( 171)						Float vRel = (cc->normal->x * tX);
HXDLIN( 171)						Float vRel1 = (vRel + (cc->normal->y * tY));
HXLINE( 172)						if ((vRel1 < -(::box2D::common::B2Settings_obj::b2_velocityThreshold))) {
HXLINE( 174)							 ::box2D::dynamics::contacts::B2ContactConstraintPoint ccp1 = ccp;
HXDLIN( 174)							ccp1->velocityBias = (ccp1->velocityBias + (-(cc->restitution) * vRel1));
            						}
            					}
            				}
HXLINE( 179)				if ((cc->pointCount == (int)2)) {
HXLINE( 181)					 ::box2D::dynamics::contacts::B2ContactConstraintPoint ccp11 = cc->points->__get((int)0).StaticCast<  ::box2D::dynamics::contacts::B2ContactConstraintPoint >();
HXLINE( 182)					 ::box2D::dynamics::contacts::B2ContactConstraintPoint ccp2 = cc->points->__get((int)1).StaticCast<  ::box2D::dynamics::contacts::B2ContactConstraintPoint >();
HXLINE( 184)					Float invMassA = bodyA->m_invMass;
HXLINE( 185)					Float invIA = bodyA->m_invI;
HXLINE( 186)					Float invMassB = bodyB->m_invMass;
HXLINE( 187)					Float invIB = bodyB->m_invI;
HXLINE( 193)					Float rn1A = (ccp11->rA->x * normalY);
HXDLIN( 193)					Float rn1A1 = (rn1A - (ccp11->rA->y * normalX));
HXLINE( 194)					Float rn1B = (ccp11->rB->x * normalY);
HXDLIN( 194)					Float rn1B1 = (rn1B - (ccp11->rB->y * normalX));
HXLINE( 195)					Float rn2A = (ccp2->rA->x * normalY);
HXDLIN( 195)					Float rn2A1 = (rn2A - (ccp2->rA->y * normalX));
HXLINE( 196)					Float rn2B = (ccp2->rB->x * normalY);
HXDLIN( 196)					Float rn2B1 = (rn2B - (ccp2->rB->y * normalX));
HXLINE( 198)					Float k11 = (((invMassA + invMassB) + ((invIA * rn1A1) * rn1A1)) + ((invIB * rn1B1) * rn1B1));
HXLINE( 199)					Float k22 = (((invMassA + invMassB) + ((invIA * rn2A1) * rn2A1)) + ((invIB * rn2B1) * rn2B1));
HXLINE( 200)					Float k12 = (((invMassA + invMassB) + ((invIA * rn1A1) * rn2A1)) + ((invIB * rn1B1) * rn2B1));
HXLINE( 203)					Float k_maxConditionNumber = ((Float)100.0);
HXLINE( 204)					if (((k11 * k11) < (k_maxConditionNumber * ((k11 * k22) - (k12 * k12))))) {
HXLINE( 207)						{
HXLINE( 207)							 ::box2D::common::math::B2Vec2 _this1 = cc->K->col1;
HXDLIN( 207)							_this1->x = k11;
HXDLIN( 207)							_this1->y = k12;
            						}
HXLINE( 208)						{
HXLINE( 208)							 ::box2D::common::math::B2Vec2 _this2 = cc->K->col2;
HXDLIN( 208)							_this2->x = k12;
HXDLIN( 208)							_this2->y = k22;
            						}
HXLINE( 209)						cc->K->getInverse(cc->normalMass);
            					}
            					else {
HXLINE( 215)						cc->pointCount = (int)1;
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(B2ContactSolver_obj,initialize,(void))

void B2ContactSolver_obj::initVelocityConstraints( ::box2D::dynamics::B2TimeStep step){
            	HX_STACKFRAME(&_hx_pos_7c129a85634d5b74_224_initVelocityConstraints)
HXLINE( 225)		 ::box2D::common::math::B2Vec2 tVec;
HXLINE( 226)		 ::box2D::common::math::B2Vec2 tVec2;
HXLINE( 227)		 ::box2D::common::math::B2Mat22 tMat;
HXLINE( 230)		{
HXLINE( 230)			int _g1 = (int)0;
HXDLIN( 230)			int _g = this->m_constraintCount;
HXDLIN( 230)			while((_g1 < _g)){
HXLINE( 230)				_g1 = (_g1 + (int)1);
HXDLIN( 230)				int i = (_g1 - (int)1);
HXLINE( 232)				 ::box2D::dynamics::contacts::B2ContactConstraint c = this->m_constraints->__get(i).StaticCast<  ::box2D::dynamics::contacts::B2ContactConstraint >();
HXLINE( 234)				 ::box2D::dynamics::B2Body bodyA = c->bodyA;
HXLINE( 235)				 ::box2D::dynamics::B2Body bodyB = c->bodyB;
HXLINE( 236)				Float invMassA = bodyA->m_invMass;
HXLINE( 237)				Float invIA = bodyA->m_invI;
HXLINE( 238)				Float invMassB = bodyB->m_invMass;
HXLINE( 239)				Float invIB = bodyB->m_invI;
HXLINE( 241)				Float normalX = c->normal->x;
HXLINE( 242)				Float normalY = c->normal->y;
HXLINE( 244)				Float tangentX = normalY;
HXLINE( 245)				Float tangentY = -(normalX);
HXLINE( 247)				Float tX;
HXLINE( 249)				int j;
HXLINE( 250)				int tCount;
HXLINE( 251)				if (step->warmStarting) {
HXLINE( 253)					tCount = c->pointCount;
HXLINE( 254)					{
HXLINE( 254)						int _g3 = (int)0;
HXDLIN( 254)						int _g2 = tCount;
HXDLIN( 254)						while((_g3 < _g2)){
HXLINE( 254)							_g3 = (_g3 + (int)1);
HXDLIN( 254)							int j1 = (_g3 - (int)1);
HXLINE( 256)							 ::box2D::dynamics::contacts::B2ContactConstraintPoint ccp = c->points->__get(j1).StaticCast<  ::box2D::dynamics::contacts::B2ContactConstraintPoint >();
HXLINE( 257)							 ::box2D::dynamics::contacts::B2ContactConstraintPoint ccp1 = ccp;
HXDLIN( 257)							ccp1->normalImpulse = (ccp1->normalImpulse * step->dtRatio);
HXLINE( 258)							 ::box2D::dynamics::contacts::B2ContactConstraintPoint ccp2 = ccp;
HXDLIN( 258)							ccp2->tangentImpulse = (ccp2->tangentImpulse * step->dtRatio);
HXLINE( 260)							Float PX = (ccp->normalImpulse * normalX);
HXDLIN( 260)							Float PX1 = (PX + (ccp->tangentImpulse * tangentX));
HXLINE( 261)							Float PY = (ccp->normalImpulse * normalY);
HXDLIN( 261)							Float PY1 = (PY + (ccp->tangentImpulse * tangentY));
HXLINE( 264)							 ::box2D::dynamics::B2Body bodyA1 = bodyA;
HXDLIN( 264)							Float _hx_tmp = (ccp->rA->x * PY1);
HXDLIN( 264)							bodyA1->m_angularVelocity = (bodyA1->m_angularVelocity - (invIA * (_hx_tmp - (ccp->rA->y * PX1))));
HXLINE( 266)							 ::box2D::common::math::B2Vec2 bodyA2 = bodyA->m_linearVelocity;
HXDLIN( 266)							bodyA2->x = (bodyA2->x - (invMassA * PX1));
HXLINE( 267)							 ::box2D::common::math::B2Vec2 bodyA3 = bodyA->m_linearVelocity;
HXDLIN( 267)							bodyA3->y = (bodyA3->y - (invMassA * PY1));
HXLINE( 269)							 ::box2D::dynamics::B2Body bodyB1 = bodyB;
HXDLIN( 269)							Float _hx_tmp1 = (ccp->rB->x * PY1);
HXDLIN( 269)							bodyB1->m_angularVelocity = (bodyB1->m_angularVelocity + (invIB * (_hx_tmp1 - (ccp->rB->y * PX1))));
HXLINE( 271)							 ::box2D::common::math::B2Vec2 bodyB2 = bodyB->m_linearVelocity;
HXDLIN( 271)							bodyB2->x = (bodyB2->x + (invMassB * PX1));
HXLINE( 272)							 ::box2D::common::math::B2Vec2 bodyB3 = bodyB->m_linearVelocity;
HXDLIN( 272)							bodyB3->y = (bodyB3->y + (invMassB * PY1));
            						}
            					}
            				}
            				else {
HXLINE( 277)					tCount = c->pointCount;
HXLINE( 278)					{
HXLINE( 278)						int _g31 = (int)0;
HXDLIN( 278)						int _g21 = tCount;
HXDLIN( 278)						while((_g31 < _g21)){
HXLINE( 278)							_g31 = (_g31 + (int)1);
HXDLIN( 278)							int j2 = (_g31 - (int)1);
HXLINE( 280)							 ::box2D::dynamics::contacts::B2ContactConstraintPoint ccp21 = c->points->__get(j2).StaticCast<  ::box2D::dynamics::contacts::B2ContactConstraintPoint >();
HXLINE( 281)							ccp21->normalImpulse = ((Float)0.0);
HXLINE( 282)							ccp21->tangentImpulse = ((Float)0.0);
            						}
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(B2ContactSolver_obj,initVelocityConstraints,(void))

void B2ContactSolver_obj::solveVelocityConstraints(){
            	HX_STACKFRAME(&_hx_pos_7c129a85634d5b74_287_solveVelocityConstraints)
HXLINE( 288)		int j;
HXLINE( 289)		 ::box2D::dynamics::contacts::B2ContactConstraintPoint ccp;
HXLINE( 290)		Float rAX;
HXLINE( 291)		Float rAY;
HXLINE( 292)		Float rBX;
HXLINE( 293)		Float rBY;
HXLINE( 294)		Float dvX;
HXLINE( 295)		Float dvY;
HXLINE( 296)		Float vn;
HXLINE( 297)		Float vt;
HXLINE( 298)		Float lambda;
HXLINE( 299)		Float maxFriction;
HXLINE( 300)		Float newImpulse;
HXLINE( 301)		Float PX;
HXLINE( 302)		Float PY;
HXLINE( 303)		Float dX;
HXLINE( 304)		Float dY;
HXLINE( 305)		Float P1X;
HXLINE( 306)		Float P1Y;
HXLINE( 307)		Float P2X;
HXLINE( 308)		Float P2Y;
HXLINE( 310)		 ::box2D::common::math::B2Mat22 tMat;
HXLINE( 311)		 ::box2D::common::math::B2Vec2 tVec;
HXLINE( 313)		{
HXLINE( 313)			int _g1 = (int)0;
HXDLIN( 313)			int _g = this->m_constraintCount;
HXDLIN( 313)			while((_g1 < _g)){
HXLINE( 313)				_g1 = (_g1 + (int)1);
HXDLIN( 313)				int i = (_g1 - (int)1);
HXLINE( 315)				 ::box2D::dynamics::contacts::B2ContactConstraint c = this->m_constraints->__get(i).StaticCast<  ::box2D::dynamics::contacts::B2ContactConstraint >();
HXLINE( 316)				 ::box2D::dynamics::B2Body bodyA = c->bodyA;
HXLINE( 317)				 ::box2D::dynamics::B2Body bodyB = c->bodyB;
HXLINE( 318)				Float wA = bodyA->m_angularVelocity;
HXLINE( 319)				Float wB = bodyB->m_angularVelocity;
HXLINE( 320)				 ::box2D::common::math::B2Vec2 vA = bodyA->m_linearVelocity;
HXLINE( 321)				 ::box2D::common::math::B2Vec2 vB = bodyB->m_linearVelocity;
HXLINE( 323)				Float invMassA = bodyA->m_invMass;
HXLINE( 324)				Float invIA = bodyA->m_invI;
HXLINE( 325)				Float invMassB = bodyB->m_invMass;
HXLINE( 326)				Float invIB = bodyB->m_invI;
HXLINE( 328)				Float normalX = c->normal->x;
HXLINE( 329)				Float normalY = c->normal->y;
HXLINE( 331)				Float tangentX = normalY;
HXLINE( 332)				Float tangentY = -(normalX);
HXLINE( 333)				Float friction = c->friction;
HXLINE( 335)				Float tX;
HXLINE( 339)				{
HXLINE( 339)					int _g3 = (int)0;
HXDLIN( 339)					int _g2 = c->pointCount;
HXDLIN( 339)					while((_g3 < _g2)){
HXLINE( 339)						_g3 = (_g3 + (int)1);
HXDLIN( 339)						int j1 = (_g3 - (int)1);
HXLINE( 341)						ccp = c->points->__get(j1).StaticCast<  ::box2D::dynamics::contacts::B2ContactConstraintPoint >();
HXLINE( 345)						Float vB1 = vB->x;
HXDLIN( 345)						Float dvX1 = ((vB1 - (wB * ccp->rB->y)) - vA->x);
HXDLIN( 345)						dvX = (dvX1 + (wA * ccp->rA->y));
HXLINE( 346)						Float vB2 = vB->y;
HXDLIN( 346)						Float dvY1 = ((vB2 + (wB * ccp->rB->x)) - vA->y);
HXDLIN( 346)						dvY = (dvY1 - (wA * ccp->rA->x));
HXLINE( 349)						vt = ((dvX * tangentX) + (dvY * tangentY));
HXLINE( 350)						lambda = (ccp->tangentMass * -(vt));
HXLINE( 353)						maxFriction = (friction * ccp->normalImpulse);
HXLINE( 354)						newImpulse = ::box2D::common::math::B2Math_obj::clamp((ccp->tangentImpulse + lambda),-(maxFriction),maxFriction);
HXLINE( 355)						lambda = (newImpulse - ccp->tangentImpulse);
HXLINE( 358)						PX = (lambda * tangentX);
HXLINE( 359)						PY = (lambda * tangentY);
HXLINE( 361)						 ::box2D::common::math::B2Vec2 vA1 = vA;
HXDLIN( 361)						vA1->x = (vA1->x - (invMassA * PX));
HXLINE( 362)						 ::box2D::common::math::B2Vec2 vA2 = vA;
HXDLIN( 362)						vA2->y = (vA2->y - (invMassA * PY));
HXLINE( 363)						Float wA1 = (ccp->rA->x * PY);
HXDLIN( 363)						wA = (wA - (invIA * (wA1 - (ccp->rA->y * PX))));
HXLINE( 365)						 ::box2D::common::math::B2Vec2 vB3 = vB;
HXDLIN( 365)						vB3->x = (vB3->x + (invMassB * PX));
HXLINE( 366)						 ::box2D::common::math::B2Vec2 vB4 = vB;
HXDLIN( 366)						vB4->y = (vB4->y + (invMassB * PY));
HXLINE( 367)						Float wB1 = (ccp->rB->x * PY);
HXDLIN( 367)						wB = (wB + (invIB * (wB1 - (ccp->rB->y * PX))));
HXLINE( 369)						ccp->tangentImpulse = newImpulse;
            					}
            				}
HXLINE( 373)				int tCount = c->pointCount;
HXLINE( 374)				if ((c->pointCount == (int)1)) {
HXLINE( 376)					ccp = c->points->__get((int)0).StaticCast<  ::box2D::dynamics::contacts::B2ContactConstraintPoint >();
HXLINE( 380)					Float vB5 = vB->x;
HXDLIN( 380)					Float dvX2 = ((vB5 + (-(wB) * ccp->rB->y)) - vA->x);
HXDLIN( 380)					dvX = (dvX2 - (-(wA) * ccp->rA->y));
HXLINE( 381)					Float vB6 = vB->y;
HXDLIN( 381)					Float dvY2 = ((vB6 + (wB * ccp->rB->x)) - vA->y);
HXDLIN( 381)					dvY = (dvY2 - (wA * ccp->rA->x));
HXLINE( 385)					vn = ((dvX * normalX) + (dvY * normalY));
HXLINE( 386)					Float lambda1 = -(ccp->normalMass);
HXDLIN( 386)					lambda = (lambda1 * (vn - ccp->velocityBias));
HXLINE( 390)					newImpulse = (ccp->normalImpulse + lambda);
HXLINE( 391)					if ((newImpulse > (int)0)) {
HXLINE( 391)						newImpulse = newImpulse;
            					}
            					else {
HXLINE( 391)						newImpulse = ((Float)0.0);
            					}
HXLINE( 392)					lambda = (newImpulse - ccp->normalImpulse);
HXLINE( 396)					PX = (lambda * normalX);
HXLINE( 397)					PY = (lambda * normalY);
HXLINE( 400)					 ::box2D::common::math::B2Vec2 vA3 = vA;
HXDLIN( 400)					vA3->x = (vA3->x - (invMassA * PX));
HXLINE( 401)					 ::box2D::common::math::B2Vec2 vA4 = vA;
HXDLIN( 401)					vA4->y = (vA4->y - (invMassA * PY));
HXLINE( 402)					Float wA2 = (ccp->rA->x * PY);
HXDLIN( 402)					wA = (wA - (invIA * (wA2 - (ccp->rA->y * PX))));
HXLINE( 405)					 ::box2D::common::math::B2Vec2 vB7 = vB;
HXDLIN( 405)					vB7->x = (vB7->x + (invMassB * PX));
HXLINE( 406)					 ::box2D::common::math::B2Vec2 vB8 = vB;
HXDLIN( 406)					vB8->y = (vB8->y + (invMassB * PY));
HXLINE( 407)					Float wB2 = (ccp->rB->x * PY);
HXDLIN( 407)					wB = (wB + (invIB * (wB2 - (ccp->rB->y * PX))));
HXLINE( 409)					ccp->normalImpulse = newImpulse;
            				}
            				else {
HXLINE( 441)					 ::box2D::dynamics::contacts::B2ContactConstraintPoint cp1 = c->points->__get((int)0).StaticCast<  ::box2D::dynamics::contacts::B2ContactConstraintPoint >();
HXLINE( 442)					 ::box2D::dynamics::contacts::B2ContactConstraintPoint cp2 = c->points->__get((int)1).StaticCast<  ::box2D::dynamics::contacts::B2ContactConstraintPoint >();
HXLINE( 444)					Float aX = cp1->normalImpulse;
HXLINE( 445)					Float aY = cp2->normalImpulse;
HXLINE( 450)					Float vB9 = vB->x;
HXDLIN( 450)					Float dv1X = ((vB9 - (wB * cp1->rB->y)) - vA->x);
HXDLIN( 450)					Float dv1X1 = (dv1X + (wA * cp1->rA->y));
HXLINE( 451)					Float vB10 = vB->y;
HXDLIN( 451)					Float dv1Y = ((vB10 + (wB * cp1->rB->x)) - vA->y);
HXDLIN( 451)					Float dv1Y1 = (dv1Y - (wA * cp1->rA->x));
HXLINE( 453)					Float vB11 = vB->x;
HXDLIN( 453)					Float dv2X = ((vB11 - (wB * cp2->rB->y)) - vA->x);
HXDLIN( 453)					Float dv2X1 = (dv2X + (wA * cp2->rA->y));
HXLINE( 454)					Float vB12 = vB->y;
HXDLIN( 454)					Float dv2Y = ((vB12 + (wB * cp2->rB->x)) - vA->y);
HXDLIN( 454)					Float dv2Y1 = (dv2Y - (wA * cp2->rA->x));
HXLINE( 458)					Float vn1 = ((dv1X1 * normalX) + (dv1Y1 * normalY));
HXLINE( 460)					Float vn2 = ((dv2X1 * normalX) + (dv2Y1 * normalY));
HXLINE( 462)					Float bX = (vn1 - cp1->velocityBias);
HXLINE( 463)					Float bY = (vn2 - cp2->velocityBias);
HXLINE( 466)					tMat = c->K;
HXLINE( 467)					Float bX1 = (tMat->col1->x * aX);
HXDLIN( 467)					bX = (bX - (bX1 + (tMat->col2->x * aY)));
HXLINE( 468)					Float bY1 = (tMat->col1->y * aX);
HXDLIN( 468)					bY = (bY - (bY1 + (tMat->col2->y * aY)));
HXLINE( 470)					Float k_errorTol = ((Float)0.001);
HXLINE( 471)					{
HXLINE( 471)						int _g21 = (int)0;
HXDLIN( 471)						while((_g21 < (int)1)){
HXLINE( 471)							_g21 = (_g21 + (int)1);
HXDLIN( 471)							int i1 = (_g21 - (int)1);
HXLINE( 484)							tMat = c->normalMass;
HXLINE( 485)							Float xX = (tMat->col1->x * bX);
HXDLIN( 485)							Float xX1 = -((xX + (tMat->col2->x * bY)));
HXLINE( 486)							Float xY = (tMat->col1->y * bX);
HXDLIN( 486)							Float xY1 = -((xY + (tMat->col2->y * bY)));
HXLINE( 488)							bool _hx_tmp;
HXDLIN( 488)							if ((xX1 >= ((Float)0.0))) {
HXLINE( 488)								_hx_tmp = (xY1 >= ((Float)0.0));
            							}
            							else {
HXLINE( 488)								_hx_tmp = false;
            							}
HXDLIN( 488)							if (_hx_tmp) {
HXLINE( 491)								dX = (xX1 - aX);
HXLINE( 492)								dY = (xY1 - aY);
HXLINE( 496)								P1X = (dX * normalX);
HXLINE( 497)								P1Y = (dX * normalY);
HXLINE( 499)								P2X = (dY * normalX);
HXLINE( 500)								P2Y = (dY * normalY);
HXLINE( 503)								 ::box2D::common::math::B2Vec2 vA5 = vA;
HXDLIN( 503)								vA5->x = (vA5->x - (invMassA * (P1X + P2X)));
HXLINE( 504)								 ::box2D::common::math::B2Vec2 vA6 = vA;
HXDLIN( 504)								vA6->y = (vA6->y - (invMassA * (P1Y + P2Y)));
HXLINE( 506)								Float wA3 = (cp1->rA->x * P1Y);
HXDLIN( 506)								Float wA4 = (wA3 - (cp1->rA->y * P1X));
HXDLIN( 506)								Float wA5 = (wA4 + (cp2->rA->x * P2Y));
HXDLIN( 506)								wA = (wA - (invIA * (wA5 - (cp2->rA->y * P2X))));
HXLINE( 509)								 ::box2D::common::math::B2Vec2 vB13 = vB;
HXDLIN( 509)								vB13->x = (vB13->x + (invMassB * (P1X + P2X)));
HXLINE( 510)								 ::box2D::common::math::B2Vec2 vB14 = vB;
HXDLIN( 510)								vB14->y = (vB14->y + (invMassB * (P1Y + P2Y)));
HXLINE( 512)								Float wB3 = (cp1->rB->x * P1Y);
HXDLIN( 512)								Float wB4 = (wB3 - (cp1->rB->y * P1X));
HXDLIN( 512)								Float wB5 = (wB4 + (cp2->rB->x * P2Y));
HXDLIN( 512)								wB = (wB + (invIB * (wB5 - (cp2->rB->y * P2X))));
HXLINE( 515)								cp1->normalImpulse = xX1;
HXLINE( 516)								cp2->normalImpulse = xY1;
HXLINE( 535)								goto _hx_goto_11;
            							}
HXLINE( 545)							xX1 = (-(cp1->normalMass) * bX);
HXLINE( 546)							xY1 = ((Float)0.0);
HXLINE( 547)							vn1 = ((Float)0.0);
HXLINE( 548)							vn2 = ((c->K->col1->y * xX1) + bY);
HXLINE( 550)							bool _hx_tmp1;
HXDLIN( 550)							if ((xX1 >= ((Float)0.0))) {
HXLINE( 550)								_hx_tmp1 = (vn2 >= ((Float)0.0));
            							}
            							else {
HXLINE( 550)								_hx_tmp1 = false;
            							}
HXDLIN( 550)							if (_hx_tmp1) {
HXLINE( 554)								dX = (xX1 - aX);
HXLINE( 555)								dY = (xY1 - aY);
HXLINE( 559)								P1X = (dX * normalX);
HXLINE( 560)								P1Y = (dX * normalY);
HXLINE( 562)								P2X = (dY * normalX);
HXLINE( 563)								P2Y = (dY * normalY);
HXLINE( 566)								 ::box2D::common::math::B2Vec2 vA7 = vA;
HXDLIN( 566)								vA7->x = (vA7->x - (invMassA * (P1X + P2X)));
HXLINE( 567)								 ::box2D::common::math::B2Vec2 vA8 = vA;
HXDLIN( 567)								vA8->y = (vA8->y - (invMassA * (P1Y + P2Y)));
HXLINE( 569)								Float wA6 = (cp1->rA->x * P1Y);
HXDLIN( 569)								Float wA7 = (wA6 - (cp1->rA->y * P1X));
HXDLIN( 569)								Float wA8 = (wA7 + (cp2->rA->x * P2Y));
HXDLIN( 569)								wA = (wA - (invIA * (wA8 - (cp2->rA->y * P2X))));
HXLINE( 572)								 ::box2D::common::math::B2Vec2 vB15 = vB;
HXDLIN( 572)								vB15->x = (vB15->x + (invMassB * (P1X + P2X)));
HXLINE( 573)								 ::box2D::common::math::B2Vec2 vB16 = vB;
HXDLIN( 573)								vB16->y = (vB16->y + (invMassB * (P1Y + P2Y)));
HXLINE( 575)								Float wB6 = (cp1->rB->x * P1Y);
HXDLIN( 575)								Float wB7 = (wB6 - (cp1->rB->y * P1X));
HXDLIN( 575)								Float wB8 = (wB7 + (cp2->rB->x * P2Y));
HXDLIN( 575)								wB = (wB + (invIB * (wB8 - (cp2->rB->y * P2X))));
HXLINE( 578)								cp1->normalImpulse = xX1;
HXLINE( 579)								cp2->normalImpulse = xY1;
HXLINE( 598)								goto _hx_goto_11;
            							}
HXLINE( 608)							xX1 = ((Float)0.0);
HXLINE( 609)							xY1 = (-(cp2->normalMass) * bY);
HXLINE( 610)							vn1 = ((c->K->col2->x * xY1) + bX);
HXLINE( 611)							vn2 = ((Float)0.0);
HXLINE( 612)							bool _hx_tmp2;
HXDLIN( 612)							if ((xY1 >= ((Float)0.0))) {
HXLINE( 612)								_hx_tmp2 = (vn1 >= ((Float)0.0));
            							}
            							else {
HXLINE( 612)								_hx_tmp2 = false;
            							}
HXDLIN( 612)							if (_hx_tmp2) {
HXLINE( 616)								dX = (xX1 - aX);
HXLINE( 617)								dY = (xY1 - aY);
HXLINE( 621)								P1X = (dX * normalX);
HXLINE( 622)								P1Y = (dX * normalY);
HXLINE( 624)								P2X = (dY * normalX);
HXLINE( 625)								P2Y = (dY * normalY);
HXLINE( 628)								 ::box2D::common::math::B2Vec2 vA9 = vA;
HXDLIN( 628)								vA9->x = (vA9->x - (invMassA * (P1X + P2X)));
HXLINE( 629)								 ::box2D::common::math::B2Vec2 vA10 = vA;
HXDLIN( 629)								vA10->y = (vA10->y - (invMassA * (P1Y + P2Y)));
HXLINE( 631)								Float wA9 = (cp1->rA->x * P1Y);
HXDLIN( 631)								Float wA10 = (wA9 - (cp1->rA->y * P1X));
HXDLIN( 631)								Float wA11 = (wA10 + (cp2->rA->x * P2Y));
HXDLIN( 631)								wA = (wA - (invIA * (wA11 - (cp2->rA->y * P2X))));
HXLINE( 634)								 ::box2D::common::math::B2Vec2 vB17 = vB;
HXDLIN( 634)								vB17->x = (vB17->x + (invMassB * (P1X + P2X)));
HXLINE( 635)								 ::box2D::common::math::B2Vec2 vB18 = vB;
HXDLIN( 635)								vB18->y = (vB18->y + (invMassB * (P1Y + P2Y)));
HXLINE( 637)								Float wB9 = (cp1->rB->x * P1Y);
HXDLIN( 637)								Float wB10 = (wB9 - (cp1->rB->y * P1X));
HXDLIN( 637)								Float wB11 = (wB10 + (cp2->rB->x * P2Y));
HXDLIN( 637)								wB = (wB + (invIB * (wB11 - (cp2->rB->y * P2X))));
HXLINE( 640)								cp1->normalImpulse = xX1;
HXLINE( 641)								cp2->normalImpulse = xY1;
HXLINE( 660)								goto _hx_goto_11;
            							}
HXLINE( 669)							xX1 = ((Float)0.0);
HXLINE( 670)							xY1 = ((Float)0.0);
HXLINE( 671)							vn1 = bX;
HXLINE( 672)							vn2 = bY;
HXLINE( 674)							bool _hx_tmp3;
HXDLIN( 674)							if ((vn1 >= ((Float)0.0))) {
HXLINE( 674)								_hx_tmp3 = (vn2 >= ((Float)0.0));
            							}
            							else {
HXLINE( 674)								_hx_tmp3 = false;
            							}
HXDLIN( 674)							if (_hx_tmp3) {
HXLINE( 677)								dX = (xX1 - aX);
HXLINE( 678)								dY = (xY1 - aY);
HXLINE( 682)								P1X = (dX * normalX);
HXLINE( 683)								P1Y = (dX * normalY);
HXLINE( 685)								P2X = (dY * normalX);
HXLINE( 686)								P2Y = (dY * normalY);
HXLINE( 689)								 ::box2D::common::math::B2Vec2 vA11 = vA;
HXDLIN( 689)								vA11->x = (vA11->x - (invMassA * (P1X + P2X)));
HXLINE( 690)								 ::box2D::common::math::B2Vec2 vA12 = vA;
HXDLIN( 690)								vA12->y = (vA12->y - (invMassA * (P1Y + P2Y)));
HXLINE( 692)								Float wA12 = (cp1->rA->x * P1Y);
HXDLIN( 692)								Float wA13 = (wA12 - (cp1->rA->y * P1X));
HXDLIN( 692)								Float wA14 = (wA13 + (cp2->rA->x * P2Y));
HXDLIN( 692)								wA = (wA - (invIA * (wA14 - (cp2->rA->y * P2X))));
HXLINE( 695)								 ::box2D::common::math::B2Vec2 vB19 = vB;
HXDLIN( 695)								vB19->x = (vB19->x + (invMassB * (P1X + P2X)));
HXLINE( 696)								 ::box2D::common::math::B2Vec2 vB20 = vB;
HXDLIN( 696)								vB20->y = (vB20->y + (invMassB * (P1Y + P2Y)));
HXLINE( 698)								Float wB12 = (cp1->rB->x * P1Y);
HXDLIN( 698)								Float wB13 = (wB12 - (cp1->rB->y * P1X));
HXDLIN( 698)								Float wB14 = (wB13 + (cp2->rB->x * P2Y));
HXDLIN( 698)								wB = (wB + (invIB * (wB14 - (cp2->rB->y * P2X))));
HXLINE( 701)								cp1->normalImpulse = xX1;
HXLINE( 702)								cp2->normalImpulse = xY1;
HXLINE( 721)								goto _hx_goto_11;
            							}
HXLINE( 725)							goto _hx_goto_11;
            						}
            						_hx_goto_11:;
            					}
            				}
HXLINE( 736)				bodyA->m_angularVelocity = wA;
HXLINE( 737)				bodyB->m_angularVelocity = wB;
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(B2ContactSolver_obj,solveVelocityConstraints,(void))

void B2ContactSolver_obj::finalizeVelocityConstraints(){
            	HX_STACKFRAME(&_hx_pos_7c129a85634d5b74_743_finalizeVelocityConstraints)
HXDLIN( 743)		int _g1 = (int)0;
HXDLIN( 743)		int _g = this->m_constraintCount;
HXDLIN( 743)		while((_g1 < _g)){
HXDLIN( 743)			_g1 = (_g1 + (int)1);
HXDLIN( 743)			int i = (_g1 - (int)1);
HXLINE( 745)			 ::box2D::dynamics::contacts::B2ContactConstraint c = this->m_constraints->__get(i).StaticCast<  ::box2D::dynamics::contacts::B2ContactConstraint >();
HXLINE( 746)			 ::box2D::collision::B2Manifold m = c->manifold;
HXLINE( 748)			{
HXLINE( 748)				int _g3 = (int)0;
HXDLIN( 748)				int _g2 = c->pointCount;
HXDLIN( 748)				while((_g3 < _g2)){
HXLINE( 748)					_g3 = (_g3 + (int)1);
HXDLIN( 748)					int j = (_g3 - (int)1);
HXLINE( 750)					 ::box2D::collision::B2ManifoldPoint point1 = m->m_points->__get(j).StaticCast<  ::box2D::collision::B2ManifoldPoint >();
HXLINE( 751)					 ::box2D::dynamics::contacts::B2ContactConstraintPoint point2 = c->points->__get(j).StaticCast<  ::box2D::dynamics::contacts::B2ContactConstraintPoint >();
HXLINE( 752)					point1->m_normalImpulse = point2->normalImpulse;
HXLINE( 753)					point1->m_tangentImpulse = point2->tangentImpulse;
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(B2ContactSolver_obj,finalizeVelocityConstraints,(void))

bool B2ContactSolver_obj::solvePositionConstraints(Float baumgarte){
            	HX_STACKFRAME(&_hx_pos_7c129a85634d5b74_864_solvePositionConstraints)
HXLINE( 865)		Float minSeparation = ((Float)0.0);
HXLINE( 867)		{
HXLINE( 867)			int _g1 = (int)0;
HXDLIN( 867)			int _g = this->m_constraintCount;
HXDLIN( 867)			while((_g1 < _g)){
HXLINE( 867)				_g1 = (_g1 + (int)1);
HXDLIN( 867)				int i = (_g1 - (int)1);
HXLINE( 869)				 ::box2D::dynamics::contacts::B2ContactConstraint c = this->m_constraints->__get(i).StaticCast<  ::box2D::dynamics::contacts::B2ContactConstraint >();
HXLINE( 870)				 ::box2D::dynamics::B2Body bodyA = c->bodyA;
HXLINE( 871)				 ::box2D::dynamics::B2Body bodyB = c->bodyB;
HXLINE( 873)				Float invMassA = (bodyA->m_mass * bodyA->m_invMass);
HXLINE( 874)				Float invIA = (bodyA->m_mass * bodyA->m_invI);
HXLINE( 875)				Float invMassB = (bodyB->m_mass * bodyB->m_invMass);
HXLINE( 876)				Float invIB = (bodyB->m_mass * bodyB->m_invI);
HXLINE( 879)				::box2D::dynamics::contacts::B2ContactSolver_obj::s_psm->initialize(c);
HXLINE( 880)				 ::box2D::common::math::B2Vec2 normal = ::box2D::dynamics::contacts::B2ContactSolver_obj::s_psm->m_normal;
HXLINE( 883)				{
HXLINE( 883)					int _g3 = (int)0;
HXDLIN( 883)					int _g2 = c->pointCount;
HXDLIN( 883)					while((_g3 < _g2)){
HXLINE( 883)						_g3 = (_g3 + (int)1);
HXDLIN( 883)						int j = (_g3 - (int)1);
HXLINE( 885)						 ::box2D::dynamics::contacts::B2ContactConstraintPoint ccp = c->points->__get(j).StaticCast<  ::box2D::dynamics::contacts::B2ContactConstraintPoint >();
HXLINE( 887)						 ::box2D::common::math::B2Vec2 point = ::box2D::dynamics::contacts::B2ContactSolver_obj::s_psm->m_points->__get(j).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXLINE( 888)						Float separation = ::box2D::dynamics::contacts::B2ContactSolver_obj::s_psm->m_separations->__get(j);
HXLINE( 890)						Float rAX = (point->x - bodyA->m_sweep->c->x);
HXLINE( 891)						Float rAY = (point->y - bodyA->m_sweep->c->y);
HXLINE( 892)						Float rBX = (point->x - bodyB->m_sweep->c->x);
HXLINE( 893)						Float rBY = (point->y - bodyB->m_sweep->c->y);
HXLINE( 896)						if ((minSeparation < separation)) {
HXLINE( 896)							minSeparation = minSeparation;
            						}
            						else {
HXLINE( 896)							minSeparation = separation;
            						}
HXLINE( 899)						Float C = ::box2D::common::math::B2Math_obj::clamp((baumgarte * (separation + ::box2D::common::B2Settings_obj::b2_linearSlop)),-(::box2D::common::B2Settings_obj::b2_maxLinearCorrection),((Float)0.0));
HXLINE( 902)						Float impulse = (-(ccp->equalizedMass) * C);
HXLINE( 904)						Float PX = (impulse * normal->x);
HXLINE( 905)						Float PY = (impulse * normal->y);
HXLINE( 908)						 ::box2D::common::math::B2Vec2 bodyA1 = bodyA->m_sweep->c;
HXDLIN( 908)						bodyA1->x = (bodyA1->x - (invMassA * PX));
HXLINE( 909)						 ::box2D::common::math::B2Vec2 bodyA2 = bodyA->m_sweep->c;
HXDLIN( 909)						bodyA2->y = (bodyA2->y - (invMassA * PY));
HXLINE( 911)						 ::box2D::common::math::B2Sweep bodyA3 = bodyA->m_sweep;
HXDLIN( 911)						bodyA3->a = (bodyA3->a - (invIA * ((rAX * PY) - (rAY * PX))));
HXLINE( 912)						bodyA->synchronizeTransform();
HXLINE( 915)						 ::box2D::common::math::B2Vec2 bodyB1 = bodyB->m_sweep->c;
HXDLIN( 915)						bodyB1->x = (bodyB1->x + (invMassB * PX));
HXLINE( 916)						 ::box2D::common::math::B2Vec2 bodyB2 = bodyB->m_sweep->c;
HXDLIN( 916)						bodyB2->y = (bodyB2->y + (invMassB * PY));
HXLINE( 918)						 ::box2D::common::math::B2Sweep bodyB3 = bodyB->m_sweep;
HXDLIN( 918)						bodyB3->a = (bodyB3->a + (invIB * ((rBX * PY) - (rBY * PX))));
HXLINE( 919)						bodyB->synchronizeTransform();
            					}
            				}
            			}
            		}
HXLINE( 925)		return (minSeparation > (((Float)-1.5) * ::box2D::common::B2Settings_obj::b2_linearSlop));
            	}


HX_DEFINE_DYNAMIC_FUNC1(B2ContactSolver_obj,solvePositionConstraints,return )

int B2ContactSolver_obj::staticFix;

 ::box2D::collision::B2WorldManifold B2ContactSolver_obj::s_worldManifold;

 ::box2D::dynamics::contacts::B2PositionSolverManifold B2ContactSolver_obj::s_psm;


hx::ObjectPtr< B2ContactSolver_obj > B2ContactSolver_obj::__new() {
	hx::ObjectPtr< B2ContactSolver_obj > __this = new B2ContactSolver_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< B2ContactSolver_obj > B2ContactSolver_obj::__alloc(hx::Ctx *_hx_ctx) {
	B2ContactSolver_obj *__this = (B2ContactSolver_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(B2ContactSolver_obj), true, "box2D.dynamics.contacts.B2ContactSolver"));
	*(void **)__this = B2ContactSolver_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

B2ContactSolver_obj::B2ContactSolver_obj()
{
}

void B2ContactSolver_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(B2ContactSolver);
	HX_MARK_MEMBER_NAME(m_step,"m_step");
	HX_MARK_MEMBER_NAME(m_allocator,"m_allocator");
	HX_MARK_MEMBER_NAME(m_constraints,"m_constraints");
	HX_MARK_MEMBER_NAME(m_constraintCount,"m_constraintCount");
	HX_MARK_END_CLASS();
}

void B2ContactSolver_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(m_step,"m_step");
	HX_VISIT_MEMBER_NAME(m_allocator,"m_allocator");
	HX_VISIT_MEMBER_NAME(m_constraints,"m_constraints");
	HX_VISIT_MEMBER_NAME(m_constraintCount,"m_constraintCount");
}

hx::Val B2ContactSolver_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"m_step") ) { return hx::Val( m_step ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"initialize") ) { return hx::Val( initialize_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"m_allocator") ) { return hx::Val( m_allocator ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"m_constraints") ) { return hx::Val( m_constraints ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"m_constraintCount") ) { return hx::Val( m_constraintCount ); }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"initVelocityConstraints") ) { return hx::Val( initVelocityConstraints_dyn() ); }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"solveVelocityConstraints") ) { return hx::Val( solveVelocityConstraints_dyn() ); }
		if (HX_FIELD_EQ(inName,"solvePositionConstraints") ) { return hx::Val( solvePositionConstraints_dyn() ); }
		break;
	case 27:
		if (HX_FIELD_EQ(inName,"finalizeVelocityConstraints") ) { return hx::Val( finalizeVelocityConstraints_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool B2ContactSolver_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"s_psm") ) { outValue = ( s_psm ); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"staticFix") ) { outValue = ( staticFix ); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"s_worldManifold") ) { outValue = ( s_worldManifold ); return true; }
	}
	return false;
}

hx::Val B2ContactSolver_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"m_step") ) { m_step=inValue.Cast<  ::box2D::dynamics::B2TimeStep >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"m_allocator") ) { m_allocator=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"m_constraints") ) { m_constraints=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"m_constraintCount") ) { m_constraintCount=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool B2ContactSolver_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"s_psm") ) { s_psm=ioValue.Cast<  ::box2D::dynamics::contacts::B2PositionSolverManifold >(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"staticFix") ) { staticFix=ioValue.Cast< int >(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"s_worldManifold") ) { s_worldManifold=ioValue.Cast<  ::box2D::collision::B2WorldManifold >(); return true; }
	}
	return false;
}

void B2ContactSolver_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("m_step","\x9e","\x57","\x53","\x94"));
	outFields->push(HX_HCSTRING("m_allocator","\x39","\xc2","\xe3","\x76"));
	outFields->push(HX_HCSTRING("m_constraints","\x64","\x6f","\xb3","\x30"));
	outFields->push(HX_HCSTRING("m_constraintCount","\x20","\xf0","\x24","\xbb"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo B2ContactSolver_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::box2D::dynamics::B2TimeStep*/ ,(int)offsetof(B2ContactSolver_obj,m_step),HX_HCSTRING("m_step","\x9e","\x57","\x53","\x94")},
	{hx::fsObject /*Dynamic*/ ,(int)offsetof(B2ContactSolver_obj,m_allocator),HX_HCSTRING("m_allocator","\x39","\xc2","\xe3","\x76")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(B2ContactSolver_obj,m_constraints),HX_HCSTRING("m_constraints","\x64","\x6f","\xb3","\x30")},
	{hx::fsInt,(int)offsetof(B2ContactSolver_obj,m_constraintCount),HX_HCSTRING("m_constraintCount","\x20","\xf0","\x24","\xbb")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo B2ContactSolver_obj_sStaticStorageInfo[] = {
	{hx::fsInt,(void *) &B2ContactSolver_obj::staticFix,HX_HCSTRING("staticFix","\xc7","\x3d","\x0e","\x87")},
	{hx::fsObject /*::box2D::collision::B2WorldManifold*/ ,(void *) &B2ContactSolver_obj::s_worldManifold,HX_HCSTRING("s_worldManifold","\x76","\x34","\x7c","\xac")},
	{hx::fsObject /*::box2D::dynamics::contacts::B2PositionSolverManifold*/ ,(void *) &B2ContactSolver_obj::s_psm,HX_HCSTRING("s_psm","\xfe","\x5b","\x35","\x76")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String B2ContactSolver_obj_sMemberFields[] = {
	HX_HCSTRING("initialize","\x50","\x31","\xbb","\xec"),
	HX_HCSTRING("initVelocityConstraints","\x29","\xf9","\xf0","\x64"),
	HX_HCSTRING("solveVelocityConstraints","\x1a","\x56","\xac","\xc2"),
	HX_HCSTRING("finalizeVelocityConstraints","\x5b","\x7f","\x13","\x7b"),
	HX_HCSTRING("solvePositionConstraints","\x0e","\x6b","\x88","\xfa"),
	HX_HCSTRING("m_step","\x9e","\x57","\x53","\x94"),
	HX_HCSTRING("m_allocator","\x39","\xc2","\xe3","\x76"),
	HX_HCSTRING("m_constraints","\x64","\x6f","\xb3","\x30"),
	HX_HCSTRING("m_constraintCount","\x20","\xf0","\x24","\xbb"),
	::String(null()) };

static void B2ContactSolver_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(B2ContactSolver_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(B2ContactSolver_obj::staticFix,"staticFix");
	HX_MARK_MEMBER_NAME(B2ContactSolver_obj::s_worldManifold,"s_worldManifold");
	HX_MARK_MEMBER_NAME(B2ContactSolver_obj::s_psm,"s_psm");
};

#ifdef HXCPP_VISIT_ALLOCS
static void B2ContactSolver_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(B2ContactSolver_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(B2ContactSolver_obj::staticFix,"staticFix");
	HX_VISIT_MEMBER_NAME(B2ContactSolver_obj::s_worldManifold,"s_worldManifold");
	HX_VISIT_MEMBER_NAME(B2ContactSolver_obj::s_psm,"s_psm");
};

#endif

hx::Class B2ContactSolver_obj::__mClass;

static ::String B2ContactSolver_obj_sStaticFields[] = {
	HX_HCSTRING("staticFix","\xc7","\x3d","\x0e","\x87"),
	HX_HCSTRING("s_worldManifold","\x76","\x34","\x7c","\xac"),
	HX_HCSTRING("s_psm","\xfe","\x5b","\x35","\x76"),
	::String(null())
};

void B2ContactSolver_obj::__register()
{
	hx::Object *dummy = new B2ContactSolver_obj;
	B2ContactSolver_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("box2D.dynamics.contacts.B2ContactSolver","\xf1","\xd1","\xc1","\x72");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &B2ContactSolver_obj::__GetStatic;
	__mClass->mSetStaticField = &B2ContactSolver_obj::__SetStatic;
	__mClass->mMarkFunc = B2ContactSolver_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(B2ContactSolver_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(B2ContactSolver_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< B2ContactSolver_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = B2ContactSolver_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = B2ContactSolver_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = B2ContactSolver_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void B2ContactSolver_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_7c129a85634d5b74_40_boot)
HXDLIN(  40)		staticFix = ::box2D::common::B2Settings_obj::b2_maxManifoldPoints;
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_7c129a85634d5b74_48_boot)
HXDLIN(  48)		s_worldManifold =  ::box2D::collision::B2WorldManifold_obj::__alloc( HX_CTX );
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_7c129a85634d5b74_862_boot)
HXDLIN( 862)		s_psm =  ::box2D::dynamics::contacts::B2PositionSolverManifold_obj::__alloc( HX_CTX );
            	}
}

} // end namespace box2D
} // end namespace dynamics
} // end namespace contacts
