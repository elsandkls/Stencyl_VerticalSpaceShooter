// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_box2D_common_B2Settings
#include <box2D/common/B2Settings.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Mat22
#include <box2D/common/math/B2Mat22.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Mat33
#include <box2D/common/math/B2Mat33.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Math
#include <box2D/common/math/B2Math.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Sweep
#include <box2D/common/math/B2Sweep.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Transform
#include <box2D/common/math/B2Transform.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Vec2
#include <box2D/common/math/B2Vec2.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Vec3
#include <box2D/common/math/B2Vec3.h>
#endif
#ifndef INCLUDED_box2D_dynamics_B2Body
#include <box2D/dynamics/B2Body.h>
#endif
#ifndef INCLUDED_box2D_dynamics_B2TimeStep
#include <box2D/dynamics/B2TimeStep.h>
#endif
#ifndef INCLUDED_box2D_dynamics_joints_B2Joint
#include <box2D/dynamics/joints/B2Joint.h>
#endif
#ifndef INCLUDED_box2D_dynamics_joints_B2JointDef
#include <box2D/dynamics/joints/B2JointDef.h>
#endif
#ifndef INCLUDED_box2D_dynamics_joints_B2WeldJoint
#include <box2D/dynamics/joints/B2WeldJoint.h>
#endif
#ifndef INCLUDED_box2D_dynamics_joints_B2WeldJointDef
#include <box2D/dynamics/joints/B2WeldJointDef.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_dde62c216aaa0d1e_73_new,"box2D.dynamics.joints.B2WeldJoint","new",0xa9dd294a,"box2D.dynamics.joints.B2WeldJoint.new","box2D/dynamics/joints/B2WeldJoint.hx",73,0xcc57e947)
HX_LOCAL_STACK_FRAME(_hx_pos_dde62c216aaa0d1e_51_getAnchorA,"box2D.dynamics.joints.B2WeldJoint","getAnchorA",0x7af16a8c,"box2D.dynamics.joints.B2WeldJoint.getAnchorA","box2D/dynamics/joints/B2WeldJoint.hx",51,0xcc57e947)
HX_LOCAL_STACK_FRAME(_hx_pos_dde62c216aaa0d1e_55_getAnchorB,"box2D.dynamics.joints.B2WeldJoint","getAnchorB",0x7af16a8d,"box2D.dynamics.joints.B2WeldJoint.getAnchorB","box2D/dynamics/joints/B2WeldJoint.hx",55,0xcc57e947)
HX_LOCAL_STACK_FRAME(_hx_pos_dde62c216aaa0d1e_61_getReactionForce,"box2D.dynamics.joints.B2WeldJoint","getReactionForce",0x1d465be2,"box2D.dynamics.joints.B2WeldJoint.getReactionForce","box2D/dynamics/joints/B2WeldJoint.hx",61,0xcc57e947)
HX_LOCAL_STACK_FRAME(_hx_pos_dde62c216aaa0d1e_67_getReactionTorque,"box2D.dynamics.joints.B2WeldJoint","getReactionTorque",0x1953c4f3,"box2D.dynamics.joints.B2WeldJoint.getReactionTorque","box2D/dynamics/joints/B2WeldJoint.hx",67,0xcc57e947)
HX_LOCAL_STACK_FRAME(_hx_pos_dde62c216aaa0d1e_90_initVelocityConstraints,"box2D.dynamics.joints.B2WeldJoint","initVelocityConstraints",0xbae20313,"box2D.dynamics.joints.B2WeldJoint.initVelocityConstraints","box2D/dynamics/joints/B2WeldJoint.hx",90,0xcc57e947)
HX_LOCAL_STACK_FRAME(_hx_pos_dde62c216aaa0d1e_161_solveVelocityConstraints,"box2D.dynamics.joints.B2WeldJoint","solveVelocityConstraints",0x9fa3f8f0,"box2D.dynamics.joints.B2WeldJoint.solveVelocityConstraints","box2D/dynamics/joints/B2WeldJoint.hx",161,0xcc57e947)
HX_LOCAL_STACK_FRAME(_hx_pos_dde62c216aaa0d1e_221_solvePositionConstraints,"box2D.dynamics.joints.B2WeldJoint","solvePositionConstraints",0xd7800de4,"box2D.dynamics.joints.B2WeldJoint.solvePositionConstraints","box2D/dynamics/joints/B2WeldJoint.hx",221,0xcc57e947)
namespace box2D{
namespace dynamics{
namespace joints{

void B2WeldJoint_obj::__construct( ::box2D::dynamics::joints::B2WeldJointDef def){
            	HX_GC_STACKFRAME(&_hx_pos_dde62c216aaa0d1e_73_new)
HXLINE(  74)		super::__construct(def);
HXLINE(  76)		this->m_localAnchorA =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
HXLINE(  77)		this->m_localAnchorB =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
HXLINE(  78)		this->m_impulse =  ::box2D::common::math::B2Vec3_obj::__alloc( HX_CTX ,null(),null(),null());
HXLINE(  79)		this->m_mass =  ::box2D::common::math::B2Mat33_obj::__alloc( HX_CTX ,null(),null(),null());
HXLINE(  82)		{
HXLINE(  82)			 ::box2D::common::math::B2Vec2 _this = this->m_localAnchorA;
HXDLIN(  82)			 ::box2D::common::math::B2Vec2 v = def->localAnchorA;
HXDLIN(  82)			_this->x = v->x;
HXDLIN(  82)			_this->y = v->y;
            		}
HXLINE(  83)		{
HXLINE(  83)			 ::box2D::common::math::B2Vec2 _this1 = this->m_localAnchorB;
HXDLIN(  83)			 ::box2D::common::math::B2Vec2 v1 = def->localAnchorB;
HXDLIN(  83)			_this1->x = v1->x;
HXDLIN(  83)			_this1->y = v1->y;
            		}
HXLINE(  84)		this->m_referenceAngle = def->referenceAngle;
HXLINE(  86)		this->m_impulse->setZero();
HXLINE(  87)		this->m_mass =  ::box2D::common::math::B2Mat33_obj::__alloc( HX_CTX ,null(),null(),null());
            	}

Dynamic B2WeldJoint_obj::__CreateEmpty() { return new B2WeldJoint_obj; }

void *B2WeldJoint_obj::_hx_vtable = 0;

Dynamic B2WeldJoint_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< B2WeldJoint_obj > _hx_result = new B2WeldJoint_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool B2WeldJoint_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x13310c20) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x13310c20;
	} else {
		return inClassId==(int)0x4dcca33a;
	}
}

 ::box2D::common::math::B2Vec2 B2WeldJoint_obj::getAnchorA(){
            	HX_STACKFRAME(&_hx_pos_dde62c216aaa0d1e_51_getAnchorA)
HXDLIN(  51)		return this->m_bodyA->getWorldPoint(this->m_localAnchorA);
            	}


 ::box2D::common::math::B2Vec2 B2WeldJoint_obj::getAnchorB(){
            	HX_STACKFRAME(&_hx_pos_dde62c216aaa0d1e_55_getAnchorB)
HXDLIN(  55)		return this->m_bodyB->getWorldPoint(this->m_localAnchorB);
            	}


 ::box2D::common::math::B2Vec2 B2WeldJoint_obj::getReactionForce(Float inv_dt){
            	HX_GC_STACKFRAME(&_hx_pos_dde62c216aaa0d1e_61_getReactionForce)
HXDLIN(  61)		Float _hx_tmp = (inv_dt * this->m_impulse->x);
HXDLIN(  61)		return  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,_hx_tmp,(inv_dt * this->m_impulse->y));
            	}


Float B2WeldJoint_obj::getReactionTorque(Float inv_dt){
            	HX_STACKFRAME(&_hx_pos_dde62c216aaa0d1e_67_getReactionTorque)
HXDLIN(  67)		return (inv_dt * this->m_impulse->z);
            	}


void B2WeldJoint_obj::initVelocityConstraints( ::box2D::dynamics::B2TimeStep step){
            	HX_STACKFRAME(&_hx_pos_dde62c216aaa0d1e_90_initVelocityConstraints)
HXLINE(  91)		 ::box2D::common::math::B2Mat22 tMat;
HXLINE(  92)		Float tX;
HXLINE(  94)		 ::box2D::dynamics::B2Body bA = this->m_bodyA;
HXLINE(  95)		 ::box2D::dynamics::B2Body bB = this->m_bodyB;
HXLINE(  99)		tMat = bA->m_xf->R;
HXLINE( 100)		Float rAX = (this->m_localAnchorA->x - bA->m_sweep->localCenter->x);
HXLINE( 101)		Float rAY = (this->m_localAnchorA->y - bA->m_sweep->localCenter->y);
HXLINE( 102)		Float tX1 = (tMat->col1->x * rAX);
HXDLIN( 102)		tX = (tX1 + (tMat->col2->x * rAY));
HXLINE( 103)		Float rAY1 = (tMat->col1->y * rAX);
HXDLIN( 103)		rAY = (rAY1 + (tMat->col2->y * rAY));
HXLINE( 104)		rAX = tX;
HXLINE( 106)		tMat = bB->m_xf->R;
HXLINE( 107)		Float rBX = (this->m_localAnchorB->x - bB->m_sweep->localCenter->x);
HXLINE( 108)		Float rBY = (this->m_localAnchorB->y - bB->m_sweep->localCenter->y);
HXLINE( 109)		Float tX2 = (tMat->col1->x * rBX);
HXDLIN( 109)		tX = (tX2 + (tMat->col2->x * rBY));
HXLINE( 110)		Float rBY1 = (tMat->col1->y * rBX);
HXDLIN( 110)		rBY = (rBY1 + (tMat->col2->y * rBY));
HXLINE( 111)		rBX = tX;
HXLINE( 122)		Float mA = bA->m_invMass;
HXLINE( 123)		Float mB = bB->m_invMass;
HXLINE( 124)		Float iA = bA->m_invI;
HXLINE( 125)		Float iB = bB->m_invI;
HXLINE( 127)		this->m_mass->col1->x = (((mA + mB) + ((rAY * rAY) * iA)) + ((rBY * rBY) * iB));
HXLINE( 128)		this->m_mass->col2->x = (((-(rAY) * rAX) * iA) - ((rBY * rBX) * iB));
HXLINE( 129)		this->m_mass->col3->x = ((-(rAY) * iA) - (rBY * iB));
HXLINE( 130)		this->m_mass->col1->y = this->m_mass->col2->x;
HXLINE( 131)		this->m_mass->col2->y = (((mA + mB) + ((rAX * rAX) * iA)) + ((rBX * rBX) * iB));
HXLINE( 132)		this->m_mass->col3->y = ((rAX * iA) + (rBX * iB));
HXLINE( 133)		this->m_mass->col1->z = this->m_mass->col3->x;
HXLINE( 134)		this->m_mass->col2->z = this->m_mass->col3->y;
HXLINE( 135)		this->m_mass->col3->z = (iA + iB);
HXLINE( 137)		if (step->warmStarting) {
HXLINE( 140)			 ::box2D::common::math::B2Vec3 _hx_tmp = this->m_impulse;
HXDLIN( 140)			_hx_tmp->x = (_hx_tmp->x * step->dtRatio);
HXLINE( 141)			 ::box2D::common::math::B2Vec3 _hx_tmp1 = this->m_impulse;
HXDLIN( 141)			_hx_tmp1->y = (_hx_tmp1->y * step->dtRatio);
HXLINE( 142)			 ::box2D::common::math::B2Vec3 _hx_tmp2 = this->m_impulse;
HXDLIN( 142)			_hx_tmp2->z = (_hx_tmp2->z * step->dtRatio);
HXLINE( 144)			 ::box2D::common::math::B2Vec2 bA1 = bA->m_linearVelocity;
HXDLIN( 144)			bA1->x = (bA1->x - (mA * this->m_impulse->x));
HXLINE( 145)			 ::box2D::common::math::B2Vec2 bA2 = bA->m_linearVelocity;
HXDLIN( 145)			bA2->y = (bA2->y - (mA * this->m_impulse->y));
HXLINE( 146)			 ::box2D::dynamics::B2Body bA3 = bA;
HXDLIN( 146)			Float _hx_tmp3 = (rAX * this->m_impulse->y);
HXDLIN( 146)			bA3->m_angularVelocity = (bA3->m_angularVelocity - (iA * ((_hx_tmp3 - (rAY * this->m_impulse->x)) + this->m_impulse->z)));
HXLINE( 148)			 ::box2D::common::math::B2Vec2 bB1 = bB->m_linearVelocity;
HXDLIN( 148)			bB1->x = (bB1->x + (mB * this->m_impulse->x));
HXLINE( 149)			 ::box2D::common::math::B2Vec2 bB2 = bB->m_linearVelocity;
HXDLIN( 149)			bB2->y = (bB2->y + (mB * this->m_impulse->y));
HXLINE( 150)			 ::box2D::dynamics::B2Body bB3 = bB;
HXDLIN( 150)			Float _hx_tmp4 = (rBX * this->m_impulse->y);
HXDLIN( 150)			bB3->m_angularVelocity = (bB3->m_angularVelocity + (iB * ((_hx_tmp4 - (rBY * this->m_impulse->x)) + this->m_impulse->z)));
            		}
            		else {
HXLINE( 154)			this->m_impulse->setZero();
            		}
            	}


void B2WeldJoint_obj::solveVelocityConstraints( ::box2D::dynamics::B2TimeStep step){
            	HX_GC_STACKFRAME(&_hx_pos_dde62c216aaa0d1e_161_solveVelocityConstraints)
HXLINE( 163)		 ::box2D::common::math::B2Mat22 tMat;
HXLINE( 164)		Float tX;
HXLINE( 166)		 ::box2D::dynamics::B2Body bA = this->m_bodyA;
HXLINE( 167)		 ::box2D::dynamics::B2Body bB = this->m_bodyB;
HXLINE( 169)		 ::box2D::common::math::B2Vec2 vA = bA->m_linearVelocity;
HXLINE( 170)		Float wA = bA->m_angularVelocity;
HXLINE( 171)		 ::box2D::common::math::B2Vec2 vB = bB->m_linearVelocity;
HXLINE( 172)		Float wB = bB->m_angularVelocity;
HXLINE( 174)		Float mA = bA->m_invMass;
HXLINE( 175)		Float mB = bB->m_invMass;
HXLINE( 176)		Float iA = bA->m_invI;
HXLINE( 177)		Float iB = bB->m_invI;
HXLINE( 180)		tMat = bA->m_xf->R;
HXLINE( 181)		Float rAX = (this->m_localAnchorA->x - bA->m_sweep->localCenter->x);
HXLINE( 182)		Float rAY = (this->m_localAnchorA->y - bA->m_sweep->localCenter->y);
HXLINE( 183)		Float tX1 = (tMat->col1->x * rAX);
HXDLIN( 183)		tX = (tX1 + (tMat->col2->x * rAY));
HXLINE( 184)		Float rAY1 = (tMat->col1->y * rAX);
HXDLIN( 184)		rAY = (rAY1 + (tMat->col2->y * rAY));
HXLINE( 185)		rAX = tX;
HXLINE( 187)		tMat = bB->m_xf->R;
HXLINE( 188)		Float rBX = (this->m_localAnchorB->x - bB->m_sweep->localCenter->x);
HXLINE( 189)		Float rBY = (this->m_localAnchorB->y - bB->m_sweep->localCenter->y);
HXLINE( 190)		Float tX2 = (tMat->col1->x * rBX);
HXDLIN( 190)		tX = (tX2 + (tMat->col2->x * rBY));
HXLINE( 191)		Float rBY1 = (tMat->col1->y * rBX);
HXDLIN( 191)		rBY = (rBY1 + (tMat->col2->y * rBY));
HXLINE( 192)		rBX = tX;
HXLINE( 196)		Float vB1 = vB->x;
HXDLIN( 196)		Float Cdot1X = ((vB1 - (wB * rBY)) - vA->x);
HXDLIN( 196)		Float Cdot1X1 = (Cdot1X + (wA * rAY));
HXLINE( 197)		Float vB2 = vB->y;
HXDLIN( 197)		Float Cdot1Y = ((vB2 + (wB * rBX)) - vA->y);
HXDLIN( 197)		Float Cdot1Y1 = (Cdot1Y - (wA * rAX));
HXLINE( 198)		Float Cdot2 = (wB - wA);
HXLINE( 199)		 ::box2D::common::math::B2Vec3 impulse =  ::box2D::common::math::B2Vec3_obj::__alloc( HX_CTX ,null(),null(),null());
HXLINE( 200)		this->m_mass->solve33(impulse,-(Cdot1X1),-(Cdot1Y1),-(Cdot2));
HXLINE( 202)		this->m_impulse->add(impulse);
HXLINE( 204)		 ::box2D::common::math::B2Vec2 vA1 = vA;
HXDLIN( 204)		vA1->x = (vA1->x - (mA * impulse->x));
HXLINE( 205)		 ::box2D::common::math::B2Vec2 vA2 = vA;
HXDLIN( 205)		vA2->y = (vA2->y - (mA * impulse->y));
HXLINE( 206)		Float wA1 = (rAX * impulse->y);
HXDLIN( 206)		wA = (wA - (iA * ((wA1 - (rAY * impulse->x)) + impulse->z)));
HXLINE( 208)		 ::box2D::common::math::B2Vec2 vB3 = vB;
HXDLIN( 208)		vB3->x = (vB3->x + (mB * impulse->x));
HXLINE( 209)		 ::box2D::common::math::B2Vec2 vB4 = vB;
HXDLIN( 209)		vB4->y = (vB4->y + (mB * impulse->y));
HXLINE( 210)		Float wB1 = (rBX * impulse->y);
HXDLIN( 210)		wB = (wB + (iB * ((wB1 - (rBY * impulse->x)) + impulse->z)));
HXLINE( 214)		bA->m_angularVelocity = wA;
HXLINE( 216)		bB->m_angularVelocity = wB;
            	}


bool B2WeldJoint_obj::solvePositionConstraints(Float baumgarte){
            	HX_GC_STACKFRAME(&_hx_pos_dde62c216aaa0d1e_221_solvePositionConstraints)
HXLINE( 223)		 ::box2D::common::math::B2Mat22 tMat;
HXLINE( 224)		Float tX;
HXLINE( 226)		 ::box2D::dynamics::B2Body bA = this->m_bodyA;
HXLINE( 227)		 ::box2D::dynamics::B2Body bB = this->m_bodyB;
HXLINE( 231)		tMat = bA->m_xf->R;
HXLINE( 232)		Float rAX = (this->m_localAnchorA->x - bA->m_sweep->localCenter->x);
HXLINE( 233)		Float rAY = (this->m_localAnchorA->y - bA->m_sweep->localCenter->y);
HXLINE( 234)		Float tX1 = (tMat->col1->x * rAX);
HXDLIN( 234)		tX = (tX1 + (tMat->col2->x * rAY));
HXLINE( 235)		Float rAY1 = (tMat->col1->y * rAX);
HXDLIN( 235)		rAY = (rAY1 + (tMat->col2->y * rAY));
HXLINE( 236)		rAX = tX;
HXLINE( 238)		tMat = bB->m_xf->R;
HXLINE( 239)		Float rBX = (this->m_localAnchorB->x - bB->m_sweep->localCenter->x);
HXLINE( 240)		Float rBY = (this->m_localAnchorB->y - bB->m_sweep->localCenter->y);
HXLINE( 241)		Float tX2 = (tMat->col1->x * rBX);
HXDLIN( 241)		tX = (tX2 + (tMat->col2->x * rBY));
HXLINE( 242)		Float rBY1 = (tMat->col1->y * rBX);
HXDLIN( 242)		rBY = (rBY1 + (tMat->col2->y * rBY));
HXLINE( 243)		rBX = tX;
HXLINE( 254)		Float mA = bA->m_invMass;
HXLINE( 255)		Float mB = bB->m_invMass;
HXLINE( 256)		Float iA = bA->m_invI;
HXLINE( 257)		Float iB = bB->m_invI;
HXLINE( 260)		Float C1X = (((bB->m_sweep->c->x + rBX) - bA->m_sweep->c->x) - rAX);
HXLINE( 261)		Float C1Y = (((bB->m_sweep->c->y + rBY) - bA->m_sweep->c->y) - rAY);
HXLINE( 262)		Float C2 = ((bB->m_sweep->a - bA->m_sweep->a) - this->m_referenceAngle);
HXLINE( 265)		Float k_allowedStretch = (((Float)10.0) * ::box2D::common::B2Settings_obj::b2_linearSlop);
HXLINE( 266)		Float positionError = ::Math_obj::sqrt(((C1X * C1X) + (C1Y * C1Y)));
HXLINE( 267)		Float angularError = ::box2D::common::math::B2Math_obj::abs(C2);
HXLINE( 268)		if ((positionError > k_allowedStretch)) {
HXLINE( 270)			iA = iA;
HXLINE( 271)			iB = iB;
            		}
HXLINE( 274)		this->m_mass->col1->x = (((mA + mB) + ((rAY * rAY) * iA)) + ((rBY * rBY) * iB));
HXLINE( 275)		this->m_mass->col2->x = (((-(rAY) * rAX) * iA) - ((rBY * rBX) * iB));
HXLINE( 276)		this->m_mass->col3->x = ((-(rAY) * iA) - (rBY * iB));
HXLINE( 277)		this->m_mass->col1->y = this->m_mass->col2->x;
HXLINE( 278)		this->m_mass->col2->y = (((mA + mB) + ((rAX * rAX) * iA)) + ((rBX * rBX) * iB));
HXLINE( 279)		this->m_mass->col3->y = ((rAX * iA) + (rBX * iB));
HXLINE( 280)		this->m_mass->col1->z = this->m_mass->col3->x;
HXLINE( 281)		this->m_mass->col2->z = this->m_mass->col3->y;
HXLINE( 282)		this->m_mass->col3->z = (iA + iB);
HXLINE( 284)		 ::box2D::common::math::B2Vec3 impulse =  ::box2D::common::math::B2Vec3_obj::__alloc( HX_CTX ,null(),null(),null());
HXLINE( 285)		this->m_mass->solve33(impulse,-(C1X),-(C1Y),-(C2));
HXLINE( 288)		 ::box2D::common::math::B2Vec2 bA1 = bA->m_sweep->c;
HXDLIN( 288)		bA1->x = (bA1->x - (mA * impulse->x));
HXLINE( 289)		 ::box2D::common::math::B2Vec2 bA2 = bA->m_sweep->c;
HXDLIN( 289)		bA2->y = (bA2->y - (mA * impulse->y));
HXLINE( 290)		 ::box2D::common::math::B2Sweep bA3 = bA->m_sweep;
HXDLIN( 290)		Float _hx_tmp = (rAX * impulse->y);
HXDLIN( 290)		bA3->a = (bA3->a - (iA * ((_hx_tmp - (rAY * impulse->x)) + impulse->z)));
HXLINE( 292)		 ::box2D::common::math::B2Vec2 bB1 = bB->m_sweep->c;
HXDLIN( 292)		bB1->x = (bB1->x + (mB * impulse->x));
HXLINE( 293)		 ::box2D::common::math::B2Vec2 bB2 = bB->m_sweep->c;
HXDLIN( 293)		bB2->y = (bB2->y + (mB * impulse->y));
HXLINE( 294)		 ::box2D::common::math::B2Sweep bB3 = bB->m_sweep;
HXDLIN( 294)		Float _hx_tmp1 = (rBX * impulse->y);
HXDLIN( 294)		bB3->a = (bB3->a + (iB * ((_hx_tmp1 - (rBY * impulse->x)) + impulse->z)));
HXLINE( 296)		bA->synchronizeTransform();
HXLINE( 297)		bB->synchronizeTransform();
HXLINE( 299)		if ((positionError <= ::box2D::common::B2Settings_obj::b2_linearSlop)) {
HXLINE( 299)			return (angularError <= ::box2D::common::B2Settings_obj::b2_angularSlop);
            		}
            		else {
HXLINE( 299)			return false;
            		}
HXDLIN( 299)		return false;
            	}



hx::ObjectPtr< B2WeldJoint_obj > B2WeldJoint_obj::__new( ::box2D::dynamics::joints::B2WeldJointDef def) {
	hx::ObjectPtr< B2WeldJoint_obj > __this = new B2WeldJoint_obj();
	__this->__construct(def);
	return __this;
}

hx::ObjectPtr< B2WeldJoint_obj > B2WeldJoint_obj::__alloc(hx::Ctx *_hx_ctx, ::box2D::dynamics::joints::B2WeldJointDef def) {
	B2WeldJoint_obj *__this = (B2WeldJoint_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(B2WeldJoint_obj), true, "box2D.dynamics.joints.B2WeldJoint"));
	*(void **)__this = B2WeldJoint_obj::_hx_vtable;
	__this->__construct(def);
	return __this;
}

B2WeldJoint_obj::B2WeldJoint_obj()
{
}

void B2WeldJoint_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(B2WeldJoint);
	HX_MARK_MEMBER_NAME(m_localAnchorA,"m_localAnchorA");
	HX_MARK_MEMBER_NAME(m_localAnchorB,"m_localAnchorB");
	HX_MARK_MEMBER_NAME(m_referenceAngle,"m_referenceAngle");
	HX_MARK_MEMBER_NAME(m_impulse,"m_impulse");
	HX_MARK_MEMBER_NAME(m_mass,"m_mass");
	 ::box2D::dynamics::joints::B2Joint_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void B2WeldJoint_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(m_localAnchorA,"m_localAnchorA");
	HX_VISIT_MEMBER_NAME(m_localAnchorB,"m_localAnchorB");
	HX_VISIT_MEMBER_NAME(m_referenceAngle,"m_referenceAngle");
	HX_VISIT_MEMBER_NAME(m_impulse,"m_impulse");
	HX_VISIT_MEMBER_NAME(m_mass,"m_mass");
	 ::box2D::dynamics::joints::B2Joint_obj::__Visit(HX_VISIT_ARG);
}

hx::Val B2WeldJoint_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"m_mass") ) { return hx::Val( m_mass ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"m_impulse") ) { return hx::Val( m_impulse ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"getAnchorA") ) { return hx::Val( getAnchorA_dyn() ); }
		if (HX_FIELD_EQ(inName,"getAnchorB") ) { return hx::Val( getAnchorB_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"m_localAnchorA") ) { return hx::Val( m_localAnchorA ); }
		if (HX_FIELD_EQ(inName,"m_localAnchorB") ) { return hx::Val( m_localAnchorB ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"getReactionForce") ) { return hx::Val( getReactionForce_dyn() ); }
		if (HX_FIELD_EQ(inName,"m_referenceAngle") ) { return hx::Val( m_referenceAngle ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"getReactionTorque") ) { return hx::Val( getReactionTorque_dyn() ); }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"initVelocityConstraints") ) { return hx::Val( initVelocityConstraints_dyn() ); }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"solveVelocityConstraints") ) { return hx::Val( solveVelocityConstraints_dyn() ); }
		if (HX_FIELD_EQ(inName,"solvePositionConstraints") ) { return hx::Val( solvePositionConstraints_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val B2WeldJoint_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"m_mass") ) { m_mass=inValue.Cast<  ::box2D::common::math::B2Mat33 >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"m_impulse") ) { m_impulse=inValue.Cast<  ::box2D::common::math::B2Vec3 >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"m_localAnchorA") ) { m_localAnchorA=inValue.Cast<  ::box2D::common::math::B2Vec2 >(); return inValue; }
		if (HX_FIELD_EQ(inName,"m_localAnchorB") ) { m_localAnchorB=inValue.Cast<  ::box2D::common::math::B2Vec2 >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"m_referenceAngle") ) { m_referenceAngle=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void B2WeldJoint_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("m_localAnchorA","\x53","\x30","\xee","\x9e"));
	outFields->push(HX_HCSTRING("m_localAnchorB","\x54","\x30","\xee","\x9e"));
	outFields->push(HX_HCSTRING("m_referenceAngle","\xda","\x56","\x05","\xf4"));
	outFields->push(HX_HCSTRING("m_impulse","\xa3","\x5f","\x3f","\x78"));
	outFields->push(HX_HCSTRING("m_mass","\x46","\xb1","\x4d","\x90"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo B2WeldJoint_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::box2D::common::math::B2Vec2*/ ,(int)offsetof(B2WeldJoint_obj,m_localAnchorA),HX_HCSTRING("m_localAnchorA","\x53","\x30","\xee","\x9e")},
	{hx::fsObject /*::box2D::common::math::B2Vec2*/ ,(int)offsetof(B2WeldJoint_obj,m_localAnchorB),HX_HCSTRING("m_localAnchorB","\x54","\x30","\xee","\x9e")},
	{hx::fsFloat,(int)offsetof(B2WeldJoint_obj,m_referenceAngle),HX_HCSTRING("m_referenceAngle","\xda","\x56","\x05","\xf4")},
	{hx::fsObject /*::box2D::common::math::B2Vec3*/ ,(int)offsetof(B2WeldJoint_obj,m_impulse),HX_HCSTRING("m_impulse","\xa3","\x5f","\x3f","\x78")},
	{hx::fsObject /*::box2D::common::math::B2Mat33*/ ,(int)offsetof(B2WeldJoint_obj,m_mass),HX_HCSTRING("m_mass","\x46","\xb1","\x4d","\x90")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *B2WeldJoint_obj_sStaticStorageInfo = 0;
#endif

static ::String B2WeldJoint_obj_sMemberFields[] = {
	HX_HCSTRING("getAnchorA","\x36","\x72","\x03","\x52"),
	HX_HCSTRING("getAnchorB","\x37","\x72","\x03","\x52"),
	HX_HCSTRING("getReactionForce","\x0c","\x7f","\x58","\x41"),
	HX_HCSTRING("getReactionTorque","\x89","\x66","\x20","\x85"),
	HX_HCSTRING("initVelocityConstraints","\x29","\xf9","\xf0","\x64"),
	HX_HCSTRING("solveVelocityConstraints","\x1a","\x56","\xac","\xc2"),
	HX_HCSTRING("solvePositionConstraints","\x0e","\x6b","\x88","\xfa"),
	HX_HCSTRING("m_localAnchorA","\x53","\x30","\xee","\x9e"),
	HX_HCSTRING("m_localAnchorB","\x54","\x30","\xee","\x9e"),
	HX_HCSTRING("m_referenceAngle","\xda","\x56","\x05","\xf4"),
	HX_HCSTRING("m_impulse","\xa3","\x5f","\x3f","\x78"),
	HX_HCSTRING("m_mass","\x46","\xb1","\x4d","\x90"),
	::String(null()) };

static void B2WeldJoint_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(B2WeldJoint_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void B2WeldJoint_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(B2WeldJoint_obj::__mClass,"__mClass");
};

#endif

hx::Class B2WeldJoint_obj::__mClass;

void B2WeldJoint_obj::__register()
{
	hx::Object *dummy = new B2WeldJoint_obj;
	B2WeldJoint_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("box2D.dynamics.joints.B2WeldJoint","\x58","\x7c","\xf0","\x77");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = B2WeldJoint_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(B2WeldJoint_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< B2WeldJoint_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = B2WeldJoint_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = B2WeldJoint_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = B2WeldJoint_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace box2D
} // end namespace dynamics
} // end namespace joints
