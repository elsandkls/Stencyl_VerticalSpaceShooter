// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_box2D_collision_B2AABB
#include <box2D/collision/B2AABB.h>
#endif
#ifndef INCLUDED_box2D_collision_B2OBB
#include <box2D/collision/B2OBB.h>
#endif
#ifndef INCLUDED_box2D_collision_B2RayCastInput
#include <box2D/collision/B2RayCastInput.h>
#endif
#ifndef INCLUDED_box2D_collision_B2RayCastOutput
#include <box2D/collision/B2RayCastOutput.h>
#endif
#ifndef INCLUDED_box2D_collision_shapes_B2MassData
#include <box2D/collision/shapes/B2MassData.h>
#endif
#ifndef INCLUDED_box2D_collision_shapes_B2PolygonShape
#include <box2D/collision/shapes/B2PolygonShape.h>
#endif
#ifndef INCLUDED_box2D_collision_shapes_B2Shape
#include <box2D/collision/shapes/B2Shape.h>
#endif
#ifndef INCLUDED_box2D_common_B2Settings
#include <box2D/common/B2Settings.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Mat22
#include <box2D/common/math/B2Mat22.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Math
#include <box2D/common/math/B2Math.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Transform
#include <box2D/common/math/B2Transform.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Vec2
#include <box2D/common/math/B2Vec2.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_102b8b1a357996ba_723_new,"box2D.collision.shapes.B2PolygonShape","new",0x68088bf8,"box2D.collision.shapes.B2PolygonShape.new","box2D/collision/shapes/B2PolygonShape.hx",723,0xcb7baa99)
HX_LOCAL_STACK_FRAME(_hx_pos_102b8b1a357996ba_42_copy,"box2D.collision.shapes.B2PolygonShape","copy",0x9834251d,"box2D.collision.shapes.B2PolygonShape.copy","box2D/collision/shapes/B2PolygonShape.hx",42,0xcb7baa99)
HX_LOCAL_STACK_FRAME(_hx_pos_102b8b1a357996ba_49_set,"box2D.collision.shapes.B2PolygonShape","set",0x680c573a,"box2D.collision.shapes.B2PolygonShape.set","box2D/collision/shapes/B2PolygonShape.hx",49,0xcb7baa99)
HX_LOCAL_STACK_FRAME(_hx_pos_102b8b1a357996ba_70_setAsArray,"box2D.collision.shapes.B2PolygonShape","setAsArray",0x4e64e72d,"box2D.collision.shapes.B2PolygonShape.setAsArray","box2D/collision/shapes/B2PolygonShape.hx",70,0xcb7baa99)
HX_LOCAL_STACK_FRAME(_hx_pos_102b8b1a357996ba_91_setAsVector,"box2D.collision.shapes.B2PolygonShape","setAsVector",0x295298af,"box2D.collision.shapes.B2PolygonShape.setAsVector","box2D/collision/shapes/B2PolygonShape.hx",91,0xcb7baa99)
HX_LOCAL_STACK_FRAME(_hx_pos_102b8b1a357996ba_136_setAsBox,"box2D.collision.shapes.B2PolygonShape","setAsBox",0xe2ccea9f,"box2D.collision.shapes.B2PolygonShape.setAsBox","box2D/collision/shapes/B2PolygonShape.hx",136,0xcb7baa99)
HX_LOCAL_STACK_FRAME(_hx_pos_102b8b1a357996ba_166_setAsOrientedBox,"box2D.collision.shapes.B2PolygonShape","setAsOrientedBox",0xe7071f9b,"box2D.collision.shapes.B2PolygonShape.setAsOrientedBox","box2D/collision/shapes/B2PolygonShape.hx",166,0xcb7baa99)
HX_LOCAL_STACK_FRAME(_hx_pos_102b8b1a357996ba_202_setAsEdge,"box2D.collision.shapes.B2PolygonShape","setAsEdge",0x92739d29,"box2D.collision.shapes.B2PolygonShape.setAsEdge","box2D/collision/shapes/B2PolygonShape.hx",202,0xcb7baa99)
HX_LOCAL_STACK_FRAME(_hx_pos_102b8b1a357996ba_229_testPoint,"box2D.collision.shapes.B2PolygonShape","testPoint",0x94c37036,"box2D.collision.shapes.B2PolygonShape.testPoint","box2D/collision/shapes/B2PolygonShape.hx",229,0xcb7baa99)
HX_LOCAL_STACK_FRAME(_hx_pos_102b8b1a357996ba_260_rayCast,"box2D.collision.shapes.B2PolygonShape","rayCast",0xea52c561,"box2D.collision.shapes.B2PolygonShape.rayCast","box2D/collision/shapes/B2PolygonShape.hx",260,0xcb7baa99)
HX_LOCAL_STACK_FRAME(_hx_pos_102b8b1a357996ba_357_computeAABB,"box2D.collision.shapes.B2PolygonShape","computeAABB",0x953d4d2f,"box2D.collision.shapes.B2PolygonShape.computeAABB","box2D/collision/shapes/B2PolygonShape.hx",357,0xcb7baa99)
HX_LOCAL_STACK_FRAME(_hx_pos_102b8b1a357996ba_387_computeMass,"box2D.collision.shapes.B2PolygonShape","computeMass",0x9d444fa3,"box2D.collision.shapes.B2PolygonShape.computeMass","box2D/collision/shapes/B2PolygonShape.hx",387,0xcb7baa99)
HX_LOCAL_STACK_FRAME(_hx_pos_102b8b1a357996ba_516_computeSubmergedArea,"box2D.collision.shapes.B2PolygonShape","computeSubmergedArea",0x47dae94a,"box2D.collision.shapes.B2PolygonShape.computeSubmergedArea","box2D/collision/shapes/B2PolygonShape.hx",516,0xcb7baa99)
HX_LOCAL_STACK_FRAME(_hx_pos_102b8b1a357996ba_627_getVertexCount,"box2D.collision.shapes.B2PolygonShape","getVertexCount",0xd1c59d3d,"box2D.collision.shapes.B2PolygonShape.getVertexCount","box2D/collision/shapes/B2PolygonShape.hx",627,0xcb7baa99)
HX_LOCAL_STACK_FRAME(_hx_pos_102b8b1a357996ba_634_getVertices,"box2D.collision.shapes.B2PolygonShape","getVertices",0x62c79647,"box2D.collision.shapes.B2PolygonShape.getVertices","box2D/collision/shapes/B2PolygonShape.hx",634,0xcb7baa99)
HX_LOCAL_STACK_FRAME(_hx_pos_102b8b1a357996ba_642_getNormals,"box2D.collision.shapes.B2PolygonShape","getNormals",0x01585dde,"box2D.collision.shapes.B2PolygonShape.getNormals","box2D/collision/shapes/B2PolygonShape.hx",642,0xcb7baa99)
HX_LOCAL_STACK_FRAME(_hx_pos_102b8b1a357996ba_649_getSupport,"box2D.collision.shapes.B2PolygonShape","getSupport",0x12a0f981,"box2D.collision.shapes.B2PolygonShape.getSupport","box2D/collision/shapes/B2PolygonShape.hx",649,0xcb7baa99)
HX_LOCAL_STACK_FRAME(_hx_pos_102b8b1a357996ba_665_getSupportVertex,"box2D.collision.shapes.B2PolygonShape","getSupportVertex",0xf54edfc5,"box2D.collision.shapes.B2PolygonShape.getSupportVertex","box2D/collision/shapes/B2PolygonShape.hx",665,0xcb7baa99)
HX_LOCAL_STACK_FRAME(_hx_pos_102b8b1a357996ba_716_validate,"box2D.collision.shapes.B2PolygonShape","validate",0xb3680dfe,"box2D.collision.shapes.B2PolygonShape.validate","box2D/collision/shapes/B2PolygonShape.hx",716,0xcb7baa99)
HX_LOCAL_STACK_FRAME(_hx_pos_102b8b1a357996ba_737_reserve,"box2D.collision.shapes.B2PolygonShape","reserve",0x25dee5d4,"box2D.collision.shapes.B2PolygonShape.reserve","box2D/collision/shapes/B2PolygonShape.hx",737,0xcb7baa99)
HX_LOCAL_STACK_FRAME(_hx_pos_102b8b1a357996ba_80_asArray,"box2D.collision.shapes.B2PolygonShape","asArray",0x3a7fc2df,"box2D.collision.shapes.B2PolygonShape.asArray","box2D/collision/shapes/B2PolygonShape.hx",80,0xcb7baa99)
HX_LOCAL_STACK_FRAME(_hx_pos_102b8b1a357996ba_124_asVector,"box2D.collision.shapes.B2PolygonShape","asVector",0xd4b7f8bd,"box2D.collision.shapes.B2PolygonShape.asVector","box2D/collision/shapes/B2PolygonShape.hx",124,0xcb7baa99)
HX_LOCAL_STACK_FRAME(_hx_pos_102b8b1a357996ba_151_asBox,"box2D.collision.shapes.B2PolygonShape","asBox",0x712115d1,"box2D.collision.shapes.B2PolygonShape.asBox","box2D/collision/shapes/B2PolygonShape.hx",151,0xcb7baa99)
HX_LOCAL_STACK_FRAME(_hx_pos_102b8b1a357996ba_192_asOrientedBox,"box2D.collision.shapes.B2PolygonShape","asOrientedBox",0xa924cccd,"box2D.collision.shapes.B2PolygonShape.asOrientedBox","box2D/collision/shapes/B2PolygonShape.hx",192,0xcb7baa99)
HX_LOCAL_STACK_FRAME(_hx_pos_102b8b1a357996ba_219_asEdge,"box2D.collision.shapes.B2PolygonShape","asEdge",0x8dc53db7,"box2D.collision.shapes.B2PolygonShape.asEdge","box2D/collision/shapes/B2PolygonShape.hx",219,0xcb7baa99)
HX_LOCAL_STACK_FRAME(_hx_pos_102b8b1a357996ba_761_computeCentroid,"box2D.collision.shapes.B2PolygonShape","computeCentroid",0x5b12726f,"box2D.collision.shapes.B2PolygonShape.computeCentroid","box2D/collision/shapes/B2PolygonShape.hx",761,0xcb7baa99)
HX_LOCAL_STACK_FRAME(_hx_pos_102b8b1a357996ba_819_computeOBB,"box2D.collision.shapes.B2PolygonShape","computeOBB",0xbaaf1020,"box2D.collision.shapes.B2PolygonShape.computeOBB","box2D/collision/shapes/B2PolygonShape.hx",819,0xcb7baa99)
HX_LOCAL_STACK_FRAME(_hx_pos_102b8b1a357996ba_164_boot,"box2D.collision.shapes.B2PolygonShape","boot",0x978aed9a,"box2D.collision.shapes.B2PolygonShape.boot","box2D/collision/shapes/B2PolygonShape.hx",164,0xcb7baa99)
namespace box2D{
namespace collision{
namespace shapes{

void B2PolygonShape_obj::__construct(){
            	HX_GC_STACKFRAME(&_hx_pos_102b8b1a357996ba_723_new)
HXLINE( 725)		super::__construct();
HXLINE( 728)		this->m_type = (int)1;
HXLINE( 730)		this->m_centroid =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 731)		this->m_vertices = ::Array_obj< ::Dynamic>::__new();
HXLINE( 732)		this->m_normals = ::Array_obj< ::Dynamic>::__new();
            	}

Dynamic B2PolygonShape_obj::__CreateEmpty() { return new B2PolygonShape_obj; }

void *B2PolygonShape_obj::_hx_vtable = 0;

Dynamic B2PolygonShape_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< B2PolygonShape_obj > _hx_result = new B2PolygonShape_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool B2PolygonShape_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x19eeb38a) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x19eeb38a;
	} else {
		return inClassId==(int)0x2e1514fe;
	}
}

 ::box2D::collision::shapes::B2Shape B2PolygonShape_obj::copy(){
            	HX_GC_STACKFRAME(&_hx_pos_102b8b1a357996ba_42_copy)
HXLINE(  43)		 ::box2D::collision::shapes::B2PolygonShape s =  ::box2D::collision::shapes::B2PolygonShape_obj::__alloc( HX_CTX );
HXLINE(  44)		s->set(hx::ObjectPtr<OBJ_>(this));
HXLINE(  45)		return s;
            	}


void B2PolygonShape_obj::set( ::box2D::collision::shapes::B2Shape other){
            	HX_STACKFRAME(&_hx_pos_102b8b1a357996ba_49_set)
HXLINE(  50)		this->super::set(other);
HXLINE(  51)		if (::Std_obj::is(other,hx::ClassOf< ::box2D::collision::shapes::B2PolygonShape >())) {
HXLINE(  53)			 ::box2D::collision::shapes::B2PolygonShape other2 = hx::TCast<  ::box2D::collision::shapes::B2PolygonShape >::cast(other);
HXLINE(  54)			{
HXLINE(  54)				 ::box2D::common::math::B2Vec2 _this = this->m_centroid;
HXDLIN(  54)				 ::box2D::common::math::B2Vec2 v = other2->m_centroid;
HXDLIN(  54)				_this->x = v->x;
HXDLIN(  54)				_this->y = v->y;
            			}
HXLINE(  55)			this->m_vertexCount = other2->m_vertexCount;
HXLINE(  56)			this->reserve(this->m_vertexCount);
HXLINE(  57)			{
HXLINE(  57)				int _g1 = (int)0;
HXDLIN(  57)				int _g = this->m_vertexCount;
HXDLIN(  57)				while((_g1 < _g)){
HXLINE(  57)					_g1 = (_g1 + (int)1);
HXDLIN(  57)					int i = (_g1 - (int)1);
HXLINE(  59)					{
HXLINE(  59)						 ::box2D::common::math::B2Vec2 _this1 = this->m_vertices->__get(i).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXDLIN(  59)						 ::box2D::common::math::B2Vec2 v1 = other2->m_vertices->__get(i).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXDLIN(  59)						_this1->x = v1->x;
HXDLIN(  59)						_this1->y = v1->y;
            					}
HXLINE(  60)					{
HXLINE(  60)						 ::box2D::common::math::B2Vec2 _this2 = this->m_normals->__get(i).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXDLIN(  60)						 ::box2D::common::math::B2Vec2 v2 = other2->m_normals->__get(i).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXDLIN(  60)						_this2->x = v2->x;
HXDLIN(  60)						_this2->y = v2->y;
            					}
            				}
            			}
            		}
            	}


void B2PolygonShape_obj::setAsArray(::cpp::VirtualArray vertices,hx::Null< int >  __o_vertexCount){
int vertexCount = __o_vertexCount.Default(0);
            	HX_STACKFRAME(&_hx_pos_102b8b1a357996ba_70_setAsArray)
HXLINE(  71)		::Array< ::Dynamic> v = ::Array_obj< ::Dynamic>::__new();
HXLINE(  72)		{
HXLINE(  72)			int _g = (int)0;
HXDLIN(  72)			while((_g < vertices->get_length())){
HXLINE(  72)				 ::Dynamic tVec = vertices->__get(_g);
HXDLIN(  72)				_g = (_g + (int)1);
HXLINE(  74)				v->push(tVec);
            			}
            		}
HXLINE(  76)		this->setAsVector(v,vertexCount);
            	}


HX_DEFINE_DYNAMIC_FUNC2(B2PolygonShape_obj,setAsArray,(void))

void B2PolygonShape_obj::setAsVector(::Array< ::Dynamic> vertices,hx::Null< int >  __o_vertexCount){
int vertexCount = __o_vertexCount.Default(0);
            	HX_STACKFRAME(&_hx_pos_102b8b1a357996ba_91_setAsVector)
HXLINE(  92)		if ((vertexCount == (int)0)) {
HXLINE(  93)			vertexCount = vertices->length;
            		}
HXLINE(  95)		::box2D::common::B2Settings_obj::b2Assert(((int)2 <= vertexCount));
HXLINE(  96)		this->m_vertexCount = vertexCount;
HXLINE(  98)		this->reserve(vertexCount);
HXLINE( 100)		int i;
HXLINE( 103)		{
HXLINE( 103)			int _g1 = (int)0;
HXDLIN( 103)			int _g = this->m_vertexCount;
HXDLIN( 103)			while((_g1 < _g)){
HXLINE( 103)				_g1 = (_g1 + (int)1);
HXDLIN( 103)				int i1 = (_g1 - (int)1);
HXLINE( 105)				{
HXLINE( 105)					 ::box2D::common::math::B2Vec2 _this = this->m_vertices->__get(i1).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXDLIN( 105)					 ::box2D::common::math::B2Vec2 v = vertices->__get(i1).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXDLIN( 105)					_this->x = v->x;
HXDLIN( 105)					_this->y = v->y;
            				}
            			}
            		}
HXLINE( 109)		{
HXLINE( 109)			int _g11 = (int)0;
HXDLIN( 109)			int _g2 = this->m_vertexCount;
HXDLIN( 109)			while((_g11 < _g2)){
HXLINE( 109)				_g11 = (_g11 + (int)1);
HXDLIN( 109)				int i2 = (_g11 - (int)1);
HXLINE( 111)				int i11 = i2;
HXLINE( 112)				int i21;
HXDLIN( 112)				if (((i2 + (int)1) < this->m_vertexCount)) {
HXLINE( 112)					i21 = (i2 + (int)1);
            				}
            				else {
HXLINE( 112)					i21 = (int)0;
            				}
HXLINE( 113)				 ::box2D::common::math::B2Vec2 edge = this->m_vertices->__get(i21).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXDLIN( 113)				 ::box2D::common::math::B2Vec2 edge1 = ::box2D::common::math::B2Math_obj::subtractVVPooled(edge,this->m_vertices->__get(i11).StaticCast<  ::box2D::common::math::B2Vec2 >());
HXLINE( 114)				::box2D::common::B2Settings_obj::b2Assert((edge1->lengthSquared() > ((Float)2.2250738585072014e-308)));
HXLINE( 115)				{
HXLINE( 115)					 ::box2D::common::math::B2Vec2 _this1 = this->m_normals->__get(i2).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXDLIN( 115)					 ::box2D::common::math::B2Vec2 v1 = ::box2D::common::math::B2Math_obj::crossVF(edge1,((Float)1.0),null());
HXDLIN( 115)					_this1->x = v1->x;
HXDLIN( 115)					_this1->y = v1->y;
            				}
HXLINE( 116)				this->m_normals->__get(i2).StaticCast<  ::box2D::common::math::B2Vec2 >()->normalize();
            			}
            		}
HXLINE( 120)		this->m_centroid = ::box2D::collision::shapes::B2PolygonShape_obj::computeCentroid(this->m_vertices,this->m_vertexCount);
            	}


HX_DEFINE_DYNAMIC_FUNC2(B2PolygonShape_obj,setAsVector,(void))

void B2PolygonShape_obj::setAsBox(Float hx,Float hy){
            	HX_STACKFRAME(&_hx_pos_102b8b1a357996ba_136_setAsBox)
HXLINE( 137)		this->m_vertexCount = (int)4;
HXLINE( 138)		this->reserve((int)4);
HXLINE( 139)		{
HXLINE( 139)			 ::box2D::common::math::B2Vec2 _this = this->m_vertices->__get((int)0).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXDLIN( 139)			_this->x = -(hx);
HXDLIN( 139)			_this->y = -(hy);
            		}
HXLINE( 140)		{
HXLINE( 140)			 ::box2D::common::math::B2Vec2 _this1 = this->m_vertices->__get((int)1).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXDLIN( 140)			_this1->x = hx;
HXDLIN( 140)			_this1->y = -(hy);
            		}
HXLINE( 141)		{
HXLINE( 141)			 ::box2D::common::math::B2Vec2 _this2 = this->m_vertices->__get((int)2).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXDLIN( 141)			_this2->x = hx;
HXDLIN( 141)			_this2->y = hy;
            		}
HXLINE( 142)		{
HXLINE( 142)			 ::box2D::common::math::B2Vec2 _this3 = this->m_vertices->__get((int)3).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXDLIN( 142)			_this3->x = -(hx);
HXDLIN( 142)			_this3->y = hy;
            		}
HXLINE( 143)		{
HXLINE( 143)			 ::box2D::common::math::B2Vec2 _this4 = this->m_normals->__get((int)0).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXDLIN( 143)			_this4->x = ((Float)0.0);
HXDLIN( 143)			_this4->y = ((Float)-1.0);
            		}
HXLINE( 144)		{
HXLINE( 144)			 ::box2D::common::math::B2Vec2 _this5 = this->m_normals->__get((int)1).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXDLIN( 144)			_this5->x = ((Float)1.0);
HXDLIN( 144)			_this5->y = ((Float)0.0);
            		}
HXLINE( 145)		{
HXLINE( 145)			 ::box2D::common::math::B2Vec2 _this6 = this->m_normals->__get((int)2).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXDLIN( 145)			_this6->x = ((Float)0.0);
HXDLIN( 145)			_this6->y = ((Float)1.0);
            		}
HXLINE( 146)		{
HXLINE( 146)			 ::box2D::common::math::B2Vec2 _this7 = this->m_normals->__get((int)3).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXDLIN( 146)			_this7->x = ((Float)-1.0);
HXDLIN( 146)			_this7->y = ((Float)0.0);
            		}
HXLINE( 147)		{
HXLINE( 147)			 ::box2D::common::math::B2Vec2 _this8 = this->m_centroid;
HXDLIN( 147)			_this8->x = ((Float)0.0);
HXDLIN( 147)			_this8->y = ((Float)0.0);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(B2PolygonShape_obj,setAsBox,(void))

void B2PolygonShape_obj::setAsOrientedBox(Float hx,Float hy, ::box2D::common::math::B2Vec2 center,hx::Null< Float >  __o_angle){
Float angle = __o_angle.Default(((Float)0.0));
            	HX_GC_STACKFRAME(&_hx_pos_102b8b1a357996ba_166_setAsOrientedBox)
HXLINE( 167)		this->m_vertexCount = (int)4;
HXLINE( 168)		this->reserve((int)4);
HXLINE( 169)		{
HXLINE( 169)			 ::box2D::common::math::B2Vec2 _this = this->m_vertices->__get((int)0).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXDLIN( 169)			_this->x = -(hx);
HXDLIN( 169)			_this->y = -(hy);
            		}
HXLINE( 170)		{
HXLINE( 170)			 ::box2D::common::math::B2Vec2 _this1 = this->m_vertices->__get((int)1).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXDLIN( 170)			_this1->x = hx;
HXDLIN( 170)			_this1->y = -(hy);
            		}
HXLINE( 171)		{
HXLINE( 171)			 ::box2D::common::math::B2Vec2 _this2 = this->m_vertices->__get((int)2).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXDLIN( 171)			_this2->x = hx;
HXDLIN( 171)			_this2->y = hy;
            		}
HXLINE( 172)		{
HXLINE( 172)			 ::box2D::common::math::B2Vec2 _this3 = this->m_vertices->__get((int)3).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXDLIN( 172)			_this3->x = -(hx);
HXDLIN( 172)			_this3->y = hy;
            		}
HXLINE( 173)		{
HXLINE( 173)			 ::box2D::common::math::B2Vec2 _this4 = this->m_normals->__get((int)0).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXDLIN( 173)			_this4->x = ((Float)0.0);
HXDLIN( 173)			_this4->y = ((Float)-1.0);
            		}
HXLINE( 174)		{
HXLINE( 174)			 ::box2D::common::math::B2Vec2 _this5 = this->m_normals->__get((int)1).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXDLIN( 174)			_this5->x = ((Float)1.0);
HXDLIN( 174)			_this5->y = ((Float)0.0);
            		}
HXLINE( 175)		{
HXLINE( 175)			 ::box2D::common::math::B2Vec2 _this6 = this->m_normals->__get((int)2).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXDLIN( 175)			_this6->x = ((Float)0.0);
HXDLIN( 175)			_this6->y = ((Float)1.0);
            		}
HXLINE( 176)		{
HXLINE( 176)			 ::box2D::common::math::B2Vec2 _this7 = this->m_normals->__get((int)3).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXDLIN( 176)			_this7->x = ((Float)-1.0);
HXDLIN( 176)			_this7->y = ((Float)0.0);
            		}
HXLINE( 177)		this->m_centroid = center;
HXLINE( 179)		 ::box2D::common::math::B2Transform xf =  ::box2D::common::math::B2Transform_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 180)		xf->position = center;
HXLINE( 181)		xf->R->set(angle);
HXLINE( 184)		{
HXLINE( 184)			int _g1 = (int)0;
HXDLIN( 184)			int _g = this->m_vertexCount;
HXDLIN( 184)			while((_g1 < _g)){
HXLINE( 184)				_g1 = (_g1 + (int)1);
HXDLIN( 184)				int i = (_g1 - (int)1);
HXLINE( 186)				::Array< ::Dynamic> _hx_tmp = this->m_vertices;
HXDLIN( 186)				_hx_tmp[i] = ::box2D::common::math::B2Math_obj::mulX(xf,this->m_vertices->__get(i).StaticCast<  ::box2D::common::math::B2Vec2 >(),null());
HXLINE( 187)				::Array< ::Dynamic> _hx_tmp1 = this->m_normals;
HXDLIN( 187)				 ::box2D::common::math::B2Mat22 xf1 = xf->R;
HXDLIN( 187)				_hx_tmp1[i] = ::box2D::common::math::B2Math_obj::mulMV(xf1,this->m_normals->__get(i).StaticCast<  ::box2D::common::math::B2Vec2 >(),null());
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(B2PolygonShape_obj,setAsOrientedBox,(void))

void B2PolygonShape_obj::setAsEdge( ::box2D::common::math::B2Vec2 v1, ::box2D::common::math::B2Vec2 v2){
            	HX_STACKFRAME(&_hx_pos_102b8b1a357996ba_202_setAsEdge)
HXLINE( 203)		this->m_vertexCount = (int)2;
HXLINE( 204)		this->reserve((int)2);
HXLINE( 205)		{
HXLINE( 205)			 ::box2D::common::math::B2Vec2 _this = this->m_vertices->__get((int)0).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXDLIN( 205)			_this->x = v1->x;
HXDLIN( 205)			_this->y = v1->y;
            		}
HXLINE( 206)		{
HXLINE( 206)			 ::box2D::common::math::B2Vec2 _this1 = this->m_vertices->__get((int)1).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXDLIN( 206)			_this1->x = v2->x;
HXDLIN( 206)			_this1->y = v2->y;
            		}
HXLINE( 207)		this->m_centroid->x = (((Float)0.5) * (v1->x + v2->x));
HXLINE( 208)		this->m_centroid->y = (((Float)0.5) * (v1->y + v2->y));
HXLINE( 209)		::Array< ::Dynamic> _hx_tmp = this->m_normals;
HXDLIN( 209)		_hx_tmp[(int)0] = ::box2D::common::math::B2Math_obj::crossVF(::box2D::common::math::B2Math_obj::subtractVV(v2,v1),((Float)1.0),null());
HXLINE( 210)		this->m_normals->__get((int)0).StaticCast<  ::box2D::common::math::B2Vec2 >()->normalize();
HXLINE( 211)		this->m_normals->__get((int)1).StaticCast<  ::box2D::common::math::B2Vec2 >()->x = -(this->m_normals->__get((int)0).StaticCast<  ::box2D::common::math::B2Vec2 >()->x);
HXLINE( 212)		this->m_normals->__get((int)1).StaticCast<  ::box2D::common::math::B2Vec2 >()->y = -(this->m_normals->__get((int)0).StaticCast<  ::box2D::common::math::B2Vec2 >()->y);
            	}


HX_DEFINE_DYNAMIC_FUNC2(B2PolygonShape_obj,setAsEdge,(void))

bool B2PolygonShape_obj::testPoint( ::box2D::common::math::B2Transform xf, ::box2D::common::math::B2Vec2 p){
            	HX_STACKFRAME(&_hx_pos_102b8b1a357996ba_229_testPoint)
HXLINE( 230)		 ::box2D::common::math::B2Vec2 tVec;
HXLINE( 233)		 ::box2D::common::math::B2Mat22 tMat = xf->R;
HXLINE( 234)		Float tX = (p->x - xf->position->x);
HXLINE( 235)		Float tY = (p->y - xf->position->y);
HXLINE( 236)		Float pLocalX = (tX * tMat->col1->x);
HXDLIN( 236)		Float pLocalX1 = (pLocalX + (tY * tMat->col1->y));
HXLINE( 237)		Float pLocalY = (tX * tMat->col2->x);
HXDLIN( 237)		Float pLocalY1 = (pLocalY + (tY * tMat->col2->y));
HXLINE( 239)		{
HXLINE( 239)			int _g1 = (int)0;
HXDLIN( 239)			int _g = this->m_vertexCount;
HXDLIN( 239)			while((_g1 < _g)){
HXLINE( 239)				_g1 = (_g1 + (int)1);
HXDLIN( 239)				int i = (_g1 - (int)1);
HXLINE( 242)				tVec = this->m_vertices->__get(i).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXLINE( 243)				tX = (pLocalX1 - tVec->x);
HXLINE( 244)				tY = (pLocalY1 - tVec->y);
HXLINE( 245)				tVec = this->m_normals->__get(i).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXLINE( 246)				Float dot = (tVec->x * tX);
HXDLIN( 246)				Float dot1 = (dot + (tVec->y * tY));
HXLINE( 247)				if ((dot1 > ((Float)0.0))) {
HXLINE( 249)					return false;
            				}
            			}
            		}
HXLINE( 253)		return true;
            	}


bool B2PolygonShape_obj::rayCast( ::box2D::collision::B2RayCastOutput output, ::box2D::collision::B2RayCastInput input, ::box2D::common::math::B2Transform transform){
            	HX_STACKFRAME(&_hx_pos_102b8b1a357996ba_260_rayCast)
HXLINE( 261)		Float lower = ((Float)0.0);
HXLINE( 262)		Float upper = input->maxFraction;
HXLINE( 264)		Float tX;
HXLINE( 265)		Float tY;
HXLINE( 266)		 ::box2D::common::math::B2Mat22 tMat;
HXLINE( 267)		 ::box2D::common::math::B2Vec2 tVec;
HXLINE( 271)		tX = (input->p1->x - transform->position->x);
HXLINE( 272)		tY = (input->p1->y - transform->position->y);
HXLINE( 273)		tMat = transform->R;
HXLINE( 274)		Float p1X = (tX * tMat->col1->x);
HXDLIN( 274)		Float p1X1 = (p1X + (tY * tMat->col1->y));
HXLINE( 275)		Float p1Y = (tX * tMat->col2->x);
HXDLIN( 275)		Float p1Y1 = (p1Y + (tY * tMat->col2->y));
HXLINE( 277)		tX = (input->p2->x - transform->position->x);
HXLINE( 278)		tY = (input->p2->y - transform->position->y);
HXLINE( 279)		tMat = transform->R;
HXLINE( 280)		Float p2X = (tX * tMat->col1->x);
HXDLIN( 280)		Float p2X1 = (p2X + (tY * tMat->col1->y));
HXLINE( 281)		Float p2Y = (tX * tMat->col2->x);
HXDLIN( 281)		Float p2Y1 = (p2Y + (tY * tMat->col2->y));
HXLINE( 283)		Float dX = (p2X1 - p1X1);
HXLINE( 284)		Float dY = (p2Y1 - p1Y1);
HXLINE( 285)		int index = (int)-1;
HXLINE( 287)		{
HXLINE( 287)			int _g1 = (int)0;
HXDLIN( 287)			int _g = this->m_vertexCount;
HXDLIN( 287)			while((_g1 < _g)){
HXLINE( 287)				_g1 = (_g1 + (int)1);
HXDLIN( 287)				int i = (_g1 - (int)1);
HXLINE( 294)				tVec = this->m_vertices->__get(i).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXLINE( 295)				tX = (tVec->x - p1X1);
HXLINE( 296)				tY = (tVec->y - p1Y1);
HXLINE( 297)				tVec = this->m_normals->__get(i).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXLINE( 298)				Float numerator = (tVec->x * tX);
HXDLIN( 298)				Float numerator1 = (numerator + (tVec->y * tY));
HXLINE( 300)				Float denominator = (tVec->x * dX);
HXDLIN( 300)				Float denominator1 = (denominator + (tVec->y * dY));
HXLINE( 302)				if ((denominator1 == ((Float)0.0))) {
HXLINE( 304)					if ((numerator1 < ((Float)0.0))) {
HXLINE( 306)						return false;
            					}
            				}
            				else {
HXLINE( 315)					bool _hx_tmp;
HXDLIN( 315)					if ((denominator1 < ((Float)0.0))) {
HXLINE( 315)						_hx_tmp = (numerator1 < (lower * denominator1));
            					}
            					else {
HXLINE( 315)						_hx_tmp = false;
            					}
HXDLIN( 315)					if (_hx_tmp) {
HXLINE( 319)						lower = ((Float)numerator1 / (Float)denominator1);
HXLINE( 320)						index = i;
            					}
            					else {
HXLINE( 322)						bool _hx_tmp1;
HXDLIN( 322)						if ((denominator1 > ((Float)0.0))) {
HXLINE( 322)							_hx_tmp1 = (numerator1 < (upper * denominator1));
            						}
            						else {
HXLINE( 322)							_hx_tmp1 = false;
            						}
HXDLIN( 322)						if (_hx_tmp1) {
HXLINE( 326)							upper = ((Float)numerator1 / (Float)denominator1);
            						}
            					}
            				}
HXLINE( 330)				if ((upper < (lower - ((Float)2.2250738585072014e-308)))) {
HXLINE( 332)					return false;
            				}
            			}
            		}
HXLINE( 338)		if ((index >= (int)0)) {
HXLINE( 340)			output->fraction = lower;
HXLINE( 342)			tMat = transform->R;
HXLINE( 343)			tVec = this->m_normals->__get(index).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXLINE( 344)			Float _hx_tmp2 = (tMat->col1->x * tVec->x);
HXDLIN( 344)			output->normal->x = (_hx_tmp2 + (tMat->col2->x * tVec->y));
HXLINE( 345)			Float _hx_tmp3 = (tMat->col1->y * tVec->x);
HXDLIN( 345)			output->normal->y = (_hx_tmp3 + (tMat->col2->y * tVec->y));
HXLINE( 346)			return true;
            		}
HXLINE( 349)		return false;
            	}


void B2PolygonShape_obj::computeAABB( ::box2D::collision::B2AABB aabb, ::box2D::common::math::B2Transform xf){
            	HX_STACKFRAME(&_hx_pos_102b8b1a357996ba_357_computeAABB)
HXLINE( 359)		 ::box2D::common::math::B2Mat22 tMat = xf->R;
HXLINE( 360)		 ::box2D::common::math::B2Vec2 tVec = this->m_vertices->__get((int)0).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXLINE( 361)		Float xf1 = xf->position->x;
HXDLIN( 361)		Float lowerX = (tMat->col1->x * tVec->x);
HXDLIN( 361)		Float lowerX1 = (xf1 + (lowerX + (tMat->col2->x * tVec->y)));
HXLINE( 362)		Float xf2 = xf->position->y;
HXDLIN( 362)		Float lowerY = (tMat->col1->y * tVec->x);
HXDLIN( 362)		Float lowerY1 = (xf2 + (lowerY + (tMat->col2->y * tVec->y)));
HXLINE( 363)		Float upperX = lowerX1;
HXLINE( 364)		Float upperY = lowerY1;
HXLINE( 366)		{
HXLINE( 366)			int _g1 = (int)1;
HXDLIN( 366)			int _g = this->m_vertexCount;
HXDLIN( 366)			while((_g1 < _g)){
HXLINE( 366)				_g1 = (_g1 + (int)1);
HXDLIN( 366)				int i = (_g1 - (int)1);
HXLINE( 368)				tVec = this->m_vertices->__get(i).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXLINE( 369)				Float xf3 = xf->position->x;
HXDLIN( 369)				Float vX = (tMat->col1->x * tVec->x);
HXDLIN( 369)				Float vX1 = (xf3 + (vX + (tMat->col2->x * tVec->y)));
HXLINE( 370)				Float xf4 = xf->position->y;
HXDLIN( 370)				Float vY = (tMat->col1->y * tVec->x);
HXDLIN( 370)				Float vY1 = (xf4 + (vY + (tMat->col2->y * tVec->y)));
HXLINE( 371)				if ((lowerX1 < vX1)) {
HXLINE( 371)					lowerX1 = lowerX1;
            				}
            				else {
HXLINE( 371)					lowerX1 = vX1;
            				}
HXLINE( 372)				if ((lowerY1 < vY1)) {
HXLINE( 372)					lowerY1 = lowerY1;
            				}
            				else {
HXLINE( 372)					lowerY1 = vY1;
            				}
HXLINE( 373)				if ((upperX > vX1)) {
HXLINE( 373)					upperX = upperX;
            				}
            				else {
HXLINE( 373)					upperX = vX1;
            				}
HXLINE( 374)				if ((upperY > vY1)) {
HXLINE( 374)					upperY = upperY;
            				}
            				else {
HXLINE( 374)					upperY = vY1;
            				}
            			}
            		}
HXLINE( 377)		aabb->lowerBound->x = (lowerX1 - this->m_radius);
HXLINE( 378)		aabb->lowerBound->y = (lowerY1 - this->m_radius);
HXLINE( 379)		aabb->upperBound->x = (upperX + this->m_radius);
HXLINE( 380)		aabb->upperBound->y = (upperY + this->m_radius);
            	}


void B2PolygonShape_obj::computeMass( ::box2D::collision::shapes::B2MassData massData,Float density){
            	HX_STACKFRAME(&_hx_pos_102b8b1a357996ba_387_computeMass)
HXLINE( 415)		if ((this->m_vertexCount == (int)2)) {
HXLINE( 417)			massData->center->x = (((Float)0.5) * (this->m_vertices->__get((int)0).StaticCast<  ::box2D::common::math::B2Vec2 >()->x + this->m_vertices->__get((int)1).StaticCast<  ::box2D::common::math::B2Vec2 >()->x));
HXLINE( 418)			massData->center->y = (((Float)0.5) * (this->m_vertices->__get((int)0).StaticCast<  ::box2D::common::math::B2Vec2 >()->y + this->m_vertices->__get((int)1).StaticCast<  ::box2D::common::math::B2Vec2 >()->y));
HXLINE( 419)			massData->mass = ((Float)0.0);
HXLINE( 420)			massData->I = ((Float)0.0);
HXLINE( 421)			return;
            		}
HXLINE( 425)		Float centerX = ((Float)0.0);
HXLINE( 426)		Float centerY = ((Float)0.0);
HXLINE( 427)		Float area = ((Float)0.0);
HXLINE( 428)		Float I = ((Float)0.0);
HXLINE( 433)		Float p1X = ((Float)0.0);
HXLINE( 434)		Float p1Y = ((Float)0.0);
HXLINE( 444)		Float k_inv3 = ((Float)0.33333333333333331);
HXLINE( 446)		{
HXLINE( 446)			int _g1 = (int)0;
HXDLIN( 446)			int _g = this->m_vertexCount;
HXDLIN( 446)			while((_g1 < _g)){
HXLINE( 446)				_g1 = (_g1 + (int)1);
HXDLIN( 446)				int i = (_g1 - (int)1);
HXLINE( 452)				 ::box2D::common::math::B2Vec2 p2 = this->m_vertices->__get(i).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXLINE( 454)				 ::box2D::common::math::B2Vec2 p3;
HXDLIN( 454)				if (((i + (int)1) < this->m_vertexCount)) {
HXLINE( 454)					::Array< ::Dynamic> p31 = this->m_vertices;
HXDLIN( 454)					p3 = p31->__get(::Std_obj::_hx_int((i + (int)1))).StaticCast<  ::box2D::common::math::B2Vec2 >();
            				}
            				else {
HXLINE( 454)					p3 = this->m_vertices->__get((int)0).StaticCast<  ::box2D::common::math::B2Vec2 >();
            				}
HXLINE( 457)				Float e1X = (p2->x - p1X);
HXLINE( 458)				Float e1Y = (p2->y - p1Y);
HXLINE( 460)				Float e2X = (p3->x - p1X);
HXLINE( 461)				Float e2Y = (p3->y - p1Y);
HXLINE( 464)				Float D = ((e1X * e2Y) - (e1Y * e2X));
HXLINE( 467)				Float triangleArea = (((Float)0.5) * D);
HXLINE( 468)				area = (area + triangleArea);
HXLINE( 472)				centerX = (centerX + ((triangleArea * k_inv3) * ((p1X + p2->x) + p3->x)));
HXLINE( 473)				centerY = (centerY + ((triangleArea * k_inv3) * ((p1Y + p2->y) + p3->y)));
HXLINE( 476)				Float px = p1X;
HXLINE( 477)				Float py = p1Y;
HXLINE( 479)				Float ex1 = e1X;
HXLINE( 480)				Float ey1 = e1Y;
HXLINE( 482)				Float ex2 = e2X;
HXLINE( 483)				Float ey2 = e2Y;
HXLINE( 486)				Float intx2 = ((k_inv3 * ((((Float)0.25) * (((ex1 * ex1) + (ex2 * ex1)) + (ex2 * ex2))) + ((px * ex1) + (px * ex2)))) + ((((Float)0.5) * px) * px));
HXLINE( 488)				Float inty2 = ((k_inv3 * ((((Float)0.25) * (((ey1 * ey1) + (ey2 * ey1)) + (ey2 * ey2))) + ((py * ey1) + (py * ey2)))) + ((((Float)0.5) * py) * py));
HXLINE( 490)				I = (I + (D * (intx2 + inty2)));
            			}
            		}
HXLINE( 494)		massData->mass = (density * area);
HXLINE( 499)		centerX = (centerX * ((Float)((Float)1.0) / (Float)area));
HXLINE( 500)		centerY = (centerY * ((Float)((Float)1.0) / (Float)area));
HXLINE( 502)		{
HXLINE( 502)			 ::box2D::common::math::B2Vec2 _this = massData->center;
HXDLIN( 502)			_this->x = centerX;
HXDLIN( 502)			_this->y = centerY;
            		}
HXLINE( 505)		massData->I = (density * I);
            	}


Float B2PolygonShape_obj::computeSubmergedArea( ::box2D::common::math::B2Vec2 normal,Float offset, ::box2D::common::math::B2Transform xf, ::box2D::common::math::B2Vec2 c){
            	HX_GC_STACKFRAME(&_hx_pos_102b8b1a357996ba_516_computeSubmergedArea)
HXLINE( 518)		 ::box2D::common::math::B2Vec2 normalL = ::box2D::common::math::B2Math_obj::mulTMV(xf->R,normal,true);
HXLINE( 519)		Float offsetL = (offset - ::box2D::common::math::B2Math_obj::dot(normal,xf->position));
HXLINE( 521)		::Array< Float > depths = ::Array_obj< Float >::__new();
HXLINE( 522)		int diveCount = (int)0;
HXLINE( 523)		int intoIndex = (int)-1;
HXLINE( 524)		int outoIndex = (int)-1;
HXLINE( 526)		bool lastSubmerged = false;
HXLINE( 527)		int i;
HXLINE( 528)		{
HXLINE( 528)			int _g1 = (int)0;
HXDLIN( 528)			int _g = this->m_vertexCount;
HXDLIN( 528)			while((_g1 < _g)){
HXLINE( 528)				_g1 = (_g1 + (int)1);
HXDLIN( 528)				int i1 = (_g1 - (int)1);
HXLINE( 530)				depths[i1] = (::box2D::common::math::B2Math_obj::dot(normalL,this->m_vertices->__get(i1).StaticCast<  ::box2D::common::math::B2Vec2 >()) - offsetL);
HXLINE( 531)				bool isSubmerged = (depths->__get(i1) < ((Float)-2.2250738585072014e-308));
HXLINE( 532)				if ((i1 > (int)0)) {
HXLINE( 534)					if (isSubmerged) {
HXLINE( 536)						if (!(lastSubmerged)) {
HXLINE( 538)							intoIndex = (i1 - (int)1);
HXLINE( 539)							diveCount = (diveCount + (int)1);
            						}
            					}
            					else {
HXLINE( 544)						if (lastSubmerged) {
HXLINE( 546)							outoIndex = (i1 - (int)1);
HXLINE( 547)							diveCount = (diveCount + (int)1);
            						}
            					}
            				}
HXLINE( 551)				lastSubmerged = isSubmerged;
            			}
            		}
HXLINE( 553)		switch((int)(diveCount)){
            			case (int)0: {
HXLINE( 556)				if (lastSubmerged) {
HXLINE( 559)					 ::box2D::collision::shapes::B2MassData md =  ::box2D::collision::shapes::B2MassData_obj::__alloc( HX_CTX );
HXLINE( 560)					this->computeMass(md,(int)1);
HXLINE( 561)					{
HXLINE( 561)						 ::box2D::common::math::B2Vec2 v = ::box2D::common::math::B2Math_obj::mulX(xf,md->center,null());
HXDLIN( 561)						c->x = v->x;
HXDLIN( 561)						c->y = v->y;
            					}
HXLINE( 562)					return md->mass;
            				}
            				else {
HXLINE( 567)					return (int)0;
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 571)				if ((intoIndex == (int)-1)) {
HXLINE( 573)					intoIndex = (this->m_vertexCount - (int)1);
            				}
            				else {
HXLINE( 577)					outoIndex = (this->m_vertexCount - (int)1);
            				}
            			}
            			break;
            		}
HXLINE( 581)		int intoIndex2 = hx::Mod((intoIndex + (int)1),this->m_vertexCount);
HXLINE( 582)		int outoIndex2 = hx::Mod((outoIndex + (int)1),this->m_vertexCount);
HXLINE( 583)		Float intoLamdda = ((Float)((int)0 - depths->__get(intoIndex)) / (Float)(depths->__get(intoIndex2) - depths->__get(intoIndex)));
HXLINE( 584)		Float outoLamdda = ((Float)((int)0 - depths->__get(outoIndex)) / (Float)(depths->__get(outoIndex2) - depths->__get(outoIndex)));
HXLINE( 586)		Float intoVec = this->m_vertices->__get(intoIndex).StaticCast<  ::box2D::common::math::B2Vec2 >()->x;
HXDLIN( 586)		Float intoVec1 = (intoVec * ((int)1 - intoLamdda));
HXDLIN( 586)		Float intoVec2 = (intoVec1 + (this->m_vertices->__get(intoIndex2).StaticCast<  ::box2D::common::math::B2Vec2 >()->x * intoLamdda));
HXLINE( 587)		Float intoVec3 = this->m_vertices->__get(intoIndex).StaticCast<  ::box2D::common::math::B2Vec2 >()->y;
HXDLIN( 587)		Float intoVec4 = (intoVec3 * ((int)1 - intoLamdda));
HXLINE( 586)		 ::box2D::common::math::B2Vec2 intoVec5 =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,intoVec2,(intoVec4 + (this->m_vertices->__get(intoIndex2).StaticCast<  ::box2D::common::math::B2Vec2 >()->y * intoLamdda)));
HXLINE( 588)		Float outoVec = this->m_vertices->__get(outoIndex).StaticCast<  ::box2D::common::math::B2Vec2 >()->x;
HXDLIN( 588)		Float outoVec1 = (outoVec * ((int)1 - outoLamdda));
HXDLIN( 588)		Float outoVec2 = (outoVec1 + (this->m_vertices->__get(outoIndex2).StaticCast<  ::box2D::common::math::B2Vec2 >()->x * outoLamdda));
HXLINE( 589)		Float outoVec3 = this->m_vertices->__get(outoIndex).StaticCast<  ::box2D::common::math::B2Vec2 >()->y;
HXDLIN( 589)		Float outoVec4 = (outoVec3 * ((int)1 - outoLamdda));
HXLINE( 588)		 ::box2D::common::math::B2Vec2 outoVec5 =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,outoVec2,(outoVec4 + (this->m_vertices->__get(outoIndex2).StaticCast<  ::box2D::common::math::B2Vec2 >()->y * outoLamdda)));
HXLINE( 592)		Float area = (int)0;
HXLINE( 593)		 ::box2D::common::math::B2Vec2 center =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 594)		 ::box2D::common::math::B2Vec2 p2 = this->m_vertices->__get(intoIndex2).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXLINE( 595)		 ::box2D::common::math::B2Vec2 p3;
HXLINE( 598)		i = intoIndex2;
HXLINE( 599)		while((i != outoIndex2)){
HXLINE( 601)			i = hx::Mod((i + (int)1),this->m_vertexCount);
HXLINE( 602)			if ((i == outoIndex2)) {
HXLINE( 603)				p3 = outoVec5;
            			}
            			else {
HXLINE( 605)				p3 = this->m_vertices->__get(i).StaticCast<  ::box2D::common::math::B2Vec2 >();
            			}
HXLINE( 607)			Float triangleArea = (p2->x - intoVec5->x);
HXDLIN( 607)			Float triangleArea1 = (triangleArea * (p3->y - intoVec5->y));
HXDLIN( 607)			Float triangleArea2 = (p2->y - intoVec5->y);
HXDLIN( 607)			Float triangleArea3 = (((Float)0.5) * (triangleArea1 - (triangleArea2 * (p3->x - intoVec5->x))));
HXLINE( 608)			area = (area + triangleArea3);
HXLINE( 610)			 ::box2D::common::math::B2Vec2 center1 = center;
HXDLIN( 610)			center1->x = (center1->x + ((Float)(triangleArea3 * ((intoVec5->x + p2->x) + p3->x)) / (Float)(int)3));
HXLINE( 611)			 ::box2D::common::math::B2Vec2 center2 = center;
HXDLIN( 611)			center2->y = (center2->y + ((Float)(triangleArea3 * ((intoVec5->y + p2->y) + p3->y)) / (Float)(int)3));
HXLINE( 613)			p2 = p3;
            		}
HXLINE( 617)		center->multiply(((Float)(int)1 / (Float)area));
HXLINE( 618)		{
HXLINE( 618)			 ::box2D::common::math::B2Vec2 v1 = ::box2D::common::math::B2Math_obj::mulX(xf,center,null());
HXDLIN( 618)			c->x = v1->x;
HXDLIN( 618)			c->y = v1->y;
            		}
HXLINE( 620)		return area;
            	}


int B2PolygonShape_obj::getVertexCount(){
            	HX_STACKFRAME(&_hx_pos_102b8b1a357996ba_627_getVertexCount)
HXDLIN( 627)		return this->m_vertexCount;
            	}


HX_DEFINE_DYNAMIC_FUNC0(B2PolygonShape_obj,getVertexCount,return )

::Array< ::Dynamic> B2PolygonShape_obj::getVertices(){
            	HX_STACKFRAME(&_hx_pos_102b8b1a357996ba_634_getVertices)
HXDLIN( 634)		return this->m_vertices;
            	}


HX_DEFINE_DYNAMIC_FUNC0(B2PolygonShape_obj,getVertices,return )

::Array< ::Dynamic> B2PolygonShape_obj::getNormals(){
            	HX_STACKFRAME(&_hx_pos_102b8b1a357996ba_642_getNormals)
HXDLIN( 642)		return this->m_normals;
            	}


HX_DEFINE_DYNAMIC_FUNC0(B2PolygonShape_obj,getNormals,return )

int B2PolygonShape_obj::getSupport( ::box2D::common::math::B2Vec2 d){
            	HX_STACKFRAME(&_hx_pos_102b8b1a357996ba_649_getSupport)
HXLINE( 650)		int bestIndex = (int)0;
HXLINE( 651)		Float bestValue = (this->m_vertices->__get((int)0).StaticCast<  ::box2D::common::math::B2Vec2 >()->x * d->x);
HXDLIN( 651)		Float bestValue1 = (bestValue + (this->m_vertices->__get((int)0).StaticCast<  ::box2D::common::math::B2Vec2 >()->y * d->y));
HXLINE( 652)		{
HXLINE( 652)			int _g1 = (int)1;
HXDLIN( 652)			int _g = this->m_vertexCount;
HXDLIN( 652)			while((_g1 < _g)){
HXLINE( 652)				_g1 = (_g1 + (int)1);
HXDLIN( 652)				int i = (_g1 - (int)1);
HXLINE( 654)				Float value = (this->m_vertices->__get(i).StaticCast<  ::box2D::common::math::B2Vec2 >()->x * d->x);
HXDLIN( 654)				Float value1 = (value + (this->m_vertices->__get(i).StaticCast<  ::box2D::common::math::B2Vec2 >()->y * d->y));
HXLINE( 655)				if ((value1 > bestValue1)) {
HXLINE( 657)					bestIndex = i;
HXLINE( 658)					bestValue1 = value1;
            				}
            			}
            		}
HXLINE( 661)		return bestIndex;
            	}


HX_DEFINE_DYNAMIC_FUNC1(B2PolygonShape_obj,getSupport,return )

 ::box2D::common::math::B2Vec2 B2PolygonShape_obj::getSupportVertex( ::box2D::common::math::B2Vec2 d){
            	HX_STACKFRAME(&_hx_pos_102b8b1a357996ba_665_getSupportVertex)
HXLINE( 666)		int bestIndex = (int)0;
HXLINE( 667)		Float bestValue = (this->m_vertices->__get((int)0).StaticCast<  ::box2D::common::math::B2Vec2 >()->x * d->x);
HXDLIN( 667)		Float bestValue1 = (bestValue + (this->m_vertices->__get((int)0).StaticCast<  ::box2D::common::math::B2Vec2 >()->y * d->y));
HXLINE( 668)		{
HXLINE( 668)			int _g1 = (int)1;
HXDLIN( 668)			int _g = this->m_vertexCount;
HXDLIN( 668)			while((_g1 < _g)){
HXLINE( 668)				_g1 = (_g1 + (int)1);
HXDLIN( 668)				int i = (_g1 - (int)1);
HXLINE( 670)				Float value = (this->m_vertices->__get(i).StaticCast<  ::box2D::common::math::B2Vec2 >()->x * d->x);
HXDLIN( 670)				Float value1 = (value + (this->m_vertices->__get(i).StaticCast<  ::box2D::common::math::B2Vec2 >()->y * d->y));
HXLINE( 671)				if ((value1 > bestValue1)) {
HXLINE( 673)					bestIndex = i;
HXLINE( 674)					bestValue1 = value1;
            				}
            			}
            		}
HXLINE( 677)		return this->m_vertices->__get(bestIndex).StaticCast<  ::box2D::common::math::B2Vec2 >();
            	}


HX_DEFINE_DYNAMIC_FUNC1(B2PolygonShape_obj,getSupportVertex,return )

bool B2PolygonShape_obj::validate(){
            	HX_STACKFRAME(&_hx_pos_102b8b1a357996ba_716_validate)
HXDLIN( 716)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC0(B2PolygonShape_obj,validate,return )

void B2PolygonShape_obj::reserve(int count){
            	HX_GC_STACKFRAME(&_hx_pos_102b8b1a357996ba_737_reserve)
HXDLIN( 737)		int _g1 = this->m_vertices->length;
HXDLIN( 737)		int _g = count;
HXDLIN( 737)		while((_g1 < _g)){
HXDLIN( 737)			_g1 = (_g1 + (int)1);
HXDLIN( 737)			int i = (_g1 - (int)1);
HXLINE( 739)			::Array< ::Dynamic> _hx_tmp = this->m_vertices;
HXDLIN( 739)			_hx_tmp[i] =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 740)			::Array< ::Dynamic> _hx_tmp1 = this->m_normals;
HXDLIN( 740)			_hx_tmp1[i] =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(B2PolygonShape_obj,reserve,(void))

 ::box2D::collision::shapes::B2PolygonShape B2PolygonShape_obj::asArray(::cpp::VirtualArray vertices,int vertexCount){
            	HX_GC_STACKFRAME(&_hx_pos_102b8b1a357996ba_80_asArray)
HXLINE(  81)		 ::box2D::collision::shapes::B2PolygonShape polygonShape =  ::box2D::collision::shapes::B2PolygonShape_obj::__alloc( HX_CTX );
HXLINE(  82)		polygonShape->setAsArray(vertices,vertexCount);
HXLINE(  83)		return polygonShape;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(B2PolygonShape_obj,asArray,return )

 ::box2D::collision::shapes::B2PolygonShape B2PolygonShape_obj::asVector(::Array< ::Dynamic> vertices,int vertexCount){
            	HX_GC_STACKFRAME(&_hx_pos_102b8b1a357996ba_124_asVector)
HXLINE( 125)		 ::box2D::collision::shapes::B2PolygonShape polygonShape =  ::box2D::collision::shapes::B2PolygonShape_obj::__alloc( HX_CTX );
HXLINE( 126)		polygonShape->setAsVector(vertices,vertexCount);
HXLINE( 127)		return polygonShape;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(B2PolygonShape_obj,asVector,return )

 ::box2D::collision::shapes::B2PolygonShape B2PolygonShape_obj::asBox(Float hx,Float hy){
            	HX_GC_STACKFRAME(&_hx_pos_102b8b1a357996ba_151_asBox)
HXLINE( 152)		 ::box2D::collision::shapes::B2PolygonShape polygonShape =  ::box2D::collision::shapes::B2PolygonShape_obj::__alloc( HX_CTX );
HXLINE( 153)		polygonShape->setAsBox(hx,hy);
HXLINE( 154)		return polygonShape;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(B2PolygonShape_obj,asBox,return )

 ::box2D::common::math::B2Mat22 B2PolygonShape_obj::s_mat;

 ::box2D::collision::shapes::B2PolygonShape B2PolygonShape_obj::asOrientedBox(Float hx,Float hy, ::box2D::common::math::B2Vec2 center,hx::Null< Float >  __o_angle){
Float angle = __o_angle.Default(((Float)0.0));
            	HX_GC_STACKFRAME(&_hx_pos_102b8b1a357996ba_192_asOrientedBox)
HXLINE( 193)		 ::box2D::collision::shapes::B2PolygonShape polygonShape =  ::box2D::collision::shapes::B2PolygonShape_obj::__alloc( HX_CTX );
HXLINE( 194)		polygonShape->setAsOrientedBox(hx,hy,center,angle);
HXLINE( 195)		return polygonShape;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(B2PolygonShape_obj,asOrientedBox,return )

 ::box2D::collision::shapes::B2PolygonShape B2PolygonShape_obj::asEdge( ::box2D::common::math::B2Vec2 v1, ::box2D::common::math::B2Vec2 v2){
            	HX_GC_STACKFRAME(&_hx_pos_102b8b1a357996ba_219_asEdge)
HXLINE( 220)		 ::box2D::collision::shapes::B2PolygonShape polygonShape =  ::box2D::collision::shapes::B2PolygonShape_obj::__alloc( HX_CTX );
HXLINE( 221)		polygonShape->setAsEdge(v1,v2);
HXLINE( 222)		return polygonShape;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(B2PolygonShape_obj,asEdge,return )

 ::box2D::common::math::B2Vec2 B2PolygonShape_obj::computeCentroid(::Array< ::Dynamic> vs,int count){
            	HX_GC_STACKFRAME(&_hx_pos_102b8b1a357996ba_761_computeCentroid)
HXLINE( 765)		 ::box2D::common::math::B2Vec2 c =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 766)		Float area = ((Float)0.0);
HXLINE( 771)		Float p1X = ((Float)0.0);
HXLINE( 772)		Float p1Y = ((Float)0.0);
HXLINE( 774)		Float inv3 = ((Float)0.33333333333333331);
HXLINE( 776)		{
HXLINE( 776)			int _g1 = (int)0;
HXDLIN( 776)			int _g = count;
HXDLIN( 776)			while((_g1 < _g)){
HXLINE( 776)				_g1 = (_g1 + (int)1);
HXDLIN( 776)				int i = (_g1 - (int)1);
HXLINE( 782)				 ::box2D::common::math::B2Vec2 p2 = vs->__get(i).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXLINE( 784)				 ::box2D::common::math::B2Vec2 p3;
HXDLIN( 784)				if (((i + (int)1) < count)) {
HXLINE( 784)					p3 = vs->__get(::Std_obj::_hx_int((i + (int)1))).StaticCast<  ::box2D::common::math::B2Vec2 >();
            				}
            				else {
HXLINE( 784)					p3 = vs->__get((int)0).StaticCast<  ::box2D::common::math::B2Vec2 >();
            				}
HXLINE( 787)				Float e1X = (p2->x - p1X);
HXLINE( 788)				Float e1Y = (p2->y - p1Y);
HXLINE( 790)				Float e2X = (p3->x - p1X);
HXLINE( 791)				Float e2Y = (p3->y - p1Y);
HXLINE( 794)				Float D = ((e1X * e2Y) - (e1Y * e2X));
HXLINE( 797)				Float triangleArea = (((Float)0.5) * D);
HXLINE( 798)				area = (area + triangleArea);
HXLINE( 802)				 ::box2D::common::math::B2Vec2 c1 = c;
HXDLIN( 802)				c1->x = (c1->x + ((triangleArea * inv3) * ((p1X + p2->x) + p3->x)));
HXLINE( 803)				 ::box2D::common::math::B2Vec2 c2 = c;
HXDLIN( 803)				c2->y = (c2->y + ((triangleArea * inv3) * ((p1Y + p2->y) + p3->y)));
            			}
            		}
HXLINE( 809)		 ::box2D::common::math::B2Vec2 c3 = c;
HXDLIN( 809)		c3->x = (c3->x * ((Float)((Float)1.0) / (Float)area));
HXLINE( 810)		 ::box2D::common::math::B2Vec2 c4 = c;
HXDLIN( 810)		c4->y = (c4->y * ((Float)((Float)1.0) / (Float)area));
HXLINE( 811)		return c;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(B2PolygonShape_obj,computeCentroid,return )

void B2PolygonShape_obj::computeOBB( ::box2D::collision::B2OBB obb,::Array< ::Dynamic> vs,int count){
            	HX_STACKFRAME(&_hx_pos_102b8b1a357996ba_819_computeOBB)
HXLINE( 820)		int i;
HXLINE( 821)		::Array< ::Dynamic> p = ::Array_obj< ::Dynamic>::__new();
HXLINE( 822)		{
HXLINE( 822)			int _g1 = (int)0;
HXDLIN( 822)			int _g = count;
HXDLIN( 822)			while((_g1 < _g)){
HXLINE( 822)				_g1 = (_g1 + (int)1);
HXDLIN( 822)				int i1 = (_g1 - (int)1);
HXLINE( 824)				p[i1] = vs->__get(i1).StaticCast<  ::box2D::common::math::B2Vec2 >();
            			}
            		}
HXLINE( 826)		p[count] = p->__get((int)0).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXLINE( 828)		Float minArea = ((Float)1.7976931348623158e+308);
HXLINE( 830)		{
HXLINE( 830)			int _g11 = (int)1;
HXDLIN( 830)			int _g2 = (count + (int)1);
HXDLIN( 830)			while((_g11 < _g2)){
HXLINE( 830)				_g11 = (_g11 + (int)1);
HXDLIN( 830)				int i2 = (_g11 - (int)1);
HXLINE( 832)				 ::box2D::common::math::B2Vec2 root = p->__get(::Std_obj::_hx_int((i2 - (int)1))).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXLINE( 834)				Float uxX = (p->__get(i2).StaticCast<  ::box2D::common::math::B2Vec2 >()->x - root->x);
HXLINE( 835)				Float uxY = (p->__get(i2).StaticCast<  ::box2D::common::math::B2Vec2 >()->y - root->y);
HXLINE( 837)				Float length = ::Math_obj::sqrt(((uxX * uxX) + (uxY * uxY)));
HXLINE( 838)				uxX = ((Float)uxX / (Float)length);
HXLINE( 839)				uxY = ((Float)uxY / (Float)length);
HXLINE( 842)				Float uyX = -(uxY);
HXLINE( 843)				Float uyY = uxX;
HXLINE( 845)				Float lowerX = ((Float)1.7976931348623158e+308);
HXLINE( 846)				Float lowerY = ((Float)1.7976931348623158e+308);
HXLINE( 848)				Float upperX = ((Float)-1.7976931348623157e+308);
HXLINE( 849)				Float upperY = ((Float)-1.7976931348623157e+308);
HXLINE( 851)				{
HXLINE( 851)					int _g3 = (int)0;
HXDLIN( 851)					int _g21 = count;
HXDLIN( 851)					while((_g3 < _g21)){
HXLINE( 851)						_g3 = (_g3 + (int)1);
HXDLIN( 851)						int j = (_g3 - (int)1);
HXLINE( 854)						Float dX = (p->__get(j).StaticCast<  ::box2D::common::math::B2Vec2 >()->x - root->x);
HXLINE( 855)						Float dY = (p->__get(j).StaticCast<  ::box2D::common::math::B2Vec2 >()->y - root->y);
HXLINE( 858)						Float rX = ((uxX * dX) + (uxY * dY));
HXLINE( 860)						Float rY = ((uyX * dX) + (uyY * dY));
HXLINE( 862)						if ((rX < lowerX)) {
HXLINE( 862)							lowerX = rX;
            						}
HXLINE( 863)						if ((rY < lowerY)) {
HXLINE( 863)							lowerY = rY;
            						}
HXLINE( 865)						if ((rX > upperX)) {
HXLINE( 865)							upperX = rX;
            						}
HXLINE( 866)						if ((rY > upperY)) {
HXLINE( 866)							upperY = rY;
            						}
            					}
            				}
HXLINE( 869)				Float area = ((upperX - lowerX) * (upperY - lowerY));
HXLINE( 870)				if ((area < (((Float)0.95) * minArea))) {
HXLINE( 872)					minArea = area;
HXLINE( 874)					obb->R->col1->x = uxX;
HXLINE( 875)					obb->R->col1->y = uxY;
HXLINE( 877)					obb->R->col2->x = uyX;
HXLINE( 878)					obb->R->col2->y = uyY;
HXLINE( 880)					Float centerX = (((Float)0.5) * (lowerX + upperX));
HXLINE( 881)					Float centerY = (((Float)0.5) * (lowerY + upperY));
HXLINE( 883)					 ::box2D::common::math::B2Mat22 tMat = obb->R;
HXLINE( 884)					Float root1 = root->x;
HXDLIN( 884)					Float _hx_tmp = (tMat->col1->x * centerX);
HXDLIN( 884)					obb->center->x = (root1 + (_hx_tmp + (tMat->col2->x * centerY)));
HXLINE( 885)					Float root2 = root->y;
HXDLIN( 885)					Float _hx_tmp1 = (tMat->col1->y * centerX);
HXDLIN( 885)					obb->center->y = (root2 + (_hx_tmp1 + (tMat->col2->y * centerY)));
HXLINE( 887)					obb->extents->x = (((Float)0.5) * (upperX - lowerX));
HXLINE( 888)					obb->extents->y = (((Float)0.5) * (upperY - lowerY));
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(B2PolygonShape_obj,computeOBB,(void))


hx::ObjectPtr< B2PolygonShape_obj > B2PolygonShape_obj::__new() {
	hx::ObjectPtr< B2PolygonShape_obj > __this = new B2PolygonShape_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< B2PolygonShape_obj > B2PolygonShape_obj::__alloc(hx::Ctx *_hx_ctx) {
	B2PolygonShape_obj *__this = (B2PolygonShape_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(B2PolygonShape_obj), true, "box2D.collision.shapes.B2PolygonShape"));
	*(void **)__this = B2PolygonShape_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

B2PolygonShape_obj::B2PolygonShape_obj()
{
}

void B2PolygonShape_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(B2PolygonShape);
	HX_MARK_MEMBER_NAME(m_centroid,"m_centroid");
	HX_MARK_MEMBER_NAME(m_vertices,"m_vertices");
	HX_MARK_MEMBER_NAME(m_normals,"m_normals");
	HX_MARK_MEMBER_NAME(m_vertexCount,"m_vertexCount");
	HX_MARK_END_CLASS();
}

void B2PolygonShape_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(m_centroid,"m_centroid");
	HX_VISIT_MEMBER_NAME(m_vertices,"m_vertices");
	HX_VISIT_MEMBER_NAME(m_normals,"m_normals");
	HX_VISIT_MEMBER_NAME(m_vertexCount,"m_vertexCount");
}

hx::Val B2PolygonShape_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"set") ) { return hx::Val( set_dyn() ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"copy") ) { return hx::Val( copy_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"rayCast") ) { return hx::Val( rayCast_dyn() ); }
		if (HX_FIELD_EQ(inName,"reserve") ) { return hx::Val( reserve_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"setAsBox") ) { return hx::Val( setAsBox_dyn() ); }
		if (HX_FIELD_EQ(inName,"validate") ) { return hx::Val( validate_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"setAsEdge") ) { return hx::Val( setAsEdge_dyn() ); }
		if (HX_FIELD_EQ(inName,"testPoint") ) { return hx::Val( testPoint_dyn() ); }
		if (HX_FIELD_EQ(inName,"m_normals") ) { return hx::Val( m_normals ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"setAsArray") ) { return hx::Val( setAsArray_dyn() ); }
		if (HX_FIELD_EQ(inName,"getNormals") ) { return hx::Val( getNormals_dyn() ); }
		if (HX_FIELD_EQ(inName,"getSupport") ) { return hx::Val( getSupport_dyn() ); }
		if (HX_FIELD_EQ(inName,"m_centroid") ) { return hx::Val( m_centroid ); }
		if (HX_FIELD_EQ(inName,"m_vertices") ) { return hx::Val( m_vertices ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"setAsVector") ) { return hx::Val( setAsVector_dyn() ); }
		if (HX_FIELD_EQ(inName,"computeAABB") ) { return hx::Val( computeAABB_dyn() ); }
		if (HX_FIELD_EQ(inName,"computeMass") ) { return hx::Val( computeMass_dyn() ); }
		if (HX_FIELD_EQ(inName,"getVertices") ) { return hx::Val( getVertices_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"m_vertexCount") ) { return hx::Val( m_vertexCount ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"getVertexCount") ) { return hx::Val( getVertexCount_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"setAsOrientedBox") ) { return hx::Val( setAsOrientedBox_dyn() ); }
		if (HX_FIELD_EQ(inName,"getSupportVertex") ) { return hx::Val( getSupportVertex_dyn() ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"computeSubmergedArea") ) { return hx::Val( computeSubmergedArea_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool B2PolygonShape_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"asBox") ) { outValue = asBox_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"s_mat") ) { outValue = ( s_mat ); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"asEdge") ) { outValue = asEdge_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"asArray") ) { outValue = asArray_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"asVector") ) { outValue = asVector_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"computeOBB") ) { outValue = computeOBB_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"asOrientedBox") ) { outValue = asOrientedBox_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"computeCentroid") ) { outValue = computeCentroid_dyn(); return true; }
	}
	return false;
}

hx::Val B2PolygonShape_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 9:
		if (HX_FIELD_EQ(inName,"m_normals") ) { m_normals=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"m_centroid") ) { m_centroid=inValue.Cast<  ::box2D::common::math::B2Vec2 >(); return inValue; }
		if (HX_FIELD_EQ(inName,"m_vertices") ) { m_vertices=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"m_vertexCount") ) { m_vertexCount=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool B2PolygonShape_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"s_mat") ) { s_mat=ioValue.Cast<  ::box2D::common::math::B2Mat22 >(); return true; }
	}
	return false;
}

void B2PolygonShape_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("m_centroid","\x92","\xe1","\x30","\xbf"));
	outFields->push(HX_HCSTRING("m_vertices","\x4b","\xc1","\x60","\x91"));
	outFields->push(HX_HCSTRING("m_normals","\x5a","\x7f","\x5c","\x36"));
	outFields->push(HX_HCSTRING("m_vertexCount","\xb9","\x2c","\x9e","\x77"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo B2PolygonShape_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::box2D::common::math::B2Vec2*/ ,(int)offsetof(B2PolygonShape_obj,m_centroid),HX_HCSTRING("m_centroid","\x92","\xe1","\x30","\xbf")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(B2PolygonShape_obj,m_vertices),HX_HCSTRING("m_vertices","\x4b","\xc1","\x60","\x91")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(B2PolygonShape_obj,m_normals),HX_HCSTRING("m_normals","\x5a","\x7f","\x5c","\x36")},
	{hx::fsInt,(int)offsetof(B2PolygonShape_obj,m_vertexCount),HX_HCSTRING("m_vertexCount","\xb9","\x2c","\x9e","\x77")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo B2PolygonShape_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*::box2D::common::math::B2Mat22*/ ,(void *) &B2PolygonShape_obj::s_mat,HX_HCSTRING("s_mat","\x94","\x05","\x33","\x76")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String B2PolygonShape_obj_sMemberFields[] = {
	HX_HCSTRING("copy","\xb5","\xbb","\xc4","\x41"),
	HX_HCSTRING("set","\xa2","\x9b","\x57","\x00"),
	HX_HCSTRING("setAsArray","\xc5","\x7f","\x48","\xc8"),
	HX_HCSTRING("setAsVector","\x17","\x85","\x94","\x56"),
	HX_HCSTRING("setAsBox","\x37","\xad","\x48","\x34"),
	HX_HCSTRING("setAsOrientedBox","\x33","\x3a","\x6b","\xdc"),
	HX_HCSTRING("setAsEdge","\x91","\x1f","\x42","\x8d"),
	HX_HCSTRING("testPoint","\x9e","\xf2","\x91","\x8f"),
	HX_HCSTRING("rayCast","\xc9","\x5d","\x3c","\x25"),
	HX_HCSTRING("computeAABB","\x97","\x39","\x7f","\xc2"),
	HX_HCSTRING("computeMass","\x0b","\x3c","\x86","\xca"),
	HX_HCSTRING("computeSubmergedArea","\xe2","\x2f","\x3c","\xaf"),
	HX_HCSTRING("getVertexCount","\xd5","\x61","\x3d","\xe6"),
	HX_HCSTRING("getVertices","\xaf","\x82","\x09","\x90"),
	HX_HCSTRING("getNormals","\x76","\xf6","\x3b","\x7b"),
	HX_HCSTRING("getSupport","\x19","\x92","\x84","\x8c"),
	HX_HCSTRING("getSupportVertex","\x5d","\xfa","\xb2","\xea"),
	HX_HCSTRING("validate","\x96","\xd0","\xe3","\x04"),
	HX_HCSTRING("reserve","\x3c","\x7e","\xc8","\x60"),
	HX_HCSTRING("m_centroid","\x92","\xe1","\x30","\xbf"),
	HX_HCSTRING("m_vertices","\x4b","\xc1","\x60","\x91"),
	HX_HCSTRING("m_normals","\x5a","\x7f","\x5c","\x36"),
	HX_HCSTRING("m_vertexCount","\xb9","\x2c","\x9e","\x77"),
	::String(null()) };

static void B2PolygonShape_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(B2PolygonShape_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(B2PolygonShape_obj::s_mat,"s_mat");
};

#ifdef HXCPP_VISIT_ALLOCS
static void B2PolygonShape_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(B2PolygonShape_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(B2PolygonShape_obj::s_mat,"s_mat");
};

#endif

hx::Class B2PolygonShape_obj::__mClass;

static ::String B2PolygonShape_obj_sStaticFields[] = {
	HX_HCSTRING("asArray","\x47","\x5b","\x69","\x75"),
	HX_HCSTRING("asVector","\x55","\xbb","\x33","\x26"),
	HX_HCSTRING("asBox","\x39","\x44","\x14","\x26"),
	HX_HCSTRING("s_mat","\x94","\x05","\x33","\x76"),
	HX_HCSTRING("asOrientedBox","\x35","\xa3","\x08","\x1c"),
	HX_HCSTRING("asEdge","\x4f","\xaa","\x9a","\x2d"),
	HX_HCSTRING("computeCentroid","\xd7","\xb2","\x66","\x2f"),
	HX_HCSTRING("computeOBB","\xb8","\xa8","\x92","\x34"),
	::String(null())
};

void B2PolygonShape_obj::__register()
{
	hx::Object *dummy = new B2PolygonShape_obj;
	B2PolygonShape_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("box2D.collision.shapes.B2PolygonShape","\x06","\x70","\x6d","\x39");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &B2PolygonShape_obj::__GetStatic;
	__mClass->mSetStaticField = &B2PolygonShape_obj::__SetStatic;
	__mClass->mMarkFunc = B2PolygonShape_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(B2PolygonShape_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(B2PolygonShape_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< B2PolygonShape_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = B2PolygonShape_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = B2PolygonShape_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = B2PolygonShape_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void B2PolygonShape_obj::__boot()
{
{
            	HX_GC_STACKFRAME(&_hx_pos_102b8b1a357996ba_164_boot)
HXDLIN( 164)		s_mat =  ::box2D::common::math::B2Mat22_obj::__alloc( HX_CTX );
            	}
}

} // end namespace box2D
} // end namespace collision
} // end namespace shapes
