// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_box2D_collision_B2DistanceProxy
#include <box2D/collision/B2DistanceProxy.h>
#endif
#ifndef INCLUDED_box2D_collision_B2SeparationFunction
#include <box2D/collision/B2SeparationFunction.h>
#endif
#ifndef INCLUDED_box2D_collision_B2SimplexCache
#include <box2D/collision/B2SimplexCache.h>
#endif
#ifndef INCLUDED_box2D_common_B2Settings
#include <box2D/common/B2Settings.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Mat22
#include <box2D/common/math/B2Mat22.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Math
#include <box2D/common/math/B2Math.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Transform
#include <box2D/common/math/B2Transform.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Vec2
#include <box2D/common/math/B2Vec2.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_f708788e04686fe9_324_new,"box2D.collision.B2SeparationFunction","new",0x092307ed,"box2D.collision.B2SeparationFunction.new","box2D/collision/B2SeparationFunction.hx",324,0x4bd3d121)
HX_LOCAL_STACK_FRAME(_hx_pos_f708788e04686fe9_39_initialize,"box2D.collision.B2SeparationFunction","initialize",0x8319b563,"box2D.collision.B2SeparationFunction.initialize","box2D/collision/B2SeparationFunction.hx",39,0x4bd3d121)
HX_LOCAL_STACK_FRAME(_hx_pos_f708788e04686fe9_262_evaluate,"box2D.collision.B2SeparationFunction","evaluate",0xab4ba9ac,"box2D.collision.B2SeparationFunction.evaluate","box2D/collision/B2SeparationFunction.hx",262,0x4bd3d121)
HX_LOCAL_STACK_FRAME(_hx_pos_f708788e04686fe9_32_boot,"box2D.collision.B2SeparationFunction","boot",0xed9ce805,"box2D.collision.B2SeparationFunction.boot","box2D/collision/B2SeparationFunction.hx",32,0x4bd3d121)
HX_LOCAL_STACK_FRAME(_hx_pos_f708788e04686fe9_33_boot,"box2D.collision.B2SeparationFunction","boot",0xed9ce805,"box2D.collision.B2SeparationFunction.boot","box2D/collision/B2SeparationFunction.hx",33,0x4bd3d121)
HX_LOCAL_STACK_FRAME(_hx_pos_f708788e04686fe9_34_boot,"box2D.collision.B2SeparationFunction","boot",0xed9ce805,"box2D.collision.B2SeparationFunction.boot","box2D/collision/B2SeparationFunction.hx",34,0x4bd3d121)
namespace box2D{
namespace collision{

void B2SeparationFunction_obj::__construct(){
            	HX_GC_STACKFRAME(&_hx_pos_f708788e04686fe9_324_new)
HXLINE( 326)		this->m_localPoint =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 327)		this->m_axis =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
            	}

Dynamic B2SeparationFunction_obj::__CreateEmpty() { return new B2SeparationFunction_obj; }

void *B2SeparationFunction_obj::_hx_vtable = 0;

Dynamic B2SeparationFunction_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< B2SeparationFunction_obj > _hx_result = new B2SeparationFunction_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool B2SeparationFunction_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x65410803;
}

void B2SeparationFunction_obj::initialize( ::box2D::collision::B2SimplexCache cache, ::box2D::collision::B2DistanceProxy proxyA, ::box2D::common::math::B2Transform transformA, ::box2D::collision::B2DistanceProxy proxyB, ::box2D::common::math::B2Transform transformB){
            	HX_GC_STACKFRAME(&_hx_pos_f708788e04686fe9_39_initialize)
HXLINE(  40)		this->m_proxyA = proxyA;
HXLINE(  41)		this->m_proxyB = proxyB;
HXLINE(  42)		int count = cache->count;
HXLINE(  43)		bool _hx_tmp;
HXDLIN(  43)		if (((int)0 < count)) {
HXLINE(  43)			_hx_tmp = (count < (int)3);
            		}
            		else {
HXLINE(  43)			_hx_tmp = false;
            		}
HXDLIN(  43)		::box2D::common::B2Settings_obj::b2Assert(_hx_tmp);
HXLINE(  45)		 ::box2D::common::math::B2Vec2 localPointA =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
HXLINE(  46)		 ::box2D::common::math::B2Vec2 localPointA1;
HXLINE(  47)		 ::box2D::common::math::B2Vec2 localPointA2;
HXLINE(  48)		 ::box2D::common::math::B2Vec2 localPointB =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
HXLINE(  49)		 ::box2D::common::math::B2Vec2 localPointB1;
HXLINE(  50)		 ::box2D::common::math::B2Vec2 localPointB2;
HXLINE(  51)		Float pointAX;
HXLINE(  52)		Float pointAY;
HXLINE(  53)		Float pointBX;
HXLINE(  54)		Float pointBY;
HXLINE(  55)		Float normalX;
HXLINE(  56)		Float normalY;
HXLINE(  57)		 ::box2D::common::math::B2Mat22 tMat;
HXLINE(  58)		 ::box2D::common::math::B2Vec2 tVec;
HXLINE(  59)		Float s;
HXLINE(  60)		Float sgn;
HXLINE(  62)		if ((count == (int)1)) {
HXLINE(  64)			this->m_type = ::box2D::collision::B2SeparationFunction_obj::e_points;
HXLINE(  65)			 ::box2D::collision::B2DistanceProxy localPointA3 = this->m_proxyA;
HXDLIN(  65)			localPointA = localPointA3->getVertex(cache->indexA->__get((int)0));
HXLINE(  66)			 ::box2D::collision::B2DistanceProxy localPointB3 = this->m_proxyB;
HXDLIN(  66)			localPointB = localPointB3->getVertex(cache->indexB->__get((int)0));
HXLINE(  68)			tVec = localPointA;
HXLINE(  69)			tMat = transformA->R;
HXLINE(  70)			Float transformA1 = transformA->position->x;
HXDLIN(  70)			Float pointAX1 = (tMat->col1->x * tVec->x);
HXDLIN(  70)			pointAX = (transformA1 + (pointAX1 + (tMat->col2->x * tVec->y)));
HXLINE(  71)			Float transformA2 = transformA->position->y;
HXDLIN(  71)			Float pointAY1 = (tMat->col1->y * tVec->x);
HXDLIN(  71)			pointAY = (transformA2 + (pointAY1 + (tMat->col2->y * tVec->y)));
HXLINE(  73)			tVec = localPointB;
HXLINE(  74)			tMat = transformB->R;
HXLINE(  75)			Float transformB1 = transformB->position->x;
HXDLIN(  75)			Float pointBX1 = (tMat->col1->x * tVec->x);
HXDLIN(  75)			pointBX = (transformB1 + (pointBX1 + (tMat->col2->x * tVec->y)));
HXLINE(  76)			Float transformB2 = transformB->position->y;
HXDLIN(  76)			Float pointBY1 = (tMat->col1->y * tVec->x);
HXDLIN(  76)			pointBY = (transformB2 + (pointBY1 + (tMat->col2->y * tVec->y)));
HXLINE(  78)			this->m_axis->x = (pointBX - pointAX);
HXLINE(  79)			this->m_axis->y = (pointBY - pointAY);
HXLINE(  80)			this->m_axis->normalize();
            		}
            		else {
HXLINE(  82)			int cache1 = cache->indexB->__get((int)0);
HXDLIN(  82)			if ((cache1 == cache->indexB->__get((int)1))) {
HXLINE(  85)				this->m_type = ::box2D::collision::B2SeparationFunction_obj::e_faceA;
HXLINE(  86)				 ::box2D::collision::B2DistanceProxy localPointA11 = this->m_proxyA;
HXDLIN(  86)				localPointA1 = localPointA11->getVertex(cache->indexA->__get((int)0));
HXLINE(  87)				 ::box2D::collision::B2DistanceProxy localPointA21 = this->m_proxyA;
HXDLIN(  87)				localPointA2 = localPointA21->getVertex(cache->indexA->__get((int)1));
HXLINE(  88)				 ::box2D::collision::B2DistanceProxy localPointB4 = this->m_proxyB;
HXDLIN(  88)				localPointB = localPointB4->getVertex(cache->indexB->__get((int)0));
HXLINE(  89)				this->m_localPoint->x = (((Float)0.5) * (localPointA1->x + localPointA2->x));
HXLINE(  90)				this->m_localPoint->y = (((Float)0.5) * (localPointA1->y + localPointA2->y));
HXLINE(  91)				this->m_axis = ::box2D::common::math::B2Math_obj::crossVF(::box2D::common::math::B2Math_obj::subtractVV(localPointA2,localPointA1),((Float)1.0),null());
HXLINE(  92)				this->m_axis->normalize();
HXLINE(  95)				tVec = this->m_axis;
HXLINE(  96)				tMat = transformA->R;
HXLINE(  97)				Float normalX1 = (tMat->col1->x * tVec->x);
HXDLIN(  97)				normalX = (normalX1 + (tMat->col2->x * tVec->y));
HXLINE(  98)				Float normalY1 = (tMat->col1->y * tVec->x);
HXDLIN(  98)				normalY = (normalY1 + (tMat->col2->y * tVec->y));
HXLINE( 100)				tVec = this->m_localPoint;
HXLINE( 101)				tMat = transformA->R;
HXLINE( 102)				Float transformA3 = transformA->position->x;
HXDLIN( 102)				Float pointAX2 = (tMat->col1->x * tVec->x);
HXDLIN( 102)				pointAX = (transformA3 + (pointAX2 + (tMat->col2->x * tVec->y)));
HXLINE( 103)				Float transformA4 = transformA->position->y;
HXDLIN( 103)				Float pointAY2 = (tMat->col1->y * tVec->x);
HXDLIN( 103)				pointAY = (transformA4 + (pointAY2 + (tMat->col2->y * tVec->y)));
HXLINE( 105)				tVec = localPointB;
HXLINE( 106)				tMat = transformB->R;
HXLINE( 107)				Float transformB3 = transformB->position->x;
HXDLIN( 107)				Float pointBX2 = (tMat->col1->x * tVec->x);
HXDLIN( 107)				pointBX = (transformB3 + (pointBX2 + (tMat->col2->x * tVec->y)));
HXLINE( 108)				Float transformB4 = transformB->position->y;
HXDLIN( 108)				Float pointBY2 = (tMat->col1->y * tVec->x);
HXDLIN( 108)				pointBY = (transformB4 + (pointBY2 + (tMat->col2->y * tVec->y)));
HXLINE( 111)				s = (((pointBX - pointAX) * normalX) + ((pointBY - pointAY) * normalY));
HXLINE( 112)				if ((s < ((Float)0.0))) {
HXLINE( 114)					 ::box2D::common::math::B2Vec2 _this = this->m_axis;
HXDLIN( 114)					_this->x = -(_this->x);
HXDLIN( 114)					_this->y = -(_this->y);
            				}
            			}
            			else {
HXLINE( 117)				int cache2 = cache->indexA->__get((int)0);
HXDLIN( 117)				if ((cache2 == cache->indexA->__get((int)0))) {
HXLINE( 120)					this->m_type = ::box2D::collision::B2SeparationFunction_obj::e_faceB;
HXLINE( 121)					 ::box2D::collision::B2DistanceProxy localPointB11 = this->m_proxyB;
HXDLIN( 121)					localPointB1 = localPointB11->getVertex(cache->indexB->__get((int)0));
HXLINE( 122)					 ::box2D::collision::B2DistanceProxy localPointB21 = this->m_proxyB;
HXDLIN( 122)					localPointB2 = localPointB21->getVertex(cache->indexB->__get((int)1));
HXLINE( 123)					 ::box2D::collision::B2DistanceProxy localPointA4 = this->m_proxyA;
HXDLIN( 123)					localPointA = localPointA4->getVertex(cache->indexA->__get((int)0));
HXLINE( 124)					this->m_localPoint->x = (((Float)0.5) * (localPointB1->x + localPointB2->x));
HXLINE( 125)					this->m_localPoint->y = (((Float)0.5) * (localPointB1->y + localPointB2->y));
HXLINE( 126)					this->m_axis = ::box2D::common::math::B2Math_obj::crossVF(::box2D::common::math::B2Math_obj::subtractVV(localPointB2,localPointB1),((Float)1.0),null());
HXLINE( 127)					this->m_axis->normalize();
HXLINE( 130)					tVec = this->m_axis;
HXLINE( 131)					tMat = transformB->R;
HXLINE( 132)					Float normalX2 = (tMat->col1->x * tVec->x);
HXDLIN( 132)					normalX = (normalX2 + (tMat->col2->x * tVec->y));
HXLINE( 133)					Float normalY2 = (tMat->col1->y * tVec->x);
HXDLIN( 133)					normalY = (normalY2 + (tMat->col2->y * tVec->y));
HXLINE( 135)					tVec = this->m_localPoint;
HXLINE( 136)					tMat = transformB->R;
HXLINE( 137)					Float transformB5 = transformB->position->x;
HXDLIN( 137)					Float pointBX3 = (tMat->col1->x * tVec->x);
HXDLIN( 137)					pointBX = (transformB5 + (pointBX3 + (tMat->col2->x * tVec->y)));
HXLINE( 138)					Float transformB6 = transformB->position->y;
HXDLIN( 138)					Float pointBY3 = (tMat->col1->y * tVec->x);
HXDLIN( 138)					pointBY = (transformB6 + (pointBY3 + (tMat->col2->y * tVec->y)));
HXLINE( 140)					tVec = localPointA;
HXLINE( 141)					tMat = transformA->R;
HXLINE( 142)					Float transformA5 = transformA->position->x;
HXDLIN( 142)					Float pointAX3 = (tMat->col1->x * tVec->x);
HXDLIN( 142)					pointAX = (transformA5 + (pointAX3 + (tMat->col2->x * tVec->y)));
HXLINE( 143)					Float transformA6 = transformA->position->y;
HXDLIN( 143)					Float pointAY3 = (tMat->col1->y * tVec->x);
HXDLIN( 143)					pointAY = (transformA6 + (pointAY3 + (tMat->col2->y * tVec->y)));
HXLINE( 146)					s = (((pointAX - pointBX) * normalX) + ((pointAY - pointBY) * normalY));
HXLINE( 147)					if ((s < ((Float)0.0))) {
HXLINE( 149)						 ::box2D::common::math::B2Vec2 _this1 = this->m_axis;
HXDLIN( 149)						_this1->x = -(_this1->x);
HXDLIN( 149)						_this1->y = -(_this1->y);
            					}
            				}
            				else {
HXLINE( 156)					 ::box2D::collision::B2DistanceProxy localPointA12 = this->m_proxyA;
HXDLIN( 156)					localPointA1 = localPointA12->getVertex(cache->indexA->__get((int)0));
HXLINE( 157)					 ::box2D::collision::B2DistanceProxy localPointA22 = this->m_proxyA;
HXDLIN( 157)					localPointA2 = localPointA22->getVertex(cache->indexA->__get((int)1));
HXLINE( 158)					 ::box2D::collision::B2DistanceProxy localPointB12 = this->m_proxyB;
HXDLIN( 158)					localPointB1 = localPointB12->getVertex(cache->indexB->__get((int)0));
HXLINE( 159)					 ::box2D::collision::B2DistanceProxy localPointB22 = this->m_proxyB;
HXDLIN( 159)					localPointB2 = localPointB22->getVertex(cache->indexB->__get((int)1));
HXLINE( 161)					 ::box2D::common::math::B2Vec2 pA = ::box2D::common::math::B2Math_obj::mulX(transformA,localPointA,true);
HXLINE( 162)					 ::box2D::common::math::B2Mat22 transformA7 = transformA->R;
HXDLIN( 162)					 ::box2D::common::math::B2Vec2 dA = ::box2D::common::math::B2Math_obj::mulMV(transformA7,::box2D::common::math::B2Math_obj::subtractVVPooled(localPointA2,localPointA1),true);
HXLINE( 163)					 ::box2D::common::math::B2Vec2 pB = ::box2D::common::math::B2Math_obj::mulX(transformB,localPointB,true);
HXLINE( 164)					 ::box2D::common::math::B2Mat22 transformB7 = transformB->R;
HXDLIN( 164)					 ::box2D::common::math::B2Vec2 dB = ::box2D::common::math::B2Math_obj::mulMV(transformB7,::box2D::common::math::B2Math_obj::subtractVVPooled(localPointB2,localPointB1),true);
HXLINE( 166)					Float a = (dA->x * dA->x);
HXDLIN( 166)					Float a1 = (a + (dA->y * dA->y));
HXLINE( 167)					Float e = (dB->x * dB->x);
HXDLIN( 167)					Float e1 = (e + (dB->y * dB->y));
HXLINE( 168)					 ::box2D::common::math::B2Vec2 r = ::box2D::common::math::B2Math_obj::subtractVVPooled(dB,dA);
HXLINE( 169)					Float c = (dA->x * r->x);
HXDLIN( 169)					Float c1 = (c + (dA->y * r->y));
HXLINE( 170)					Float f = (dB->x * r->x);
HXDLIN( 170)					Float f1 = (f + (dB->y * r->y));
HXLINE( 172)					Float b = (dA->x * dB->x);
HXDLIN( 172)					Float b1 = (b + (dA->y * dB->y));
HXLINE( 173)					Float denom = ((a1 * e1) - (b1 * b1));
HXLINE( 175)					s = ((Float)0.0);
HXLINE( 176)					if ((denom != ((Float)0.0))) {
HXLINE( 178)						s = ::box2D::common::math::B2Math_obj::clamp(((Float)((b1 * f1) - (c1 * e1)) / (Float)denom),((Float)0.0),((Float)1.0));
            					}
HXLINE( 181)					Float t = ((Float)((b1 * s) + f1) / (Float)e1);
HXLINE( 182)					if ((t < ((Float)0.0))) {
HXLINE( 184)						t = ((Float)0.0);
HXLINE( 185)						s = ::box2D::common::math::B2Math_obj::clamp(((Float)(b1 - c1) / (Float)a1),((Float)0.0),((Float)1.0));
            					}
HXLINE( 189)					localPointA =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 190)					Float localPointA13 = localPointA1->x;
HXDLIN( 190)					localPointA->x = (localPointA13 + (s * (localPointA2->x - localPointA1->x)));
HXLINE( 191)					Float localPointA14 = localPointA1->y;
HXDLIN( 191)					localPointA->y = (localPointA14 + (s * (localPointA2->y - localPointA1->y)));
HXLINE( 193)					localPointB =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 194)					Float localPointB13 = localPointB1->x;
HXDLIN( 194)					localPointB->x = (localPointB13 + (s * (localPointB2->x - localPointB1->x)));
HXLINE( 195)					Float localPointB14 = localPointB1->y;
HXDLIN( 195)					localPointB->y = (localPointB14 + (s * (localPointB2->y - localPointB1->y)));
HXLINE( 197)					bool _hx_tmp1;
HXDLIN( 197)					if ((s != ((Float)0.0))) {
HXLINE( 197)						_hx_tmp1 = (s == ((Float)1.0));
            					}
            					else {
HXLINE( 197)						_hx_tmp1 = true;
            					}
HXDLIN( 197)					if (_hx_tmp1) {
HXLINE( 199)						this->m_type = ::box2D::collision::B2SeparationFunction_obj::e_faceB;
HXLINE( 200)						this->m_axis = ::box2D::common::math::B2Math_obj::crossVF(::box2D::common::math::B2Math_obj::subtractVV(localPointB2,localPointB1),((Float)1.0),null());
HXLINE( 201)						this->m_axis->normalize();
HXLINE( 203)						this->m_localPoint = localPointB;
HXLINE( 206)						tVec = this->m_axis;
HXLINE( 207)						tMat = transformB->R;
HXLINE( 208)						Float normalX3 = (tMat->col1->x * tVec->x);
HXDLIN( 208)						normalX = (normalX3 + (tMat->col2->x * tVec->y));
HXLINE( 209)						Float normalY3 = (tMat->col1->y * tVec->x);
HXDLIN( 209)						normalY = (normalY3 + (tMat->col2->y * tVec->y));
HXLINE( 211)						tVec = this->m_localPoint;
HXLINE( 212)						tMat = transformB->R;
HXLINE( 213)						Float transformB8 = transformB->position->x;
HXDLIN( 213)						Float pointBX4 = (tMat->col1->x * tVec->x);
HXDLIN( 213)						pointBX = (transformB8 + (pointBX4 + (tMat->col2->x * tVec->y)));
HXLINE( 214)						Float transformB9 = transformB->position->y;
HXDLIN( 214)						Float pointBY4 = (tMat->col1->y * tVec->x);
HXDLIN( 214)						pointBY = (transformB9 + (pointBY4 + (tMat->col2->y * tVec->y)));
HXLINE( 216)						tVec = localPointA;
HXLINE( 217)						tMat = transformA->R;
HXLINE( 218)						Float transformA8 = transformA->position->x;
HXDLIN( 218)						Float pointAX4 = (tMat->col1->x * tVec->x);
HXDLIN( 218)						pointAX = (transformA8 + (pointAX4 + (tMat->col2->x * tVec->y)));
HXLINE( 219)						Float transformA9 = transformA->position->y;
HXDLIN( 219)						Float pointAY4 = (tMat->col1->y * tVec->x);
HXDLIN( 219)						pointAY = (transformA9 + (pointAY4 + (tMat->col2->y * tVec->y)));
HXLINE( 222)						sgn = (((pointAX - pointBX) * normalX) + ((pointAY - pointBY) * normalY));
HXLINE( 223)						if ((s < ((Float)0.0))) {
HXLINE( 225)							 ::box2D::common::math::B2Vec2 _this2 = this->m_axis;
HXDLIN( 225)							_this2->x = -(_this2->x);
HXDLIN( 225)							_this2->y = -(_this2->y);
            						}
            					}
            					else {
HXLINE( 230)						this->m_type = ::box2D::collision::B2SeparationFunction_obj::e_faceA;
HXLINE( 231)						this->m_axis = ::box2D::common::math::B2Math_obj::crossVF(::box2D::common::math::B2Math_obj::subtractVV(localPointA2,localPointA1),((Float)1.0),null());
HXLINE( 233)						this->m_localPoint = localPointA;
HXLINE( 236)						tVec = this->m_axis;
HXLINE( 237)						tMat = transformA->R;
HXLINE( 238)						Float normalX4 = (tMat->col1->x * tVec->x);
HXDLIN( 238)						normalX = (normalX4 + (tMat->col2->x * tVec->y));
HXLINE( 239)						Float normalY4 = (tMat->col1->y * tVec->x);
HXDLIN( 239)						normalY = (normalY4 + (tMat->col2->y * tVec->y));
HXLINE( 241)						tVec = this->m_localPoint;
HXLINE( 242)						tMat = transformA->R;
HXLINE( 243)						Float transformA10 = transformA->position->x;
HXDLIN( 243)						Float pointAX5 = (tMat->col1->x * tVec->x);
HXDLIN( 243)						pointAX = (transformA10 + (pointAX5 + (tMat->col2->x * tVec->y)));
HXLINE( 244)						Float transformA11 = transformA->position->y;
HXDLIN( 244)						Float pointAY5 = (tMat->col1->y * tVec->x);
HXDLIN( 244)						pointAY = (transformA11 + (pointAY5 + (tMat->col2->y * tVec->y)));
HXLINE( 246)						tVec = localPointB;
HXLINE( 247)						tMat = transformB->R;
HXLINE( 248)						Float transformB10 = transformB->position->x;
HXDLIN( 248)						Float pointBX5 = (tMat->col1->x * tVec->x);
HXDLIN( 248)						pointBX = (transformB10 + (pointBX5 + (tMat->col2->x * tVec->y)));
HXLINE( 249)						Float transformB11 = transformB->position->y;
HXDLIN( 249)						Float pointBY5 = (tMat->col1->y * tVec->x);
HXDLIN( 249)						pointBY = (transformB11 + (pointBY5 + (tMat->col2->y * tVec->y)));
HXLINE( 252)						sgn = (((pointBX - pointAX) * normalX) + ((pointBY - pointAY) * normalY));
HXLINE( 253)						if ((s < ((Float)0.0))) {
HXLINE( 255)							 ::box2D::common::math::B2Vec2 _this3 = this->m_axis;
HXDLIN( 255)							_this3->x = -(_this3->x);
HXDLIN( 255)							_this3->y = -(_this3->y);
            						}
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC5(B2SeparationFunction_obj,initialize,(void))

Float B2SeparationFunction_obj::evaluate( ::box2D::common::math::B2Transform transformA, ::box2D::common::math::B2Transform transformB){
            	HX_STACKFRAME(&_hx_pos_f708788e04686fe9_262_evaluate)
HXLINE( 263)		 ::box2D::common::math::B2Vec2 axisA;
HXLINE( 264)		 ::box2D::common::math::B2Vec2 axisB;
HXLINE( 265)		 ::box2D::common::math::B2Vec2 localPointA;
HXLINE( 266)		 ::box2D::common::math::B2Vec2 localPointB;
HXLINE( 267)		 ::box2D::common::math::B2Vec2 pointA;
HXLINE( 268)		 ::box2D::common::math::B2Vec2 pointB;
HXLINE( 269)		Float seperation;
HXLINE( 270)		 ::box2D::common::math::B2Vec2 normal;
HXLINE( 272)		if ((this->m_type == ::box2D::collision::B2SeparationFunction_obj::e_points)) {
HXLINE( 274)			axisA = ::box2D::common::math::B2Math_obj::mulTMV(transformA->R,this->m_axis,true);
HXLINE( 275)			 ::box2D::common::math::B2Mat22 transformB1 = transformB->R;
HXDLIN( 275)			axisB = ::box2D::common::math::B2Math_obj::mulTMV(transformB1,this->m_axis->getNegativePooled(),true);
HXLINE( 276)			localPointA = this->m_proxyA->getSupportVertex(axisA);
HXLINE( 277)			localPointB = this->m_proxyB->getSupportVertex(axisB);
HXLINE( 278)			pointA = ::box2D::common::math::B2Math_obj::mulX(transformA,localPointA,true);
HXLINE( 279)			pointB = ::box2D::common::math::B2Math_obj::mulX(transformB,localPointB,true);
HXLINE( 281)			Float seperation1 = ((pointB->x - pointA->x) * this->m_axis->x);
HXDLIN( 281)			seperation = (seperation1 + ((pointB->y - pointA->y) * this->m_axis->y));
HXLINE( 282)			return seperation;
            		}
            		else {
HXLINE( 285)			if ((this->m_type == ::box2D::collision::B2SeparationFunction_obj::e_faceA)) {
HXLINE( 287)				normal = ::box2D::common::math::B2Math_obj::mulMV(transformA->R,this->m_axis,true);
HXLINE( 288)				pointA = ::box2D::common::math::B2Math_obj::mulX(transformA,this->m_localPoint,true);
HXLINE( 290)				 ::box2D::common::math::B2Mat22 transformB2 = transformB->R;
HXDLIN( 290)				axisB = ::box2D::common::math::B2Math_obj::mulTMV(transformB2,normal->getNegativePooled(),null());
HXLINE( 292)				localPointB = this->m_proxyB->getSupportVertex(axisB);
HXLINE( 293)				pointB = ::box2D::common::math::B2Math_obj::mulX(transformB,localPointB,true);
HXLINE( 296)				Float seperation2 = ((pointB->x - pointA->x) * normal->x);
HXDLIN( 296)				seperation = (seperation2 + ((pointB->y - pointA->y) * normal->y));
HXLINE( 297)				return seperation;
            			}
            			else {
HXLINE( 300)				if ((this->m_type == ::box2D::collision::B2SeparationFunction_obj::e_faceB)) {
HXLINE( 302)					normal = ::box2D::common::math::B2Math_obj::mulMV(transformB->R,this->m_axis,true);
HXLINE( 303)					pointB = ::box2D::common::math::B2Math_obj::mulX(transformB,this->m_localPoint,true);
HXLINE( 305)					 ::box2D::common::math::B2Mat22 transformA1 = transformA->R;
HXDLIN( 305)					axisA = ::box2D::common::math::B2Math_obj::mulTMV(transformA1,normal->getNegativePooled(),true);
HXLINE( 307)					localPointA = this->m_proxyA->getSupportVertex(axisA);
HXLINE( 308)					pointA = ::box2D::common::math::B2Math_obj::mulX(transformA,localPointA,true);
HXLINE( 311)					Float seperation3 = ((pointA->x - pointB->x) * normal->x);
HXDLIN( 311)					seperation = (seperation3 + ((pointA->y - pointB->y) * normal->y));
HXLINE( 312)					return seperation;
            				}
            				else {
HXLINE( 317)					::box2D::common::B2Settings_obj::b2Assert(false);
HXLINE( 318)					return ((Float)0.0);
            				}
            			}
            		}
HXLINE( 272)		return ((Float)0.);
            	}


HX_DEFINE_DYNAMIC_FUNC2(B2SeparationFunction_obj,evaluate,return )

int B2SeparationFunction_obj::e_points;

int B2SeparationFunction_obj::e_faceA;

int B2SeparationFunction_obj::e_faceB;


hx::ObjectPtr< B2SeparationFunction_obj > B2SeparationFunction_obj::__new() {
	hx::ObjectPtr< B2SeparationFunction_obj > __this = new B2SeparationFunction_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< B2SeparationFunction_obj > B2SeparationFunction_obj::__alloc(hx::Ctx *_hx_ctx) {
	B2SeparationFunction_obj *__this = (B2SeparationFunction_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(B2SeparationFunction_obj), true, "box2D.collision.B2SeparationFunction"));
	*(void **)__this = B2SeparationFunction_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

B2SeparationFunction_obj::B2SeparationFunction_obj()
{
}

void B2SeparationFunction_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(B2SeparationFunction);
	HX_MARK_MEMBER_NAME(m_proxyA,"m_proxyA");
	HX_MARK_MEMBER_NAME(m_proxyB,"m_proxyB");
	HX_MARK_MEMBER_NAME(m_type,"m_type");
	HX_MARK_MEMBER_NAME(m_localPoint,"m_localPoint");
	HX_MARK_MEMBER_NAME(m_axis,"m_axis");
	HX_MARK_END_CLASS();
}

void B2SeparationFunction_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(m_proxyA,"m_proxyA");
	HX_VISIT_MEMBER_NAME(m_proxyB,"m_proxyB");
	HX_VISIT_MEMBER_NAME(m_type,"m_type");
	HX_VISIT_MEMBER_NAME(m_localPoint,"m_localPoint");
	HX_VISIT_MEMBER_NAME(m_axis,"m_axis");
}

hx::Val B2SeparationFunction_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"m_type") ) { return hx::Val( m_type ); }
		if (HX_FIELD_EQ(inName,"m_axis") ) { return hx::Val( m_axis ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"evaluate") ) { return hx::Val( evaluate_dyn() ); }
		if (HX_FIELD_EQ(inName,"m_proxyA") ) { return hx::Val( m_proxyA ); }
		if (HX_FIELD_EQ(inName,"m_proxyB") ) { return hx::Val( m_proxyB ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"initialize") ) { return hx::Val( initialize_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"m_localPoint") ) { return hx::Val( m_localPoint ); }
	}
	return super::__Field(inName,inCallProp);
}

bool B2SeparationFunction_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"e_faceA") ) { outValue = ( e_faceA ); return true; }
		if (HX_FIELD_EQ(inName,"e_faceB") ) { outValue = ( e_faceB ); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"e_points") ) { outValue = ( e_points ); return true; }
	}
	return false;
}

hx::Val B2SeparationFunction_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"m_type") ) { m_type=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"m_axis") ) { m_axis=inValue.Cast<  ::box2D::common::math::B2Vec2 >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"m_proxyA") ) { m_proxyA=inValue.Cast<  ::box2D::collision::B2DistanceProxy >(); return inValue; }
		if (HX_FIELD_EQ(inName,"m_proxyB") ) { m_proxyB=inValue.Cast<  ::box2D::collision::B2DistanceProxy >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"m_localPoint") ) { m_localPoint=inValue.Cast<  ::box2D::common::math::B2Vec2 >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool B2SeparationFunction_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"e_faceA") ) { e_faceA=ioValue.Cast< int >(); return true; }
		if (HX_FIELD_EQ(inName,"e_faceB") ) { e_faceB=ioValue.Cast< int >(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"e_points") ) { e_points=ioValue.Cast< int >(); return true; }
	}
	return false;
}

void B2SeparationFunction_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("m_proxyA","\xe5","\x5a","\x52","\x7e"));
	outFields->push(HX_HCSTRING("m_proxyB","\xe6","\x5a","\x52","\x7e"));
	outFields->push(HX_HCSTRING("m_type","\x0c","\x63","\x00","\x95"));
	outFields->push(HX_HCSTRING("m_localPoint","\xb7","\xd0","\x8e","\xcf"));
	outFields->push(HX_HCSTRING("m_axis","\xf3","\x8c","\x70","\x88"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo B2SeparationFunction_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::box2D::collision::B2DistanceProxy*/ ,(int)offsetof(B2SeparationFunction_obj,m_proxyA),HX_HCSTRING("m_proxyA","\xe5","\x5a","\x52","\x7e")},
	{hx::fsObject /*::box2D::collision::B2DistanceProxy*/ ,(int)offsetof(B2SeparationFunction_obj,m_proxyB),HX_HCSTRING("m_proxyB","\xe6","\x5a","\x52","\x7e")},
	{hx::fsInt,(int)offsetof(B2SeparationFunction_obj,m_type),HX_HCSTRING("m_type","\x0c","\x63","\x00","\x95")},
	{hx::fsObject /*::box2D::common::math::B2Vec2*/ ,(int)offsetof(B2SeparationFunction_obj,m_localPoint),HX_HCSTRING("m_localPoint","\xb7","\xd0","\x8e","\xcf")},
	{hx::fsObject /*::box2D::common::math::B2Vec2*/ ,(int)offsetof(B2SeparationFunction_obj,m_axis),HX_HCSTRING("m_axis","\xf3","\x8c","\x70","\x88")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo B2SeparationFunction_obj_sStaticStorageInfo[] = {
	{hx::fsInt,(void *) &B2SeparationFunction_obj::e_points,HX_HCSTRING("e_points","\xfd","\x29","\x8c","\xf6")},
	{hx::fsInt,(void *) &B2SeparationFunction_obj::e_faceA,HX_HCSTRING("e_faceA","\x6a","\x76","\x27","\x5f")},
	{hx::fsInt,(void *) &B2SeparationFunction_obj::e_faceB,HX_HCSTRING("e_faceB","\x6b","\x76","\x27","\x5f")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String B2SeparationFunction_obj_sMemberFields[] = {
	HX_HCSTRING("initialize","\x50","\x31","\xbb","\xec"),
	HX_HCSTRING("evaluate","\x59","\x60","\x50","\x01"),
	HX_HCSTRING("m_proxyA","\xe5","\x5a","\x52","\x7e"),
	HX_HCSTRING("m_proxyB","\xe6","\x5a","\x52","\x7e"),
	HX_HCSTRING("m_type","\x0c","\x63","\x00","\x95"),
	HX_HCSTRING("m_localPoint","\xb7","\xd0","\x8e","\xcf"),
	HX_HCSTRING("m_axis","\xf3","\x8c","\x70","\x88"),
	::String(null()) };

static void B2SeparationFunction_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(B2SeparationFunction_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(B2SeparationFunction_obj::e_points,"e_points");
	HX_MARK_MEMBER_NAME(B2SeparationFunction_obj::e_faceA,"e_faceA");
	HX_MARK_MEMBER_NAME(B2SeparationFunction_obj::e_faceB,"e_faceB");
};

#ifdef HXCPP_VISIT_ALLOCS
static void B2SeparationFunction_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(B2SeparationFunction_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(B2SeparationFunction_obj::e_points,"e_points");
	HX_VISIT_MEMBER_NAME(B2SeparationFunction_obj::e_faceA,"e_faceA");
	HX_VISIT_MEMBER_NAME(B2SeparationFunction_obj::e_faceB,"e_faceB");
};

#endif

hx::Class B2SeparationFunction_obj::__mClass;

static ::String B2SeparationFunction_obj_sStaticFields[] = {
	HX_HCSTRING("e_points","\xfd","\x29","\x8c","\xf6"),
	HX_HCSTRING("e_faceA","\x6a","\x76","\x27","\x5f"),
	HX_HCSTRING("e_faceB","\x6b","\x76","\x27","\x5f"),
	::String(null())
};

void B2SeparationFunction_obj::__register()
{
	hx::Object *dummy = new B2SeparationFunction_obj;
	B2SeparationFunction_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("box2D.collision.B2SeparationFunction","\x7b","\x8d","\xd3","\x32");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &B2SeparationFunction_obj::__GetStatic;
	__mClass->mSetStaticField = &B2SeparationFunction_obj::__SetStatic;
	__mClass->mMarkFunc = B2SeparationFunction_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(B2SeparationFunction_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(B2SeparationFunction_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< B2SeparationFunction_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = B2SeparationFunction_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = B2SeparationFunction_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = B2SeparationFunction_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void B2SeparationFunction_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_f708788e04686fe9_32_boot)
HXDLIN(  32)		e_points = (int)1;
            	}
{
            	HX_STACKFRAME(&_hx_pos_f708788e04686fe9_33_boot)
HXDLIN(  33)		e_faceA = (int)2;
            	}
{
            	HX_STACKFRAME(&_hx_pos_f708788e04686fe9_34_boot)
HXDLIN(  34)		e_faceB = (int)4;
            	}
}

} // end namespace box2D
} // end namespace collision
