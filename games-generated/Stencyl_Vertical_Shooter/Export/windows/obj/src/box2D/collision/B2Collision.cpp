// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_box2D_collision_B2AABB
#include <box2D/collision/B2AABB.h>
#endif
#ifndef INCLUDED_box2D_collision_B2Collision
#include <box2D/collision/B2Collision.h>
#endif
#ifndef INCLUDED_box2D_collision_B2ContactID
#include <box2D/collision/B2ContactID.h>
#endif
#ifndef INCLUDED_box2D_collision_B2Manifold
#include <box2D/collision/B2Manifold.h>
#endif
#ifndef INCLUDED_box2D_collision_B2ManifoldPoint
#include <box2D/collision/B2ManifoldPoint.h>
#endif
#ifndef INCLUDED_box2D_collision_ClipVertex
#include <box2D/collision/ClipVertex.h>
#endif
#ifndef INCLUDED_box2D_collision_Features
#include <box2D/collision/Features.h>
#endif
#ifndef INCLUDED_box2D_collision_shapes_B2CircleShape
#include <box2D/collision/shapes/B2CircleShape.h>
#endif
#ifndef INCLUDED_box2D_collision_shapes_B2PolygonShape
#include <box2D/collision/shapes/B2PolygonShape.h>
#endif
#ifndef INCLUDED_box2D_collision_shapes_B2Shape
#include <box2D/collision/shapes/B2Shape.h>
#endif
#ifndef INCLUDED_box2D_common_B2Settings
#include <box2D/common/B2Settings.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Mat22
#include <box2D/common/math/B2Mat22.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Transform
#include <box2D/common/math/B2Transform.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Vec2
#include <box2D/common/math/B2Vec2.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_11df19b5b3fde1b2_41_clipSegmentToLine,"box2D.collision.B2Collision","clipSegmentToLine",0x9c641799,"box2D.collision.B2Collision.clipSegmentToLine","box2D/collision/B2Collision.hx",41,0xb600848b)
HX_LOCAL_STACK_FRAME(_hx_pos_11df19b5b3fde1b2_93_edgeSeparation,"box2D.collision.B2Collision","edgeSeparation",0x1bcec31c,"box2D.collision.B2Collision.edgeSeparation","box2D/collision/B2Collision.hx",93,0xb600848b)
HX_LOCAL_STACK_FRAME(_hx_pos_11df19b5b3fde1b2_159_findMaxSeparation,"box2D.collision.B2Collision","findMaxSeparation",0x5c03e578,"box2D.collision.B2Collision.findMaxSeparation","box2D/collision/B2Collision.hx",159,0xb600848b)
HX_LOCAL_STACK_FRAME(_hx_pos_11df19b5b3fde1b2_262_findIncidentEdge,"box2D.collision.B2Collision","findIncidentEdge",0x9f9a2501,"box2D.collision.B2Collision.findIncidentEdge","box2D/collision/B2Collision.hx",262,0xb600848b)
HX_LOCAL_STACK_FRAME(_hx_pos_11df19b5b3fde1b2_331_makeClipPointVector,"box2D.collision.B2Collision","makeClipPointVector",0x2990ab1c,"box2D.collision.B2Collision.makeClipPointVector","box2D/collision/B2Collision.hx",331,0xb600848b)
HX_LOCAL_STACK_FRAME(_hx_pos_11df19b5b3fde1b2_360_collidePolygons,"box2D.collision.B2Collision","collidePolygons",0xd48a73fe,"box2D.collision.B2Collision.collidePolygons","box2D/collision/B2Collision.hx",360,0xb600848b)
HX_LOCAL_STACK_FRAME(_hx_pos_11df19b5b3fde1b2_514_collideCircles,"box2D.collision.B2Collision","collideCircles",0xe8b0e0be,"box2D.collision.B2Collision.collideCircles","box2D/collision/B2Collision.hx",514,0xb600848b)
HX_LOCAL_STACK_FRAME(_hx_pos_11df19b5b3fde1b2_552_collidePolygonAndCircle,"box2D.collision.B2Collision","collidePolygonAndCircle",0x55c672b2,"box2D.collision.B2Collision.collidePolygonAndCircle","box2D/collision/B2Collision.hx",552,0xb600848b)
HX_LOCAL_STACK_FRAME(_hx_pos_11df19b5b3fde1b2_679_testOverlap,"box2D.collision.B2Collision","testOverlap",0x8c92c37c,"box2D.collision.B2Collision.testOverlap","box2D/collision/B2Collision.hx",679,0xb600848b)
HX_LOCAL_STACK_FRAME(_hx_pos_11df19b5b3fde1b2_37_boot,"box2D.collision.B2Collision","boot",0x4e14b32b,"box2D.collision.B2Collision.boot","box2D/collision/B2Collision.hx",37,0xb600848b)
HX_LOCAL_STACK_FRAME(_hx_pos_11df19b5b3fde1b2_337_boot,"box2D.collision.B2Collision","boot",0x4e14b32b,"box2D.collision.B2Collision.boot","box2D/collision/B2Collision.hx",337,0xb600848b)
HX_LOCAL_STACK_FRAME(_hx_pos_11df19b5b3fde1b2_338_boot,"box2D.collision.B2Collision","boot",0x4e14b32b,"box2D.collision.B2Collision.boot","box2D/collision/B2Collision.hx",338,0xb600848b)
HX_LOCAL_STACK_FRAME(_hx_pos_11df19b5b3fde1b2_339_boot,"box2D.collision.B2Collision","boot",0x4e14b32b,"box2D.collision.B2Collision.boot","box2D/collision/B2Collision.hx",339,0xb600848b)
HX_LOCAL_STACK_FRAME(_hx_pos_11df19b5b3fde1b2_340_boot,"box2D.collision.B2Collision","boot",0x4e14b32b,"box2D.collision.B2Collision.boot","box2D/collision/B2Collision.hx",340,0xb600848b)
HX_LOCAL_STACK_FRAME(_hx_pos_11df19b5b3fde1b2_341_boot,"box2D.collision.B2Collision","boot",0x4e14b32b,"box2D.collision.B2Collision.boot","box2D/collision/B2Collision.hx",341,0xb600848b)
HX_LOCAL_STACK_FRAME(_hx_pos_11df19b5b3fde1b2_342_boot,"box2D.collision.B2Collision","boot",0x4e14b32b,"box2D.collision.B2Collision.boot","box2D/collision/B2Collision.hx",342,0xb600848b)
HX_LOCAL_STACK_FRAME(_hx_pos_11df19b5b3fde1b2_343_boot,"box2D.collision.B2Collision","boot",0x4e14b32b,"box2D.collision.B2Collision.boot","box2D/collision/B2Collision.hx",343,0xb600848b)
HX_LOCAL_STACK_FRAME(_hx_pos_11df19b5b3fde1b2_344_boot,"box2D.collision.B2Collision","boot",0x4e14b32b,"box2D.collision.B2Collision.boot","box2D/collision/B2Collision.hx",344,0xb600848b)
HX_LOCAL_STACK_FRAME(_hx_pos_11df19b5b3fde1b2_345_boot,"box2D.collision.B2Collision","boot",0x4e14b32b,"box2D.collision.B2Collision.boot","box2D/collision/B2Collision.hx",345,0xb600848b)
HX_LOCAL_STACK_FRAME(_hx_pos_11df19b5b3fde1b2_346_boot,"box2D.collision.B2Collision","boot",0x4e14b32b,"box2D.collision.B2Collision.boot","box2D/collision/B2Collision.hx",346,0xb600848b)
HX_LOCAL_STACK_FRAME(_hx_pos_11df19b5b3fde1b2_347_boot,"box2D.collision.B2Collision","boot",0x4e14b32b,"box2D.collision.B2Collision.boot","box2D/collision/B2Collision.hx",347,0xb600848b)
HX_LOCAL_STACK_FRAME(_hx_pos_11df19b5b3fde1b2_348_boot,"box2D.collision.B2Collision","boot",0x4e14b32b,"box2D.collision.B2Collision.boot","box2D/collision/B2Collision.hx",348,0xb600848b)
HX_LOCAL_STACK_FRAME(_hx_pos_11df19b5b3fde1b2_349_boot,"box2D.collision.B2Collision","boot",0x4e14b32b,"box2D.collision.B2Collision.boot","box2D/collision/B2Collision.hx",349,0xb600848b)
HX_LOCAL_STACK_FRAME(_hx_pos_11df19b5b3fde1b2_355_boot,"box2D.collision.B2Collision","boot",0x4e14b32b,"box2D.collision.B2Collision.boot","box2D/collision/B2Collision.hx",355,0xb600848b)
namespace box2D{
namespace collision{

void B2Collision_obj::__construct() { }

Dynamic B2Collision_obj::__CreateEmpty() { return new B2Collision_obj; }

void *B2Collision_obj::_hx_vtable = 0;

Dynamic B2Collision_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< B2Collision_obj > _hx_result = new B2Collision_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool B2Collision_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x071913a9;
}

int B2Collision_obj::b2_nullFeature;

int B2Collision_obj::clipSegmentToLine(::Array< ::Dynamic> vOut,::Array< ::Dynamic> vIn, ::box2D::common::math::B2Vec2 normal,Float offset){
            	HX_STACKFRAME(&_hx_pos_11df19b5b3fde1b2_41_clipSegmentToLine)
HXLINE(  42)		 ::box2D::collision::ClipVertex cv;
HXLINE(  45)		int numOut = (int)0;
HXLINE(  47)		cv = vIn->__get((int)0).StaticCast<  ::box2D::collision::ClipVertex >();
HXLINE(  48)		 ::box2D::common::math::B2Vec2 vIn0 = cv->v;
HXLINE(  49)		cv = vIn->__get((int)1).StaticCast<  ::box2D::collision::ClipVertex >();
HXLINE(  50)		 ::box2D::common::math::B2Vec2 vIn1 = cv->v;
HXLINE(  53)		Float distance0 = (normal->x * vIn0->x);
HXDLIN(  53)		Float distance01 = ((distance0 + (normal->y * vIn0->y)) - offset);
HXLINE(  54)		Float distance1 = (normal->x * vIn1->x);
HXDLIN(  54)		Float distance11 = ((distance1 + (normal->y * vIn1->y)) - offset);
HXLINE(  57)		if ((distance01 <= ((Float)0.0))) {
HXLINE(  57)			numOut = (numOut + (int)1);
HXDLIN(  57)			 ::box2D::collision::ClipVertex vOut1 = vOut->__get((numOut - (int)1)).StaticCast<  ::box2D::collision::ClipVertex >();
HXDLIN(  57)			vOut1->set(vIn->__get((int)0).StaticCast<  ::box2D::collision::ClipVertex >());
            		}
HXLINE(  58)		if ((distance11 <= ((Float)0.0))) {
HXLINE(  58)			numOut = (numOut + (int)1);
HXDLIN(  58)			 ::box2D::collision::ClipVertex vOut2 = vOut->__get((numOut - (int)1)).StaticCast<  ::box2D::collision::ClipVertex >();
HXDLIN(  58)			vOut2->set(vIn->__get((int)1).StaticCast<  ::box2D::collision::ClipVertex >());
            		}
HXLINE(  61)		if (((distance01 * distance11) < ((Float)0.0))) {
HXLINE(  64)			Float interp = ((Float)distance01 / (Float)(distance01 - distance11));
HXLINE(  67)			cv = vOut->__get(numOut).StaticCast<  ::box2D::collision::ClipVertex >();
HXLINE(  68)			 ::box2D::common::math::B2Vec2 tVec = cv->v;
HXLINE(  69)			Float vIn01 = vIn0->x;
HXDLIN(  69)			tVec->x = (vIn01 + (interp * (vIn1->x - vIn0->x)));
HXLINE(  70)			Float vIn02 = vIn0->y;
HXDLIN(  70)			tVec->y = (vIn02 + (interp * (vIn1->y - vIn0->y)));
HXLINE(  71)			cv = vOut->__get(numOut).StaticCast<  ::box2D::collision::ClipVertex >();
HXLINE(  72)			 ::box2D::collision::ClipVertex cv2;
HXLINE(  73)			if ((distance01 > ((Float)0.0))) {
HXLINE(  75)				cv2 = vIn->__get((int)0).StaticCast<  ::box2D::collision::ClipVertex >();
HXLINE(  76)				cv->id = cv2->id;
            			}
            			else {
HXLINE(  80)				cv2 = vIn->__get((int)1).StaticCast<  ::box2D::collision::ClipVertex >();
HXLINE(  81)				cv->id = cv2->id;
            			}
HXLINE(  83)			numOut = (numOut + (int)1);
            		}
HXLINE(  86)		return numOut;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(B2Collision_obj,clipSegmentToLine,return )

Float B2Collision_obj::edgeSeparation( ::box2D::collision::shapes::B2PolygonShape poly1, ::box2D::common::math::B2Transform xf1,int edge1, ::box2D::collision::shapes::B2PolygonShape poly2, ::box2D::common::math::B2Transform xf2){
            	HX_STACKFRAME(&_hx_pos_11df19b5b3fde1b2_93_edgeSeparation)
HXLINE(  94)		int count1 = poly1->m_vertexCount;
HXLINE(  95)		::Array< ::Dynamic> vertices1 = poly1->m_vertices;
HXLINE(  96)		::Array< ::Dynamic> normals1 = poly1->m_normals;
HXLINE(  98)		int count2 = poly2->m_vertexCount;
HXLINE(  99)		::Array< ::Dynamic> vertices2 = poly2->m_vertices;
HXLINE( 103)		 ::box2D::common::math::B2Mat22 tMat;
HXLINE( 104)		 ::box2D::common::math::B2Vec2 tVec;
HXLINE( 108)		tMat = xf1->R;
HXLINE( 109)		tVec = normals1->__get(edge1).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXLINE( 110)		Float normal1WorldX = (tMat->col1->x * tVec->x);
HXDLIN( 110)		Float normal1WorldX1 = (normal1WorldX + (tMat->col2->x * tVec->y));
HXLINE( 111)		Float normal1WorldY = (tMat->col1->y * tVec->x);
HXDLIN( 111)		Float normal1WorldY1 = (normal1WorldY + (tMat->col2->y * tVec->y));
HXLINE( 113)		tMat = xf2->R;
HXLINE( 114)		Float normal1X = (tMat->col1->x * normal1WorldX1);
HXDLIN( 114)		Float normal1X1 = (normal1X + (tMat->col1->y * normal1WorldY1));
HXLINE( 115)		Float normal1Y = (tMat->col2->x * normal1WorldX1);
HXDLIN( 115)		Float normal1Y1 = (normal1Y + (tMat->col2->y * normal1WorldY1));
HXLINE( 118)		int index = (int)0;
HXLINE( 119)		Float minDot = ((Float)1.7976931348623158e+308);
HXLINE( 120)		{
HXLINE( 120)			int _g1 = (int)0;
HXDLIN( 120)			int _g = count2;
HXDLIN( 120)			while((_g1 < _g)){
HXLINE( 120)				_g1 = (_g1 + (int)1);
HXDLIN( 120)				int i = (_g1 - (int)1);
HXLINE( 123)				tVec = vertices2->__get(i).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXLINE( 124)				Float dot = (tVec->x * normal1X1);
HXDLIN( 124)				Float dot1 = (dot + (tVec->y * normal1Y1));
HXLINE( 125)				if ((dot1 < minDot)) {
HXLINE( 127)					minDot = dot1;
HXLINE( 128)					index = i;
            				}
            			}
            		}
HXLINE( 133)		tVec = vertices1->__get(edge1).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXLINE( 134)		tMat = xf1->R;
HXLINE( 135)		Float xf11 = xf1->position->x;
HXDLIN( 135)		Float v1X = (tMat->col1->x * tVec->x);
HXDLIN( 135)		Float v1X1 = (xf11 + (v1X + (tMat->col2->x * tVec->y)));
HXLINE( 136)		Float xf12 = xf1->position->y;
HXDLIN( 136)		Float v1Y = (tMat->col1->y * tVec->x);
HXDLIN( 136)		Float v1Y1 = (xf12 + (v1Y + (tMat->col2->y * tVec->y)));
HXLINE( 138)		tVec = vertices2->__get(index).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXLINE( 139)		tMat = xf2->R;
HXLINE( 140)		Float xf21 = xf2->position->x;
HXDLIN( 140)		Float v2X = (tMat->col1->x * tVec->x);
HXDLIN( 140)		Float v2X1 = (xf21 + (v2X + (tMat->col2->x * tVec->y)));
HXLINE( 141)		Float xf22 = xf2->position->y;
HXDLIN( 141)		Float v2Y = (tMat->col1->y * tVec->x);
HXDLIN( 141)		Float v2Y1 = (xf22 + (v2Y + (tMat->col2->y * tVec->y)));
HXLINE( 144)		v2X1 = (v2X1 - v1X1);
HXLINE( 145)		v2Y1 = (v2Y1 - v1Y1);
HXLINE( 147)		Float separation = ((v2X1 * normal1WorldX1) + (v2Y1 * normal1WorldY1));
HXLINE( 148)		return separation;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(B2Collision_obj,edgeSeparation,return )

Float B2Collision_obj::findMaxSeparation(::Array< int > edgeIndex, ::box2D::collision::shapes::B2PolygonShape poly1, ::box2D::common::math::B2Transform xf1, ::box2D::collision::shapes::B2PolygonShape poly2, ::box2D::common::math::B2Transform xf2){
            	HX_STACKFRAME(&_hx_pos_11df19b5b3fde1b2_159_findMaxSeparation)
HXLINE( 160)		int count1 = poly1->m_vertexCount;
HXLINE( 161)		::Array< ::Dynamic> normals1 = poly1->m_normals;
HXLINE( 163)		 ::box2D::common::math::B2Vec2 tVec;
HXLINE( 164)		 ::box2D::common::math::B2Mat22 tMat = xf2->R;
HXLINE( 169)		tVec = poly2->m_centroid;
HXLINE( 170)		Float xf21 = xf2->position->x;
HXDLIN( 170)		Float dX = (tMat->col1->x * tVec->x);
HXDLIN( 170)		Float dX1 = (xf21 + (dX + (tMat->col2->x * tVec->y)));
HXLINE( 171)		Float xf22 = xf2->position->y;
HXDLIN( 171)		Float dY = (tMat->col1->y * tVec->x);
HXDLIN( 171)		Float dY1 = (xf22 + (dY + (tMat->col2->y * tVec->y)));
HXLINE( 172)		tMat = xf1->R;
HXLINE( 173)		tVec = poly1->m_centroid;
HXLINE( 174)		Float xf11 = xf1->position->x;
HXDLIN( 174)		Float dX2 = (tMat->col1->x * tVec->x);
HXDLIN( 174)		dX1 = (dX1 - (xf11 + (dX2 + (tMat->col2->x * tVec->y))));
HXLINE( 175)		Float xf12 = xf1->position->y;
HXDLIN( 175)		Float dY2 = (tMat->col1->y * tVec->x);
HXDLIN( 175)		dY1 = (dY1 - (xf12 + (dY2 + (tMat->col2->y * tVec->y))));
HXLINE( 178)		Float dLocal1X = (dX1 * xf1->R->col1->x);
HXDLIN( 178)		Float dLocal1X1 = (dLocal1X + (dY1 * xf1->R->col1->y));
HXLINE( 179)		Float dLocal1Y = (dX1 * xf1->R->col2->x);
HXDLIN( 179)		Float dLocal1Y1 = (dLocal1Y + (dY1 * xf1->R->col2->y));
HXLINE( 182)		int edge = (int)0;
HXLINE( 183)		Float maxDot = ((Float)-1.7976931348623157e+308);
HXLINE( 184)		{
HXLINE( 184)			int _g1 = (int)0;
HXDLIN( 184)			int _g = count1;
HXDLIN( 184)			while((_g1 < _g)){
HXLINE( 184)				_g1 = (_g1 + (int)1);
HXDLIN( 184)				int i = (_g1 - (int)1);
HXLINE( 187)				tVec = normals1->__get(i).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXLINE( 188)				Float dot = (tVec->x * dLocal1X1);
HXDLIN( 188)				Float dot1 = (dot + (tVec->y * dLocal1Y1));
HXLINE( 189)				if ((dot1 > maxDot)) {
HXLINE( 191)					maxDot = dot1;
HXLINE( 192)					edge = i;
            				}
            			}
            		}
HXLINE( 197)		Float s = ::box2D::collision::B2Collision_obj::edgeSeparation(poly1,xf1,edge,poly2,xf2);
HXLINE( 200)		int prevEdge;
HXDLIN( 200)		if (((edge - (int)1) >= (int)0)) {
HXLINE( 200)			prevEdge = (edge - (int)1);
            		}
            		else {
HXLINE( 200)			prevEdge = (count1 - (int)1);
            		}
HXLINE( 201)		Float sPrev = ::box2D::collision::B2Collision_obj::edgeSeparation(poly1,xf1,prevEdge,poly2,xf2);
HXLINE( 204)		int nextEdge;
HXDLIN( 204)		if (((edge + (int)1) < count1)) {
HXLINE( 204)			nextEdge = (edge + (int)1);
            		}
            		else {
HXLINE( 204)			nextEdge = (int)0;
            		}
HXLINE( 205)		Float sNext = ::box2D::collision::B2Collision_obj::edgeSeparation(poly1,xf1,nextEdge,poly2,xf2);
HXLINE( 208)		int bestEdge;
HXLINE( 209)		Float bestSeparation;
HXLINE( 210)		int increment;
HXLINE( 211)		bool _hx_tmp;
HXDLIN( 211)		if ((sPrev > s)) {
HXLINE( 211)			_hx_tmp = (sPrev > sNext);
            		}
            		else {
HXLINE( 211)			_hx_tmp = false;
            		}
HXDLIN( 211)		if (_hx_tmp) {
HXLINE( 213)			increment = (int)-1;
HXLINE( 214)			bestEdge = prevEdge;
HXLINE( 215)			bestSeparation = sPrev;
            		}
            		else {
HXLINE( 217)			if ((sNext > s)) {
HXLINE( 219)				increment = (int)1;
HXLINE( 220)				bestEdge = nextEdge;
HXLINE( 221)				bestSeparation = sNext;
            			}
            			else {
HXLINE( 226)				edgeIndex[(int)0] = edge;
HXLINE( 227)				return s;
            			}
            		}
HXLINE( 231)		while(true){
HXLINE( 234)			if ((increment == (int)-1)) {
HXLINE( 235)				if (((bestEdge - (int)1) >= (int)0)) {
HXLINE( 235)					edge = (bestEdge - (int)1);
            				}
            				else {
HXLINE( 235)					edge = (count1 - (int)1);
            				}
            			}
            			else {
HXLINE( 237)				if (((bestEdge + (int)1) < count1)) {
HXLINE( 237)					edge = (bestEdge + (int)1);
            				}
            				else {
HXLINE( 237)					edge = (int)0;
            				}
            			}
HXLINE( 239)			s = ::box2D::collision::B2Collision_obj::edgeSeparation(poly1,xf1,edge,poly2,xf2);
HXLINE( 241)			if ((s > bestSeparation)) {
HXLINE( 243)				bestEdge = edge;
HXLINE( 244)				bestSeparation = s;
            			}
            			else {
HXLINE( 248)				goto _hx_goto_4;
            			}
            		}
            		_hx_goto_4:;
HXLINE( 253)		edgeIndex[(int)0] = bestEdge;
HXLINE( 254)		return bestSeparation;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(B2Collision_obj,findMaxSeparation,return )

void B2Collision_obj::findIncidentEdge(::Array< ::Dynamic> c, ::box2D::collision::shapes::B2PolygonShape poly1, ::box2D::common::math::B2Transform xf1,int edge1, ::box2D::collision::shapes::B2PolygonShape poly2, ::box2D::common::math::B2Transform xf2){
            	HX_STACKFRAME(&_hx_pos_11df19b5b3fde1b2_262_findIncidentEdge)
HXLINE( 263)		int count1 = poly1->m_vertexCount;
HXLINE( 264)		::Array< ::Dynamic> normals1 = poly1->m_normals;
HXLINE( 266)		int count2 = poly2->m_vertexCount;
HXLINE( 267)		::Array< ::Dynamic> vertices2 = poly2->m_vertices;
HXLINE( 268)		::Array< ::Dynamic> normals2 = poly2->m_normals;
HXLINE( 272)		 ::box2D::common::math::B2Mat22 tMat;
HXLINE( 273)		 ::box2D::common::math::B2Vec2 tVec;
HXLINE( 277)		tMat = xf1->R;
HXLINE( 278)		tVec = normals1->__get(edge1).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXLINE( 279)		Float normal1X = (tMat->col1->x * tVec->x);
HXDLIN( 279)		Float normal1X1 = (normal1X + (tMat->col2->x * tVec->y));
HXLINE( 280)		Float normal1Y = (tMat->col1->y * tVec->x);
HXDLIN( 280)		Float normal1Y1 = (normal1Y + (tMat->col2->y * tVec->y));
HXLINE( 281)		tMat = xf2->R;
HXLINE( 282)		Float tX = (tMat->col1->x * normal1X1);
HXDLIN( 282)		Float tX1 = (tX + (tMat->col1->y * normal1Y1));
HXLINE( 283)		Float normal1Y2 = (tMat->col2->x * normal1X1);
HXDLIN( 283)		normal1Y1 = (normal1Y2 + (tMat->col2->y * normal1Y1));
HXLINE( 284)		normal1X1 = tX1;
HXLINE( 287)		int index = (int)0;
HXLINE( 288)		Float minDot = ((Float)1.7976931348623158e+308);
HXLINE( 289)		{
HXLINE( 289)			int _g1 = (int)0;
HXDLIN( 289)			int _g = count2;
HXDLIN( 289)			while((_g1 < _g)){
HXLINE( 289)				_g1 = (_g1 + (int)1);
HXDLIN( 289)				int i = (_g1 - (int)1);
HXLINE( 292)				tVec = normals2->__get(i).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXLINE( 293)				Float dot = (normal1X1 * tVec->x);
HXDLIN( 293)				Float dot1 = (dot + (normal1Y1 * tVec->y));
HXLINE( 294)				if ((dot1 < minDot)) {
HXLINE( 296)					minDot = dot1;
HXLINE( 297)					index = i;
            				}
            			}
            		}
HXLINE( 301)		 ::box2D::collision::ClipVertex tClip;
HXLINE( 303)		int i1 = index;
HXLINE( 304)		int i2;
HXDLIN( 304)		if (((i1 + (int)1) < count2)) {
HXLINE( 304)			i2 = (i1 + (int)1);
            		}
            		else {
HXLINE( 304)			i2 = (int)0;
            		}
HXLINE( 306)		tClip = c->__get((int)0).StaticCast<  ::box2D::collision::ClipVertex >();
HXLINE( 308)		tVec = vertices2->__get(i1).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXLINE( 309)		tMat = xf2->R;
HXLINE( 310)		Float xf21 = xf2->position->x;
HXDLIN( 310)		Float _hx_tmp = (tMat->col1->x * tVec->x);
HXDLIN( 310)		tClip->v->x = (xf21 + (_hx_tmp + (tMat->col2->x * tVec->y)));
HXLINE( 311)		Float xf22 = xf2->position->y;
HXDLIN( 311)		Float _hx_tmp1 = (tMat->col1->y * tVec->x);
HXDLIN( 311)		tClip->v->y = (xf22 + (_hx_tmp1 + (tMat->col2->y * tVec->y)));
HXLINE( 313)		tClip->id->features->set_referenceEdge(edge1);
HXLINE( 314)		tClip->id->features->set_incidentEdge(i1);
HXLINE( 315)		tClip->id->features->set_incidentVertex((int)0);
HXLINE( 317)		tClip = c->__get((int)1).StaticCast<  ::box2D::collision::ClipVertex >();
HXLINE( 319)		tVec = vertices2->__get(i2).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXLINE( 320)		tMat = xf2->R;
HXLINE( 321)		Float xf23 = xf2->position->x;
HXDLIN( 321)		Float _hx_tmp2 = (tMat->col1->x * tVec->x);
HXDLIN( 321)		tClip->v->x = (xf23 + (_hx_tmp2 + (tMat->col2->x * tVec->y)));
HXLINE( 322)		Float xf24 = xf2->position->y;
HXDLIN( 322)		Float _hx_tmp3 = (tMat->col1->y * tVec->x);
HXDLIN( 322)		tClip->v->y = (xf24 + (_hx_tmp3 + (tMat->col2->y * tVec->y)));
HXLINE( 324)		tClip->id->features->set_referenceEdge(edge1);
HXLINE( 325)		tClip->id->features->set_incidentEdge(i2);
HXLINE( 326)		tClip->id->features->set_incidentVertex((int)1);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(B2Collision_obj,findIncidentEdge,(void))

::Array< ::Dynamic> B2Collision_obj::makeClipPointVector(){
            	HX_GC_STACKFRAME(&_hx_pos_11df19b5b3fde1b2_331_makeClipPointVector)
HXLINE( 332)		::Array< ::Dynamic> r = ::Array_obj< ::Dynamic>::__new();
HXLINE( 333)		r[(int)0] =  ::box2D::collision::ClipVertex_obj::__alloc( HX_CTX );
HXLINE( 334)		r[(int)1] =  ::box2D::collision::ClipVertex_obj::__alloc( HX_CTX );
HXLINE( 335)		return r;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(B2Collision_obj,makeClipPointVector,return )

::Array< ::Dynamic> B2Collision_obj::s_incidentEdge;

::Array< ::Dynamic> B2Collision_obj::s_clipPoints1;

::Array< ::Dynamic> B2Collision_obj::s_clipPoints2;

::Array< int > B2Collision_obj::s_edgeAO;

::Array< int > B2Collision_obj::s_edgeBO;

 ::box2D::common::math::B2Vec2 B2Collision_obj::s_localTangent;

 ::box2D::common::math::B2Vec2 B2Collision_obj::s_localNormal;

 ::box2D::common::math::B2Vec2 B2Collision_obj::s_planePoint;

 ::box2D::common::math::B2Vec2 B2Collision_obj::s_normal;

 ::box2D::common::math::B2Vec2 B2Collision_obj::s_tangent;

 ::box2D::common::math::B2Vec2 B2Collision_obj::s_tangent2;

 ::box2D::common::math::B2Vec2 B2Collision_obj::s_v11;

 ::box2D::common::math::B2Vec2 B2Collision_obj::s_v12;

 ::box2D::common::math::B2Vec2 B2Collision_obj::b2CollidePolyTempVec;

void B2Collision_obj::collidePolygons( ::box2D::collision::B2Manifold manifold, ::box2D::collision::shapes::B2PolygonShape polyA, ::box2D::common::math::B2Transform xfA, ::box2D::collision::shapes::B2PolygonShape polyB, ::box2D::common::math::B2Transform xfB){
            	HX_STACKFRAME(&_hx_pos_11df19b5b3fde1b2_360_collidePolygons)
HXLINE( 361)		 ::box2D::collision::ClipVertex cv;
HXLINE( 363)		manifold->m_pointCount = (int)0;
HXLINE( 364)		Float totalRadius = (polyA->m_radius + polyB->m_radius);
HXLINE( 366)		int edgeA = (int)0;
HXLINE( 367)		::box2D::collision::B2Collision_obj::s_edgeAO[(int)0] = edgeA;
HXLINE( 368)		Float separationA = ::box2D::collision::B2Collision_obj::findMaxSeparation(::box2D::collision::B2Collision_obj::s_edgeAO,polyA,xfA,polyB,xfB);
HXLINE( 369)		edgeA = ::box2D::collision::B2Collision_obj::s_edgeAO->__get((int)0);
HXLINE( 370)		if ((separationA > totalRadius)) {
HXLINE( 371)			return;
            		}
HXLINE( 373)		int edgeB = (int)0;
HXLINE( 374)		::box2D::collision::B2Collision_obj::s_edgeBO[(int)0] = edgeB;
HXLINE( 375)		Float separationB = ::box2D::collision::B2Collision_obj::findMaxSeparation(::box2D::collision::B2Collision_obj::s_edgeBO,polyB,xfB,polyA,xfA);
HXLINE( 376)		edgeB = ::box2D::collision::B2Collision_obj::s_edgeBO->__get((int)0);
HXLINE( 377)		if ((separationB > totalRadius)) {
HXLINE( 378)			return;
            		}
HXLINE( 380)		 ::box2D::collision::shapes::B2PolygonShape poly1;
HXLINE( 381)		 ::box2D::collision::shapes::B2PolygonShape poly2;
HXLINE( 382)		 ::box2D::common::math::B2Transform xf1;
HXLINE( 383)		 ::box2D::common::math::B2Transform xf2;
HXLINE( 384)		int edge1;
HXLINE( 385)		int flip;
HXLINE( 386)		Float k_relativeTol = ((Float)0.98);
HXLINE( 387)		Float k_absoluteTol = ((Float)0.001);
HXLINE( 388)		 ::box2D::common::math::B2Mat22 tMat;
HXLINE( 390)		if ((separationB > ((k_relativeTol * separationA) + k_absoluteTol))) {
HXLINE( 392)			poly1 = polyB;
HXLINE( 393)			poly2 = polyA;
HXLINE( 394)			xf1 = xfB;
HXLINE( 395)			xf2 = xfA;
HXLINE( 396)			edge1 = edgeB;
HXLINE( 397)			manifold->m_type = (int)4;
HXLINE( 398)			flip = (int)1;
            		}
            		else {
HXLINE( 402)			poly1 = polyA;
HXLINE( 403)			poly2 = polyB;
HXLINE( 404)			xf1 = xfA;
HXLINE( 405)			xf2 = xfB;
HXLINE( 406)			edge1 = edgeA;
HXLINE( 407)			manifold->m_type = (int)2;
HXLINE( 408)			flip = (int)0;
            		}
HXLINE( 411)		::Array< ::Dynamic> incidentEdge = ::box2D::collision::B2Collision_obj::s_incidentEdge;
HXLINE( 412)		::box2D::collision::B2Collision_obj::findIncidentEdge(incidentEdge,poly1,xf1,edge1,poly2,xf2);
HXLINE( 414)		int count1 = poly1->m_vertexCount;
HXLINE( 415)		::Array< ::Dynamic> vertices1 = poly1->m_vertices;
HXLINE( 417)		 ::box2D::common::math::B2Vec2 local_v11 = vertices1->__get(edge1).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXLINE( 418)		 ::box2D::common::math::B2Vec2 local_v12;
HXLINE( 419)		if (((edge1 + (int)1) < count1)) {
HXLINE( 420)			local_v12 = vertices1->__get((edge1 + (int)1)).StaticCast<  ::box2D::common::math::B2Vec2 >();
            		}
            		else {
HXLINE( 422)			local_v12 = vertices1->__get((int)0).StaticCast<  ::box2D::common::math::B2Vec2 >();
            		}
HXLINE( 425)		 ::box2D::common::math::B2Vec2 localTangent = ::box2D::collision::B2Collision_obj::s_localTangent;
HXLINE( 426)		{
HXLINE( 426)			localTangent->x = (local_v12->x - local_v11->x);
HXDLIN( 426)			localTangent->y = (local_v12->y - local_v11->y);
            		}
HXLINE( 427)		localTangent->normalize();
HXLINE( 429)		 ::box2D::common::math::B2Vec2 localNormal = ::box2D::collision::B2Collision_obj::s_localNormal;
HXLINE( 430)		localNormal->x = localTangent->y;
HXLINE( 431)		localNormal->y = -(localTangent->x);
HXLINE( 433)		 ::box2D::common::math::B2Vec2 planePoint = ::box2D::collision::B2Collision_obj::s_planePoint;
HXLINE( 434)		{
HXLINE( 434)			planePoint->x = (((Float)0.5) * (local_v11->x + local_v12->x));
HXDLIN( 434)			planePoint->y = (((Float)0.5) * (local_v11->y + local_v12->y));
            		}
HXLINE( 436)		 ::box2D::common::math::B2Vec2 tangent = ::box2D::collision::B2Collision_obj::s_tangent;
HXLINE( 438)		tMat = xf1->R;
HXLINE( 439)		Float _hx_tmp = (tMat->col1->x * localTangent->x);
HXDLIN( 439)		tangent->x = (_hx_tmp + (tMat->col2->x * localTangent->y));
HXLINE( 440)		Float _hx_tmp1 = (tMat->col1->y * localTangent->x);
HXDLIN( 440)		tangent->y = (_hx_tmp1 + (tMat->col2->y * localTangent->y));
HXLINE( 441)		 ::box2D::common::math::B2Vec2 tangent2 = ::box2D::collision::B2Collision_obj::s_tangent2;
HXLINE( 442)		tangent2->x = -(tangent->x);
HXLINE( 443)		tangent2->y = -(tangent->y);
HXLINE( 444)		 ::box2D::common::math::B2Vec2 normal = ::box2D::collision::B2Collision_obj::s_normal;
HXLINE( 445)		normal->x = tangent->y;
HXLINE( 446)		normal->y = -(tangent->x);
HXLINE( 450)		 ::box2D::common::math::B2Vec2 v11 = ::box2D::collision::B2Collision_obj::s_v11;
HXLINE( 451)		 ::box2D::common::math::B2Vec2 v12 = ::box2D::collision::B2Collision_obj::s_v12;
HXLINE( 452)		Float xf11 = xf1->position->x;
HXDLIN( 452)		Float _hx_tmp2 = (tMat->col1->x * local_v11->x);
HXDLIN( 452)		v11->x = (xf11 + (_hx_tmp2 + (tMat->col2->x * local_v11->y)));
HXLINE( 453)		Float xf12 = xf1->position->y;
HXDLIN( 453)		Float _hx_tmp3 = (tMat->col1->y * local_v11->x);
HXDLIN( 453)		v11->y = (xf12 + (_hx_tmp3 + (tMat->col2->y * local_v11->y)));
HXLINE( 454)		Float xf13 = xf1->position->x;
HXDLIN( 454)		Float _hx_tmp4 = (tMat->col1->x * local_v12->x);
HXDLIN( 454)		v12->x = (xf13 + (_hx_tmp4 + (tMat->col2->x * local_v12->y)));
HXLINE( 455)		Float xf14 = xf1->position->y;
HXDLIN( 455)		Float _hx_tmp5 = (tMat->col1->y * local_v12->x);
HXDLIN( 455)		v12->y = (xf14 + (_hx_tmp5 + (tMat->col2->y * local_v12->y)));
HXLINE( 458)		Float frontOffset = (normal->x * v11->x);
HXDLIN( 458)		Float frontOffset1 = (frontOffset + (normal->y * v11->y));
HXLINE( 460)		Float sideOffset1 = (-(tangent->x) * v11->x);
HXDLIN( 460)		Float sideOffset11 = ((sideOffset1 - (tangent->y * v11->y)) + totalRadius);
HXLINE( 461)		Float sideOffset2 = (tangent->x * v12->x);
HXDLIN( 461)		Float sideOffset21 = ((sideOffset2 + (tangent->y * v12->y)) + totalRadius);
HXLINE( 464)		::Array< ::Dynamic> clipPoints1 = ::box2D::collision::B2Collision_obj::s_clipPoints1;
HXLINE( 465)		::Array< ::Dynamic> clipPoints2 = ::box2D::collision::B2Collision_obj::s_clipPoints2;
HXLINE( 466)		int np = ::box2D::collision::B2Collision_obj::clipSegmentToLine(clipPoints1,incidentEdge,tangent2,sideOffset11);
HXLINE( 472)		if ((np < (int)2)) {
HXLINE( 473)			return;
            		}
HXLINE( 476)		np = ::box2D::collision::B2Collision_obj::clipSegmentToLine(clipPoints2,clipPoints1,tangent,sideOffset21);
HXLINE( 478)		if ((np < (int)2)) {
HXLINE( 479)			return;
            		}
HXLINE( 482)		{
HXLINE( 482)			 ::box2D::common::math::B2Vec2 _this = manifold->m_localPlaneNormal;
HXDLIN( 482)			_this->x = localNormal->x;
HXDLIN( 482)			_this->y = localNormal->y;
            		}
HXLINE( 483)		{
HXLINE( 483)			 ::box2D::common::math::B2Vec2 _this1 = manifold->m_localPoint;
HXDLIN( 483)			_this1->x = planePoint->x;
HXDLIN( 483)			_this1->y = planePoint->y;
            		}
HXLINE( 485)		int pointCount = (int)0;
HXLINE( 486)		{
HXLINE( 486)			int _g1 = (int)0;
HXDLIN( 486)			int _g = ::box2D::common::B2Settings_obj::b2_maxManifoldPoints;
HXDLIN( 486)			while((_g1 < _g)){
HXLINE( 486)				_g1 = (_g1 + (int)1);
HXDLIN( 486)				int i = (_g1 - (int)1);
HXLINE( 488)				cv = clipPoints2->__get(i).StaticCast<  ::box2D::collision::ClipVertex >();
HXLINE( 489)				Float separation = (normal->x * cv->v->x);
HXDLIN( 489)				Float separation1 = ((separation + (normal->y * cv->v->y)) - frontOffset1);
HXLINE( 490)				if ((separation1 <= totalRadius)) {
HXLINE( 492)					 ::box2D::collision::B2ManifoldPoint cp = manifold->m_points->__get(pointCount).StaticCast<  ::box2D::collision::B2ManifoldPoint >();
HXLINE( 494)					tMat = xf2->R;
HXLINE( 495)					Float tX = (cv->v->x - xf2->position->x);
HXLINE( 496)					Float tY = (cv->v->y - xf2->position->y);
HXLINE( 497)					Float _hx_tmp6 = (tX * tMat->col1->x);
HXDLIN( 497)					cp->m_localPoint->x = (_hx_tmp6 + (tY * tMat->col1->y));
HXLINE( 498)					Float _hx_tmp7 = (tX * tMat->col2->x);
HXDLIN( 498)					cp->m_localPoint->y = (_hx_tmp7 + (tY * tMat->col2->y));
HXLINE( 499)					cp->m_id->set(cv->id);
HXLINE( 500)					cp->m_id->features->set_flip(flip);
HXLINE( 501)					pointCount = (pointCount + (int)1);
            				}
            			}
            		}
HXLINE( 505)		manifold->m_pointCount = pointCount;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(B2Collision_obj,collidePolygons,(void))

void B2Collision_obj::collideCircles( ::box2D::collision::B2Manifold manifold, ::box2D::collision::shapes::B2CircleShape circle1, ::box2D::common::math::B2Transform xf1, ::box2D::collision::shapes::B2CircleShape circle2, ::box2D::common::math::B2Transform xf2){
            	HX_STACKFRAME(&_hx_pos_11df19b5b3fde1b2_514_collideCircles)
HXLINE( 515)		manifold->m_pointCount = (int)0;
HXLINE( 517)		 ::box2D::common::math::B2Mat22 tMat;
HXLINE( 518)		 ::box2D::common::math::B2Vec2 tVec;
HXLINE( 521)		tMat = xf1->R;
HXDLIN( 521)		tVec = circle1->m_p;
HXLINE( 522)		Float xf11 = xf1->position->x;
HXDLIN( 522)		Float p1X = (tMat->col1->x * tVec->x);
HXDLIN( 522)		Float p1X1 = (xf11 + (p1X + (tMat->col2->x * tVec->y)));
HXLINE( 523)		Float xf12 = xf1->position->y;
HXDLIN( 523)		Float p1Y = (tMat->col1->y * tVec->x);
HXDLIN( 523)		Float p1Y1 = (xf12 + (p1Y + (tMat->col2->y * tVec->y)));
HXLINE( 525)		tMat = xf2->R;
HXDLIN( 525)		tVec = circle2->m_p;
HXLINE( 526)		Float xf21 = xf2->position->x;
HXDLIN( 526)		Float p2X = (tMat->col1->x * tVec->x);
HXDLIN( 526)		Float p2X1 = (xf21 + (p2X + (tMat->col2->x * tVec->y)));
HXLINE( 527)		Float xf22 = xf2->position->y;
HXDLIN( 527)		Float p2Y = (tMat->col1->y * tVec->x);
HXDLIN( 527)		Float p2Y1 = (xf22 + (p2Y + (tMat->col2->y * tVec->y)));
HXLINE( 529)		Float dX = (p2X1 - p1X1);
HXLINE( 530)		Float dY = (p2Y1 - p1Y1);
HXLINE( 532)		Float distSqr = ((dX * dX) + (dY * dY));
HXLINE( 533)		Float radius = (circle1->m_radius + circle2->m_radius);
HXLINE( 534)		if ((distSqr > (radius * radius))) {
HXLINE( 536)			return;
            		}
HXLINE( 538)		manifold->m_type = (int)1;
HXLINE( 539)		{
HXLINE( 539)			 ::box2D::common::math::B2Vec2 _this = manifold->m_localPoint;
HXDLIN( 539)			 ::box2D::common::math::B2Vec2 v = circle1->m_p;
HXDLIN( 539)			_this->x = v->x;
HXDLIN( 539)			_this->y = v->y;
            		}
HXLINE( 540)		{
HXLINE( 540)			 ::box2D::common::math::B2Vec2 _this1 = manifold->m_localPlaneNormal;
HXDLIN( 540)			_this1->x = ((Float)0.0);
HXDLIN( 540)			_this1->y = ((Float)0.0);
            		}
HXLINE( 541)		manifold->m_pointCount = (int)1;
HXLINE( 542)		{
HXLINE( 542)			 ::box2D::common::math::B2Vec2 _this2 = manifold->m_points->__get((int)0).StaticCast<  ::box2D::collision::B2ManifoldPoint >()->m_localPoint;
HXDLIN( 542)			 ::box2D::common::math::B2Vec2 v1 = circle2->m_p;
HXDLIN( 542)			_this2->x = v1->x;
HXDLIN( 542)			_this2->y = v1->y;
            		}
HXLINE( 543)		manifold->m_points->__get((int)0).StaticCast<  ::box2D::collision::B2ManifoldPoint >()->m_id->set_key((int)0);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(B2Collision_obj,collideCircles,(void))

void B2Collision_obj::collidePolygonAndCircle( ::box2D::collision::B2Manifold manifold, ::box2D::collision::shapes::B2PolygonShape polygon, ::box2D::common::math::B2Transform xf1, ::box2D::collision::shapes::B2CircleShape circle, ::box2D::common::math::B2Transform xf2){
            	HX_STACKFRAME(&_hx_pos_11df19b5b3fde1b2_552_collidePolygonAndCircle)
HXLINE( 553)		manifold->m_pointCount = (int)0;
HXLINE( 554)		 ::box2D::collision::B2ManifoldPoint tPoint;
HXLINE( 556)		Float dX;
HXLINE( 557)		Float dY;
HXLINE( 558)		Float positionX;
HXLINE( 559)		Float positionY;
HXLINE( 561)		 ::box2D::common::math::B2Vec2 tVec;
HXLINE( 562)		 ::box2D::common::math::B2Mat22 tMat = xf2->R;
HXLINE( 567)		tVec = circle->m_p;
HXLINE( 568)		Float xf21 = xf2->position->x;
HXDLIN( 568)		Float cX = (tMat->col1->x * tVec->x);
HXDLIN( 568)		Float cX1 = (xf21 + (cX + (tMat->col2->x * tVec->y)));
HXLINE( 569)		Float xf22 = xf2->position->y;
HXDLIN( 569)		Float cY = (tMat->col1->y * tVec->x);
HXDLIN( 569)		Float cY1 = (xf22 + (cY + (tMat->col2->y * tVec->y)));
HXLINE( 572)		dX = (cX1 - xf1->position->x);
HXLINE( 573)		dY = (cY1 - xf1->position->y);
HXLINE( 574)		tMat = xf1->R;
HXLINE( 575)		Float cLocalX = (dX * tMat->col1->x);
HXDLIN( 575)		Float cLocalX1 = (cLocalX + (dY * tMat->col1->y));
HXLINE( 576)		Float cLocalY = (dX * tMat->col2->x);
HXDLIN( 576)		Float cLocalY1 = (cLocalY + (dY * tMat->col2->y));
HXLINE( 578)		Float dist;
HXLINE( 581)		int normalIndex = (int)0;
HXLINE( 582)		Float separation = ((Float)-1.7976931348623157e+308);
HXLINE( 583)		Float radius = (polygon->m_radius + circle->m_radius);
HXLINE( 584)		int vertexCount = polygon->m_vertexCount;
HXLINE( 585)		::Array< ::Dynamic> vertices = polygon->m_vertices;
HXLINE( 586)		::Array< ::Dynamic> normals = polygon->m_normals;
HXLINE( 588)		{
HXLINE( 588)			int _g1 = (int)0;
HXDLIN( 588)			int _g = vertexCount;
HXDLIN( 588)			while((_g1 < _g)){
HXLINE( 588)				_g1 = (_g1 + (int)1);
HXDLIN( 588)				int i = (_g1 - (int)1);
HXLINE( 591)				tVec = vertices->__get(i).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXLINE( 592)				dX = (cLocalX1 - tVec->x);
HXLINE( 593)				dY = (cLocalY1 - tVec->y);
HXLINE( 594)				tVec = normals->__get(i).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXLINE( 595)				Float s = (tVec->x * dX);
HXDLIN( 595)				Float s1 = (s + (tVec->y * dY));
HXLINE( 597)				if ((s1 > radius)) {
HXLINE( 600)					return;
            				}
HXLINE( 603)				if ((s1 > separation)) {
HXLINE( 605)					separation = s1;
HXLINE( 606)					normalIndex = i;
            				}
            			}
            		}
HXLINE( 610)		int vertIndex1 = normalIndex;
HXLINE( 611)		int vertIndex2;
HXDLIN( 611)		if (((vertIndex1 + (int)1) < vertexCount)) {
HXLINE( 611)			vertIndex2 = (vertIndex1 + (int)1);
            		}
            		else {
HXLINE( 611)			vertIndex2 = (int)0;
            		}
HXLINE( 612)		 ::box2D::common::math::B2Vec2 v1 = vertices->__get(vertIndex1).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXLINE( 613)		 ::box2D::common::math::B2Vec2 v2 = vertices->__get(vertIndex2).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXLINE( 616)		if ((separation < ((Float)2.2250738585072014e-308))) {
HXLINE( 618)			manifold->m_pointCount = (int)1;
HXLINE( 619)			manifold->m_type = (int)2;
HXLINE( 620)			{
HXLINE( 620)				 ::box2D::common::math::B2Vec2 _this = manifold->m_localPlaneNormal;
HXDLIN( 620)				 ::box2D::common::math::B2Vec2 v = normals->__get(normalIndex).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXDLIN( 620)				_this->x = v->x;
HXDLIN( 620)				_this->y = v->y;
            			}
HXLINE( 621)			manifold->m_localPoint->x = (((Float)0.5) * (v1->x + v2->x));
HXLINE( 622)			manifold->m_localPoint->y = (((Float)0.5) * (v1->y + v2->y));
HXLINE( 623)			{
HXLINE( 623)				 ::box2D::common::math::B2Vec2 _this1 = manifold->m_points->__get((int)0).StaticCast<  ::box2D::collision::B2ManifoldPoint >()->m_localPoint;
HXDLIN( 623)				 ::box2D::common::math::B2Vec2 v3 = circle->m_p;
HXDLIN( 623)				_this1->x = v3->x;
HXDLIN( 623)				_this1->y = v3->y;
            			}
HXLINE( 624)			manifold->m_points->__get((int)0).StaticCast<  ::box2D::collision::B2ManifoldPoint >()->m_id->set_key((int)0);
HXLINE( 625)			return;
            		}
HXLINE( 629)		Float u1 = (cLocalX1 - v1->x);
HXDLIN( 629)		Float u11 = (u1 * (v2->x - v1->x));
HXDLIN( 629)		Float u12 = (cLocalY1 - v1->y);
HXDLIN( 629)		Float u13 = (u11 + (u12 * (v2->y - v1->y)));
HXLINE( 630)		Float u2 = (cLocalX1 - v2->x);
HXDLIN( 630)		Float u21 = (u2 * (v1->x - v2->x));
HXDLIN( 630)		Float u22 = (cLocalY1 - v2->y);
HXDLIN( 630)		Float u23 = (u21 + (u22 * (v1->y - v2->y)));
HXLINE( 631)		if ((u13 <= ((Float)0.0))) {
HXLINE( 633)			Float _hx_tmp = (cLocalX1 - v1->x);
HXDLIN( 633)			Float _hx_tmp1 = (_hx_tmp * (cLocalX1 - v1->x));
HXDLIN( 633)			Float _hx_tmp2 = (cLocalY1 - v1->y);
HXDLIN( 633)			Float _hx_tmp3 = (_hx_tmp1 + (_hx_tmp2 * (cLocalY1 - v1->y)));
HXDLIN( 633)			if ((_hx_tmp3 > (radius * radius))) {
HXLINE( 634)				return;
            			}
HXLINE( 635)			manifold->m_pointCount = (int)1;
HXLINE( 636)			manifold->m_type = (int)2;
HXLINE( 637)			manifold->m_localPlaneNormal->x = (cLocalX1 - v1->x);
HXLINE( 638)			manifold->m_localPlaneNormal->y = (cLocalY1 - v1->y);
HXLINE( 639)			manifold->m_localPlaneNormal->normalize();
HXLINE( 640)			{
HXLINE( 640)				 ::box2D::common::math::B2Vec2 _this2 = manifold->m_localPoint;
HXDLIN( 640)				_this2->x = v1->x;
HXDLIN( 640)				_this2->y = v1->y;
            			}
HXLINE( 641)			{
HXLINE( 641)				 ::box2D::common::math::B2Vec2 _this3 = manifold->m_points->__get((int)0).StaticCast<  ::box2D::collision::B2ManifoldPoint >()->m_localPoint;
HXDLIN( 641)				 ::box2D::common::math::B2Vec2 v4 = circle->m_p;
HXDLIN( 641)				_this3->x = v4->x;
HXDLIN( 641)				_this3->y = v4->y;
            			}
HXLINE( 642)			manifold->m_points->__get((int)0).StaticCast<  ::box2D::collision::B2ManifoldPoint >()->m_id->set_key((int)0);
            		}
            		else {
HXLINE( 644)			if ((u23 <= (int)0)) {
HXLINE( 646)				Float _hx_tmp4 = (cLocalX1 - v2->x);
HXDLIN( 646)				Float _hx_tmp5 = (_hx_tmp4 * (cLocalX1 - v2->x));
HXDLIN( 646)				Float _hx_tmp6 = (cLocalY1 - v2->y);
HXDLIN( 646)				Float _hx_tmp7 = (_hx_tmp5 + (_hx_tmp6 * (cLocalY1 - v2->y)));
HXDLIN( 646)				if ((_hx_tmp7 > (radius * radius))) {
HXLINE( 647)					return;
            				}
HXLINE( 648)				manifold->m_pointCount = (int)1;
HXLINE( 649)				manifold->m_type = (int)2;
HXLINE( 650)				manifold->m_localPlaneNormal->x = (cLocalX1 - v2->x);
HXLINE( 651)				manifold->m_localPlaneNormal->y = (cLocalY1 - v2->y);
HXLINE( 652)				manifold->m_localPlaneNormal->normalize();
HXLINE( 653)				{
HXLINE( 653)					 ::box2D::common::math::B2Vec2 _this4 = manifold->m_localPoint;
HXDLIN( 653)					_this4->x = v2->x;
HXDLIN( 653)					_this4->y = v2->y;
            				}
HXLINE( 654)				{
HXLINE( 654)					 ::box2D::common::math::B2Vec2 _this5 = manifold->m_points->__get((int)0).StaticCast<  ::box2D::collision::B2ManifoldPoint >()->m_localPoint;
HXDLIN( 654)					 ::box2D::common::math::B2Vec2 v5 = circle->m_p;
HXDLIN( 654)					_this5->x = v5->x;
HXDLIN( 654)					_this5->y = v5->y;
            				}
HXLINE( 655)				manifold->m_points->__get((int)0).StaticCast<  ::box2D::collision::B2ManifoldPoint >()->m_id->set_key((int)0);
            			}
            			else {
HXLINE( 659)				Float faceCenterX = (((Float)0.5) * (v1->x + v2->x));
HXLINE( 660)				Float faceCenterY = (((Float)0.5) * (v1->y + v2->y));
HXLINE( 661)				Float separation1 = ((cLocalX1 - faceCenterX) * normals->__get(vertIndex1).StaticCast<  ::box2D::common::math::B2Vec2 >()->x);
HXDLIN( 661)				separation = (separation1 + ((cLocalY1 - faceCenterY) * normals->__get(vertIndex1).StaticCast<  ::box2D::common::math::B2Vec2 >()->y));
HXLINE( 662)				if ((separation > radius)) {
HXLINE( 663)					return;
            				}
HXLINE( 664)				manifold->m_pointCount = (int)1;
HXLINE( 665)				manifold->m_type = (int)2;
HXLINE( 666)				manifold->m_localPlaneNormal->x = normals->__get(vertIndex1).StaticCast<  ::box2D::common::math::B2Vec2 >()->x;
HXLINE( 667)				manifold->m_localPlaneNormal->y = normals->__get(vertIndex1).StaticCast<  ::box2D::common::math::B2Vec2 >()->y;
HXLINE( 668)				manifold->m_localPlaneNormal->normalize();
HXLINE( 669)				{
HXLINE( 669)					 ::box2D::common::math::B2Vec2 _this6 = manifold->m_localPoint;
HXDLIN( 669)					_this6->x = faceCenterX;
HXDLIN( 669)					_this6->y = faceCenterY;
            				}
HXLINE( 670)				{
HXLINE( 670)					 ::box2D::common::math::B2Vec2 _this7 = manifold->m_points->__get((int)0).StaticCast<  ::box2D::collision::B2ManifoldPoint >()->m_localPoint;
HXDLIN( 670)					 ::box2D::common::math::B2Vec2 v6 = circle->m_p;
HXDLIN( 670)					_this7->x = v6->x;
HXDLIN( 670)					_this7->y = v6->y;
            				}
HXLINE( 671)				manifold->m_points->__get((int)0).StaticCast<  ::box2D::collision::B2ManifoldPoint >()->m_id->set_key((int)0);
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(B2Collision_obj,collidePolygonAndCircle,(void))

bool B2Collision_obj::testOverlap( ::box2D::collision::B2AABB a, ::box2D::collision::B2AABB b){
            	HX_STACKFRAME(&_hx_pos_11df19b5b3fde1b2_679_testOverlap)
HXLINE( 680)		 ::box2D::common::math::B2Vec2 t1 = b->lowerBound;
HXLINE( 681)		 ::box2D::common::math::B2Vec2 t2 = a->upperBound;
HXLINE( 683)		Float d1X = (t1->x - t2->x);
HXLINE( 684)		Float d1Y = (t1->y - t2->y);
HXLINE( 686)		t1 = a->lowerBound;
HXLINE( 687)		t2 = b->upperBound;
HXLINE( 688)		Float d2X = (t1->x - t2->x);
HXLINE( 689)		Float d2Y = (t1->y - t2->y);
HXLINE( 691)		bool _hx_tmp;
HXDLIN( 691)		if (!((d1X > ((Float)0.0)))) {
HXLINE( 691)			_hx_tmp = (d1Y > ((Float)0.0));
            		}
            		else {
HXLINE( 691)			_hx_tmp = true;
            		}
HXDLIN( 691)		if (_hx_tmp) {
HXLINE( 692)			return false;
            		}
HXLINE( 694)		bool _hx_tmp1;
HXDLIN( 694)		if (!((d2X > ((Float)0.0)))) {
HXLINE( 694)			_hx_tmp1 = (d2Y > ((Float)0.0));
            		}
            		else {
HXLINE( 694)			_hx_tmp1 = true;
            		}
HXDLIN( 694)		if (_hx_tmp1) {
HXLINE( 695)			return false;
            		}
HXLINE( 697)		return true;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(B2Collision_obj,testOverlap,return )


B2Collision_obj::B2Collision_obj()
{
}

bool B2Collision_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"s_v11") ) { outValue = ( s_v11 ); return true; }
		if (HX_FIELD_EQ(inName,"s_v12") ) { outValue = ( s_v12 ); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"s_edgeAO") ) { outValue = ( s_edgeAO ); return true; }
		if (HX_FIELD_EQ(inName,"s_edgeBO") ) { outValue = ( s_edgeBO ); return true; }
		if (HX_FIELD_EQ(inName,"s_normal") ) { outValue = ( s_normal ); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"s_tangent") ) { outValue = ( s_tangent ); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"s_tangent2") ) { outValue = ( s_tangent2 ); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"testOverlap") ) { outValue = testOverlap_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"s_planePoint") ) { outValue = ( s_planePoint ); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"s_clipPoints1") ) { outValue = ( s_clipPoints1 ); return true; }
		if (HX_FIELD_EQ(inName,"s_clipPoints2") ) { outValue = ( s_clipPoints2 ); return true; }
		if (HX_FIELD_EQ(inName,"s_localNormal") ) { outValue = ( s_localNormal ); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"b2_nullFeature") ) { outValue = ( b2_nullFeature ); return true; }
		if (HX_FIELD_EQ(inName,"edgeSeparation") ) { outValue = edgeSeparation_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"s_incidentEdge") ) { outValue = ( s_incidentEdge ); return true; }
		if (HX_FIELD_EQ(inName,"s_localTangent") ) { outValue = ( s_localTangent ); return true; }
		if (HX_FIELD_EQ(inName,"collideCircles") ) { outValue = collideCircles_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"collidePolygons") ) { outValue = collidePolygons_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"findIncidentEdge") ) { outValue = findIncidentEdge_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"clipSegmentToLine") ) { outValue = clipSegmentToLine_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"findMaxSeparation") ) { outValue = findMaxSeparation_dyn(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"makeClipPointVector") ) { outValue = makeClipPointVector_dyn(); return true; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"b2CollidePolyTempVec") ) { outValue = ( b2CollidePolyTempVec ); return true; }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"collidePolygonAndCircle") ) { outValue = collidePolygonAndCircle_dyn(); return true; }
	}
	return false;
}

bool B2Collision_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"s_v11") ) { s_v11=ioValue.Cast<  ::box2D::common::math::B2Vec2 >(); return true; }
		if (HX_FIELD_EQ(inName,"s_v12") ) { s_v12=ioValue.Cast<  ::box2D::common::math::B2Vec2 >(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"s_edgeAO") ) { s_edgeAO=ioValue.Cast< ::Array< int > >(); return true; }
		if (HX_FIELD_EQ(inName,"s_edgeBO") ) { s_edgeBO=ioValue.Cast< ::Array< int > >(); return true; }
		if (HX_FIELD_EQ(inName,"s_normal") ) { s_normal=ioValue.Cast<  ::box2D::common::math::B2Vec2 >(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"s_tangent") ) { s_tangent=ioValue.Cast<  ::box2D::common::math::B2Vec2 >(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"s_tangent2") ) { s_tangent2=ioValue.Cast<  ::box2D::common::math::B2Vec2 >(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"s_planePoint") ) { s_planePoint=ioValue.Cast<  ::box2D::common::math::B2Vec2 >(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"s_clipPoints1") ) { s_clipPoints1=ioValue.Cast< ::Array< ::Dynamic> >(); return true; }
		if (HX_FIELD_EQ(inName,"s_clipPoints2") ) { s_clipPoints2=ioValue.Cast< ::Array< ::Dynamic> >(); return true; }
		if (HX_FIELD_EQ(inName,"s_localNormal") ) { s_localNormal=ioValue.Cast<  ::box2D::common::math::B2Vec2 >(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"b2_nullFeature") ) { b2_nullFeature=ioValue.Cast< int >(); return true; }
		if (HX_FIELD_EQ(inName,"s_incidentEdge") ) { s_incidentEdge=ioValue.Cast< ::Array< ::Dynamic> >(); return true; }
		if (HX_FIELD_EQ(inName,"s_localTangent") ) { s_localTangent=ioValue.Cast<  ::box2D::common::math::B2Vec2 >(); return true; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"b2CollidePolyTempVec") ) { b2CollidePolyTempVec=ioValue.Cast<  ::box2D::common::math::B2Vec2 >(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *B2Collision_obj_sMemberStorageInfo = 0;
static hx::StaticInfo B2Collision_obj_sStaticStorageInfo[] = {
	{hx::fsInt,(void *) &B2Collision_obj::b2_nullFeature,HX_HCSTRING("b2_nullFeature","\x80","\x86","\x85","\xd4")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(void *) &B2Collision_obj::s_incidentEdge,HX_HCSTRING("s_incidentEdge","\x3b","\xdd","\x82","\x42")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(void *) &B2Collision_obj::s_clipPoints1,HX_HCSTRING("s_clipPoints1","\xb2","\x0e","\x79","\x5a")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(void *) &B2Collision_obj::s_clipPoints2,HX_HCSTRING("s_clipPoints2","\xb3","\x0e","\x79","\x5a")},
	{hx::fsObject /*Array< int >*/ ,(void *) &B2Collision_obj::s_edgeAO,HX_HCSTRING("s_edgeAO","\xf7","\x9f","\x9f","\x5a")},
	{hx::fsObject /*Array< int >*/ ,(void *) &B2Collision_obj::s_edgeBO,HX_HCSTRING("s_edgeBO","\xd6","\xa0","\x9f","\x5a")},
	{hx::fsObject /*::box2D::common::math::B2Vec2*/ ,(void *) &B2Collision_obj::s_localTangent,HX_HCSTRING("s_localTangent","\x26","\xd5","\x29","\x67")},
	{hx::fsObject /*::box2D::common::math::B2Vec2*/ ,(void *) &B2Collision_obj::s_localNormal,HX_HCSTRING("s_localNormal","\xe6","\x20","\x26","\xa9")},
	{hx::fsObject /*::box2D::common::math::B2Vec2*/ ,(void *) &B2Collision_obj::s_planePoint,HX_HCSTRING("s_planePoint","\xe0","\xa3","\x13","\xc0")},
	{hx::fsObject /*::box2D::common::math::B2Vec2*/ ,(void *) &B2Collision_obj::s_normal,HX_HCSTRING("s_normal","\xb3","\xc7","\x89","\x50")},
	{hx::fsObject /*::box2D::common::math::B2Vec2*/ ,(void *) &B2Collision_obj::s_tangent,HX_HCSTRING("s_tangent","\xb9","\x21","\xf8","\x36")},
	{hx::fsObject /*::box2D::common::math::B2Vec2*/ ,(void *) &B2Collision_obj::s_tangent2,HX_HCSTRING("s_tangent2","\x59","\x60","\x25","\xe2")},
	{hx::fsObject /*::box2D::common::math::B2Vec2*/ ,(void *) &B2Collision_obj::s_v11,HX_HCSTRING("s_v11","\xca","\xaf","\x39","\x76")},
	{hx::fsObject /*::box2D::common::math::B2Vec2*/ ,(void *) &B2Collision_obj::s_v12,HX_HCSTRING("s_v12","\xcb","\xaf","\x39","\x76")},
	{hx::fsObject /*::box2D::common::math::B2Vec2*/ ,(void *) &B2Collision_obj::b2CollidePolyTempVec,HX_HCSTRING("b2CollidePolyTempVec","\x86","\xa1","\xc4","\x72")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static void B2Collision_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(B2Collision_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(B2Collision_obj::b2_nullFeature,"b2_nullFeature");
	HX_MARK_MEMBER_NAME(B2Collision_obj::s_incidentEdge,"s_incidentEdge");
	HX_MARK_MEMBER_NAME(B2Collision_obj::s_clipPoints1,"s_clipPoints1");
	HX_MARK_MEMBER_NAME(B2Collision_obj::s_clipPoints2,"s_clipPoints2");
	HX_MARK_MEMBER_NAME(B2Collision_obj::s_edgeAO,"s_edgeAO");
	HX_MARK_MEMBER_NAME(B2Collision_obj::s_edgeBO,"s_edgeBO");
	HX_MARK_MEMBER_NAME(B2Collision_obj::s_localTangent,"s_localTangent");
	HX_MARK_MEMBER_NAME(B2Collision_obj::s_localNormal,"s_localNormal");
	HX_MARK_MEMBER_NAME(B2Collision_obj::s_planePoint,"s_planePoint");
	HX_MARK_MEMBER_NAME(B2Collision_obj::s_normal,"s_normal");
	HX_MARK_MEMBER_NAME(B2Collision_obj::s_tangent,"s_tangent");
	HX_MARK_MEMBER_NAME(B2Collision_obj::s_tangent2,"s_tangent2");
	HX_MARK_MEMBER_NAME(B2Collision_obj::s_v11,"s_v11");
	HX_MARK_MEMBER_NAME(B2Collision_obj::s_v12,"s_v12");
	HX_MARK_MEMBER_NAME(B2Collision_obj::b2CollidePolyTempVec,"b2CollidePolyTempVec");
};

#ifdef HXCPP_VISIT_ALLOCS
static void B2Collision_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(B2Collision_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(B2Collision_obj::b2_nullFeature,"b2_nullFeature");
	HX_VISIT_MEMBER_NAME(B2Collision_obj::s_incidentEdge,"s_incidentEdge");
	HX_VISIT_MEMBER_NAME(B2Collision_obj::s_clipPoints1,"s_clipPoints1");
	HX_VISIT_MEMBER_NAME(B2Collision_obj::s_clipPoints2,"s_clipPoints2");
	HX_VISIT_MEMBER_NAME(B2Collision_obj::s_edgeAO,"s_edgeAO");
	HX_VISIT_MEMBER_NAME(B2Collision_obj::s_edgeBO,"s_edgeBO");
	HX_VISIT_MEMBER_NAME(B2Collision_obj::s_localTangent,"s_localTangent");
	HX_VISIT_MEMBER_NAME(B2Collision_obj::s_localNormal,"s_localNormal");
	HX_VISIT_MEMBER_NAME(B2Collision_obj::s_planePoint,"s_planePoint");
	HX_VISIT_MEMBER_NAME(B2Collision_obj::s_normal,"s_normal");
	HX_VISIT_MEMBER_NAME(B2Collision_obj::s_tangent,"s_tangent");
	HX_VISIT_MEMBER_NAME(B2Collision_obj::s_tangent2,"s_tangent2");
	HX_VISIT_MEMBER_NAME(B2Collision_obj::s_v11,"s_v11");
	HX_VISIT_MEMBER_NAME(B2Collision_obj::s_v12,"s_v12");
	HX_VISIT_MEMBER_NAME(B2Collision_obj::b2CollidePolyTempVec,"b2CollidePolyTempVec");
};

#endif

hx::Class B2Collision_obj::__mClass;

static ::String B2Collision_obj_sStaticFields[] = {
	HX_HCSTRING("b2_nullFeature","\x80","\x86","\x85","\xd4"),
	HX_HCSTRING("clipSegmentToLine","\x32","\xee","\x6b","\x91"),
	HX_HCSTRING("edgeSeparation","\xe3","\xc2","\xf9","\x6d"),
	HX_HCSTRING("findMaxSeparation","\x11","\xbc","\x0b","\x51"),
	HX_HCSTRING("findIncidentEdge","\x88","\xe4","\x59","\x12"),
	HX_HCSTRING("makeClipPointVector","\xf5","\x19","\x2e","\x51"),
	HX_HCSTRING("s_incidentEdge","\x3b","\xdd","\x82","\x42"),
	HX_HCSTRING("s_clipPoints1","\xb2","\x0e","\x79","\x5a"),
	HX_HCSTRING("s_clipPoints2","\xb3","\x0e","\x79","\x5a"),
	HX_HCSTRING("s_edgeAO","\xf7","\x9f","\x9f","\x5a"),
	HX_HCSTRING("s_edgeBO","\xd6","\xa0","\x9f","\x5a"),
	HX_HCSTRING("s_localTangent","\x26","\xd5","\x29","\x67"),
	HX_HCSTRING("s_localNormal","\xe6","\x20","\x26","\xa9"),
	HX_HCSTRING("s_planePoint","\xe0","\xa3","\x13","\xc0"),
	HX_HCSTRING("s_normal","\xb3","\xc7","\x89","\x50"),
	HX_HCSTRING("s_tangent","\xb9","\x21","\xf8","\x36"),
	HX_HCSTRING("s_tangent2","\x59","\x60","\x25","\xe2"),
	HX_HCSTRING("s_v11","\xca","\xaf","\x39","\x76"),
	HX_HCSTRING("s_v12","\xcb","\xaf","\x39","\x76"),
	HX_HCSTRING("b2CollidePolyTempVec","\x86","\xa1","\xc4","\x72"),
	HX_HCSTRING("collidePolygons","\x57","\x42","\xff","\x67"),
	HX_HCSTRING("collideCircles","\x85","\xe0","\xdb","\x3a"),
	HX_HCSTRING("collidePolygonAndCircle","\x0b","\xc2","\xa6","\x15"),
	HX_HCSTRING("testOverlap","\x55","\x31","\xd9","\x65"),
	::String(null())
};

void B2Collision_obj::__register()
{
	hx::Object *dummy = new B2Collision_obj;
	B2Collision_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("box2D.collision.B2Collision","\x15","\x94","\x7b","\x08");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &B2Collision_obj::__GetStatic;
	__mClass->mSetStaticField = &B2Collision_obj::__SetStatic;
	__mClass->mMarkFunc = B2Collision_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(B2Collision_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< B2Collision_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = B2Collision_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = B2Collision_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = B2Collision_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void B2Collision_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_11df19b5b3fde1b2_37_boot)
HXDLIN(  37)		b2_nullFeature = (int)255;
            	}
{
            	HX_STACKFRAME(&_hx_pos_11df19b5b3fde1b2_337_boot)
HXDLIN( 337)		s_incidentEdge = ::box2D::collision::B2Collision_obj::makeClipPointVector();
            	}
{
            	HX_STACKFRAME(&_hx_pos_11df19b5b3fde1b2_338_boot)
HXDLIN( 338)		s_clipPoints1 = ::box2D::collision::B2Collision_obj::makeClipPointVector();
            	}
{
            	HX_STACKFRAME(&_hx_pos_11df19b5b3fde1b2_339_boot)
HXDLIN( 339)		s_clipPoints2 = ::box2D::collision::B2Collision_obj::makeClipPointVector();
            	}
{
            	HX_STACKFRAME(&_hx_pos_11df19b5b3fde1b2_340_boot)
HXDLIN( 340)		s_edgeAO = ::Array_obj< int >::__new();
            	}
{
            	HX_STACKFRAME(&_hx_pos_11df19b5b3fde1b2_341_boot)
HXDLIN( 341)		s_edgeBO = ::Array_obj< int >::__new();
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_11df19b5b3fde1b2_342_boot)
HXDLIN( 342)		s_localTangent =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_11df19b5b3fde1b2_343_boot)
HXDLIN( 343)		s_localNormal =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_11df19b5b3fde1b2_344_boot)
HXDLIN( 344)		s_planePoint =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_11df19b5b3fde1b2_345_boot)
HXDLIN( 345)		s_normal =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_11df19b5b3fde1b2_346_boot)
HXDLIN( 346)		s_tangent =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_11df19b5b3fde1b2_347_boot)
HXDLIN( 347)		s_tangent2 =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_11df19b5b3fde1b2_348_boot)
HXDLIN( 348)		s_v11 =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_11df19b5b3fde1b2_349_boot)
HXDLIN( 349)		s_v12 =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_11df19b5b3fde1b2_355_boot)
HXDLIN( 355)		b2CollidePolyTempVec =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,null(),null());
            	}
}

} // end namespace box2D
} // end namespace collision
