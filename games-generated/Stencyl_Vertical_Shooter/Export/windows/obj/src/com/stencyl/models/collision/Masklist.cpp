// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_Lambda
#include <Lambda.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_com_stencyl_models_Actor
#include <com/stencyl/models/Actor.h>
#endif
#ifndef INCLUDED_com_stencyl_models_GameModel
#include <com/stencyl/models/GameModel.h>
#endif
#ifndef INCLUDED_com_stencyl_models_collision_Hitbox
#include <com/stencyl/models/collision/Hitbox.h>
#endif
#ifndef INCLUDED_com_stencyl_models_collision_Mask
#include <com/stencyl/models/collision/Mask.h>
#endif
#ifndef INCLUDED_com_stencyl_models_collision_Masklist
#include <com/stencyl/models/collision/Masklist.h>
#endif
#ifndef INCLUDED_com_stencyl_utils_Utils
#include <com/stencyl/utils/Utils.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_f519071837067109_12_new,"com.stencyl.models.collision.Masklist","new",0x6fba8e2d,"com.stencyl.models.collision.Masklist.new","com/stencyl/models/collision/Masklist.hx",12,0x862655e3)
HX_LOCAL_STACK_FRAME(_hx_pos_f519071837067109_33_collide,"com.stencyl.models.collision.Masklist","collide",0xcc91d7cb,"com.stencyl.models.collision.Masklist.collide","com/stencyl/models/collision/Masklist.hx",33,0x862655e3)
HX_LOCAL_STACK_FRAME(_hx_pos_f519071837067109_57_collideMasklist,"com.stencyl.models.collision.Masklist","collideMasklist",0x1e9b1a35,"com.stencyl.models.collision.Masklist.collideMasklist","com/stencyl/models/collision/Masklist.hx",57,0x862655e3)
HX_LOCAL_STACK_FRAME(_hx_pos_f519071837067109_92_add,"com.stencyl.models.collision.Masklist","add",0x6fb0afee,"com.stencyl.models.collision.Masklist.add","com/stencyl/models/collision/Masklist.hx",92,0x862655e3)
HX_LOCAL_STACK_FRAME(_hx_pos_f519071837067109_124_remove,"com.stencyl.models.collision.Masklist","remove",0x2db6bc97,"com.stencyl.models.collision.Masklist.remove","com/stencyl/models/collision/Masklist.hx",124,0x862655e3)
HX_LOCAL_STACK_FRAME(_hx_pos_f519071837067109_150_removeAt,"com.stencyl.models.collision.Masklist","removeAt",0x1650896a,"com.stencyl.models.collision.Masklist.removeAt","com/stencyl/models/collision/Masklist.hx",150,0x862655e3)
HX_LOCAL_STACK_FRAME(_hx_pos_f519071837067109_173_removeAll,"com.stencyl.models.collision.Masklist","removeAll",0x7027acca,"com.stencyl.models.collision.Masklist.removeAll","com/stencyl/models/collision/Masklist.hx",173,0x862655e3)
HX_LOCAL_STACK_FRAME(_hx_pos_f519071837067109_189_getMask,"com.stencyl.models.collision.Masklist","getMask",0xfa0718ef,"com.stencyl.models.collision.Masklist.getMask","com/stencyl/models/collision/Masklist.hx",189,0x862655e3)
HX_LOCAL_STACK_FRAME(_hx_pos_f519071837067109_193_assignTo,"com.stencyl.models.collision.Masklist","assignTo",0x77fcd49d,"com.stencyl.models.collision.Masklist.assignTo","com/stencyl/models/collision/Masklist.hx",193,0x862655e3)
HX_LOCAL_STACK_FRAME(_hx_pos_f519071837067109_200_update,"com.stencyl.models.collision.Masklist","update",0xb033a65c,"com.stencyl.models.collision.Masklist.update","com/stencyl/models/collision/Masklist.hx",200,0x862655e3)
HX_LOCAL_STACK_FRAME(_hx_pos_f519071837067109_227_get_count,"com.stencyl.models.collision.Masklist","get_count",0x334f36b3,"com.stencyl.models.collision.Masklist.get_count","com/stencyl/models/collision/Masklist.hx",227,0x862655e3)
namespace com{
namespace stencyl{
namespace models{
namespace collision{

void Masklist_obj::__construct(::cpp::VirtualArray masks, ::com::stencyl::models::Actor par){
            	HX_STACKFRAME(&_hx_pos_f519071837067109_12_new)
HXLINE( 232)		this->_count = (int)0;
HXLINE(  20)		super::__construct(null(),null(),null(),null(),null(),null());
HXLINE(  21)		this->_masks = ::Array_obj< ::Dynamic>::__new();
HXLINE(  22)		this->_temp = ::Array_obj< ::Dynamic>::__new();
HXLINE(  24)		this->solid = false;
HXLINE(  25)		this->parent = par;
HXLINE(  27)		 ::com::stencyl::models::collision::Mask m;
HXLINE(  28)		{
HXLINE(  28)			int _g = (int)0;
HXDLIN(  28)			while((_g < masks->get_length())){
HXLINE(  28)				 ::Dynamic m1 = masks->__get(_g);
HXDLIN(  28)				_g = (_g + (int)1);
HXDLIN(  28)				this->add(( ( ::com::stencyl::models::collision::Mask)(m1) ));
            			}
            		}
            	}

Dynamic Masklist_obj::__CreateEmpty() { return new Masklist_obj; }

void *Masklist_obj::_hx_vtable = 0;

Dynamic Masklist_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Masklist_obj > _hx_result = new Masklist_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool Masklist_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x2ff29145) {
		if (inClassId<=(int)0x2d683423) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x2d683423;
		} else {
			return inClassId==(int)0x2ff29145;
		}
	} else {
		return inClassId==(int)0x6b714215;
	}
}

bool Masklist_obj::collide( ::com::stencyl::models::collision::Mask mask){
            	HX_STACKFRAME(&_hx_pos_f519071837067109_33_collide)
HXLINE(  34)		 ::com::stencyl::models::collision::Mask m;
HXLINE(  35)		{
HXLINE(  35)			int _g = (int)0;
HXDLIN(  35)			::Array< ::Dynamic> _g1 = this->_masks;
HXDLIN(  35)			while((_g < _g1->length)){
HXLINE(  35)				 ::com::stencyl::models::collision::Mask m1 = _g1->__get(_g).StaticCast<  ::com::stencyl::models::collision::Mask >();
HXDLIN(  35)				_g = (_g + (int)1);
HXLINE(  37)				int _hx_tmp;
HXDLIN(  37)				if ((m1->groupID == (int)-1000)) {
HXLINE(  37)					_hx_tmp = m1->parent->groupID;
            				}
            				else {
HXLINE(  37)					_hx_tmp = m1->groupID;
            				}
HXDLIN(  37)				m1->groupID = _hx_tmp;
HXLINE(  39)				bool _hx_tmp1;
HXDLIN(  39)				bool _hx_tmp2;
HXDLIN(  39)				bool _hx_tmp3;
HXDLIN(  39)				if (!(::Std_obj::is(mask,hx::ClassOf< ::com::stencyl::models::collision::Masklist >()))) {
HXLINE(  39)					_hx_tmp3 = (mask->groupID == (int)-2);
            				}
            				else {
HXLINE(  39)					_hx_tmp3 = true;
            				}
HXDLIN(  39)				if (!(_hx_tmp3)) {
HXLINE(  39)					_hx_tmp2 = ::com::stencyl::models::GameModel_obj::collisionMap->__get(m1->groupID).StaticCast< ::Array< bool > >()->__get(mask->groupID);
            				}
            				else {
HXLINE(  39)					_hx_tmp2 = true;
            				}
HXDLIN(  39)				if (_hx_tmp2) {
HXLINE(  39)					_hx_tmp1 = m1->collide(mask);
            				}
            				else {
HXLINE(  39)					_hx_tmp1 = false;
            				}
HXDLIN(  39)				if (_hx_tmp1) {
HXLINE(  41)					this->lastBounds->x = m1->lastBounds->x;
HXLINE(  42)					this->lastBounds->y = m1->lastBounds->y;
HXLINE(  43)					this->lastBounds->width = m1->lastBounds->width;
HXLINE(  44)					this->lastBounds->height = m1->lastBounds->height;
HXLINE(  46)					this->lastCheckedMask = m1;
HXLINE(  47)					this->lastColID = mask->groupID;
HXLINE(  49)					return true;
            				}
            			}
            		}
HXLINE(  52)		return false;
            	}


bool Masklist_obj::collideMasklist( ::com::stencyl::models::collision::Masklist other){
            	HX_STACKFRAME(&_hx_pos_f519071837067109_57_collideMasklist)
HXLINE(  58)		 ::com::stencyl::models::collision::Mask a;
HXLINE(  59)		 ::com::stencyl::models::collision::Mask b;
HXLINE(  60)		{
HXLINE(  60)			int _g = (int)0;
HXDLIN(  60)			::Array< ::Dynamic> _g1 = this->_masks;
HXDLIN(  60)			while((_g < _g1->length)){
HXLINE(  60)				 ::com::stencyl::models::collision::Mask a1 = _g1->__get(_g).StaticCast<  ::com::stencyl::models::collision::Mask >();
HXDLIN(  60)				_g = (_g + (int)1);
HXLINE(  62)				int _hx_tmp;
HXDLIN(  62)				if ((a1->groupID == (int)-1000)) {
HXLINE(  62)					_hx_tmp = a1->parent->groupID;
            				}
            				else {
HXLINE(  62)					_hx_tmp = a1->groupID;
            				}
HXDLIN(  62)				a1->groupID = _hx_tmp;
HXLINE(  64)				{
HXLINE(  64)					int _g2 = (int)0;
HXDLIN(  64)					::Array< ::Dynamic> _g3 = other->_masks;
HXDLIN(  64)					while((_g2 < _g3->length)){
HXLINE(  64)						 ::com::stencyl::models::collision::Mask b1 = _g3->__get(_g2).StaticCast<  ::com::stencyl::models::collision::Mask >();
HXDLIN(  64)						_g2 = (_g2 + (int)1);
HXLINE(  66)						int _hx_tmp1;
HXDLIN(  66)						if ((b1->groupID == (int)-1000)) {
HXLINE(  66)							_hx_tmp1 = b1->parent->groupID;
            						}
            						else {
HXLINE(  66)							_hx_tmp1 = b1->groupID;
            						}
HXDLIN(  66)						b1->groupID = _hx_tmp1;
HXLINE(  68)						if (a1->collide(b1)) {
HXLINE(  71)							other->lastBounds->x = b1->lastBounds->x;
HXLINE(  72)							other->lastBounds->y = b1->lastBounds->y;
HXLINE(  73)							other->lastBounds->width = b1->lastBounds->width;
HXLINE(  74)							other->lastBounds->height = b1->lastBounds->height;
HXLINE(  76)							other->lastCheckedMask = b1;
HXLINE(  77)							other->lastColID = a1->groupID;
HXLINE(  79)							return true;
            						}
            					}
            				}
            			}
            		}
HXLINE(  83)		return true;
            	}


 ::com::stencyl::models::collision::Mask Masklist_obj::add( ::com::stencyl::models::collision::Mask mask){
            	HX_STACKFRAME(&_hx_pos_f519071837067109_92_add)
HXLINE(  93)		::Array< ::Dynamic> _hx_tmp = this->_masks;
HXDLIN(  93)		_hx_tmp[this->_count++] = mask;
HXLINE(  94)		mask->list = hx::ObjectPtr<OBJ_>(this);
HXLINE(  95)		mask->parent = this->parent;
HXLINE(  96)		bool _hx_tmp1;
HXDLIN(  96)		if (!(this->solid)) {
HXLINE(  96)			_hx_tmp1 = mask->solid;
            		}
            		else {
HXLINE(  96)			_hx_tmp1 = true;
            		}
HXDLIN(  96)		this->solid = _hx_tmp1;
HXLINE(  97)		this->update();
HXLINE(  99)		int _hx_tmp2;
HXDLIN(  99)		if ((mask->groupID == (int)-1000)) {
HXLINE(  99)			_hx_tmp2 = this->parent->groupID;
            		}
            		else {
HXLINE(  99)			_hx_tmp2 = mask->groupID;
            		}
HXDLIN(  99)		mask->groupID = _hx_tmp2;
HXLINE( 101)		::Dynamic this1 = ::com::stencyl::models::GameModel_obj::get()->groupsCollidesWith;
HXDLIN( 101)		::Array< int > colList = ( (::Array< int >)(( ( ::haxe::ds::IntMap)(this1) )->get(mask->groupID)) );
HXLINE( 102)		int i;
HXLINE( 104)		if (hx::IsNotNull( colList )) {
HXLINE( 106)			int _g = (int)0;
HXDLIN( 106)			while((_g < colList->length)){
HXLINE( 106)				int i1 = colList->__get(_g);
HXDLIN( 106)				_g = (_g + (int)1);
HXLINE( 108)				if (!(::com::stencyl::utils::Utils_obj::contains(this->collideTypes,i1))) {
HXLINE( 110)					this->collideTypes->push(i1);
            				}
            			}
            		}
HXLINE( 115)		return mask;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Masklist_obj,add,return )

 ::com::stencyl::models::collision::Mask Masklist_obj::remove( ::com::stencyl::models::collision::Mask mask){
            	HX_STACKFRAME(&_hx_pos_f519071837067109_124_remove)
HXLINE( 125)		if ((::Lambda_obj::indexOf(this->_masks,mask) < (int)0)) {
HXLINE( 125)			return mask;
            		}
HXLINE( 126)		{
HXLINE( 126)			::cpp::VirtualArray arr = this->_temp;
HXDLIN( 126)			arr->splice((int)0,arr->get_length());
            		}
HXLINE( 127)		 ::com::stencyl::models::collision::Mask m;
HXLINE( 128)		{
HXLINE( 128)			int _g = (int)0;
HXDLIN( 128)			::Array< ::Dynamic> _g1 = this->_masks;
HXDLIN( 128)			while((_g < _g1->length)){
HXLINE( 128)				 ::com::stencyl::models::collision::Mask m1 = _g1->__get(_g).StaticCast<  ::com::stencyl::models::collision::Mask >();
HXDLIN( 128)				_g = (_g + (int)1);
HXLINE( 130)				if (hx::IsEq( m1,mask )) {
HXLINE( 132)					mask->list = null();
HXLINE( 133)					mask->parent = null();
HXLINE( 134)					this->_count--;
HXLINE( 135)					this->update();
            				}
            				else {
HXLINE( 137)					this->_temp[this->_temp->length] = m1;
            				}
            			}
            		}
HXLINE( 139)		::Array< ::Dynamic> temp = this->_masks;
HXLINE( 140)		this->_masks = this->_temp;
HXLINE( 141)		this->_temp = temp;
HXLINE( 142)		return mask;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Masklist_obj,remove,return )

void Masklist_obj::removeAt(hx::Null< int >  __o_index){
int index = __o_index.Default(0);
            	HX_STACKFRAME(&_hx_pos_f519071837067109_150_removeAt)
HXLINE( 151)		{
HXLINE( 151)			::cpp::VirtualArray arr = this->_temp;
HXDLIN( 151)			arr->splice((int)0,arr->get_length());
            		}
HXLINE( 152)		int i = this->_masks->length;
HXLINE( 153)		index = hx::Mod(index,i);
HXLINE( 154)		while(true){
HXLINE( 154)			i = (i - (int)1);
HXDLIN( 154)			if (!(((i + (int)1) > (int)0))) {
HXLINE( 154)				goto _hx_goto_11;
            			}
HXLINE( 156)			if ((i == index)) {
HXLINE( 158)				this->_masks->__get(index).StaticCast<  ::com::stencyl::models::collision::Mask >()->list = null();
HXLINE( 159)				this->_count--;
HXLINE( 160)				this->update();
            			}
            			else {
HXLINE( 162)				::Array< ::Dynamic> _hx_tmp = this->_temp;
HXDLIN( 162)				int _hx_tmp1 = this->_temp->length;
HXDLIN( 162)				_hx_tmp[_hx_tmp1] = this->_masks->__get(index).StaticCast<  ::com::stencyl::models::collision::Mask >();
            			}
            		}
            		_hx_goto_11:;
HXLINE( 164)		::Array< ::Dynamic> temp = this->_masks;
HXLINE( 165)		this->_masks = this->_temp;
HXLINE( 166)		this->_temp = temp;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Masklist_obj,removeAt,(void))

void Masklist_obj::removeAll(){
            	HX_STACKFRAME(&_hx_pos_f519071837067109_173_removeAll)
HXLINE( 174)		 ::com::stencyl::models::collision::Mask m;
HXLINE( 175)		{
HXLINE( 175)			int _g = (int)0;
HXDLIN( 175)			::Array< ::Dynamic> _g1 = this->_masks;
HXDLIN( 175)			while((_g < _g1->length)){
HXLINE( 175)				 ::com::stencyl::models::collision::Mask m1 = _g1->__get(_g).StaticCast<  ::com::stencyl::models::collision::Mask >();
HXDLIN( 175)				_g = (_g + (int)1);
HXDLIN( 175)				m1->list = null();
            			}
            		}
HXLINE( 176)		this->_count = (int)0;
HXLINE( 177)		{
HXLINE( 177)			::cpp::VirtualArray arr = this->_masks;
HXDLIN( 177)			arr->splice((int)0,arr->get_length());
            		}
HXLINE( 178)		{
HXLINE( 178)			::cpp::VirtualArray arr1 = this->_temp;
HXDLIN( 178)			arr1->splice((int)0,arr1->get_length());
            		}
HXLINE( 179)		this->update();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Masklist_obj,removeAll,(void))

 ::com::stencyl::models::collision::Mask Masklist_obj::getMask(hx::Null< int >  __o_index){
int index = __o_index.Default(0);
            	HX_STACKFRAME(&_hx_pos_f519071837067109_189_getMask)
HXDLIN( 189)		::Array< ::Dynamic> _hx_tmp = this->_masks;
HXDLIN( 189)		return _hx_tmp->__get(hx::Mod(index,this->_masks->length)).StaticCast<  ::com::stencyl::models::collision::Mask >();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Masklist_obj,getMask,return )

void Masklist_obj::assignTo( ::com::stencyl::models::Actor parent){
            	HX_STACKFRAME(&_hx_pos_f519071837067109_193_assignTo)
HXLINE( 194)		{
HXLINE( 194)			int _g = (int)0;
HXDLIN( 194)			::Array< ::Dynamic> _g1 = this->_masks;
HXDLIN( 194)			while((_g < _g1->length)){
HXLINE( 194)				 ::com::stencyl::models::collision::Mask m = _g1->__get(_g).StaticCast<  ::com::stencyl::models::collision::Mask >();
HXDLIN( 194)				_g = (_g + (int)1);
HXDLIN( 194)				m->parent = parent;
            			}
            		}
HXLINE( 195)		this->super::assignTo(parent);
            	}


void Masklist_obj::update(){
            	HX_STACKFRAME(&_hx_pos_f519071837067109_200_update)
HXLINE( 202)		int t = (int)100000;
HXDLIN( 202)		int l = (int)100000;
HXDLIN( 202)		int r = (int)0;
HXDLIN( 202)		int b = (int)0;
HXDLIN( 202)		 ::com::stencyl::models::collision::Hitbox h;
HXDLIN( 202)		int i = this->_count;
HXLINE( 203)		while(true){
HXLINE( 203)			i = (i - (int)1);
HXDLIN( 203)			if (!(((i + (int)1) > (int)0))) {
HXLINE( 203)				goto _hx_goto_18;
            			}
HXLINE( 205)			h = hx::TCast<  ::com::stencyl::models::collision::Hitbox >::cast(this->_masks->__get(i).StaticCast<  ::com::stencyl::models::collision::Mask >());
HXDLIN( 205)			if (hx::IsNotNull( h )) {
HXLINE( 207)				if ((h->_x < l)) {
HXLINE( 207)					l = h->_x;
            				}
HXLINE( 208)				if ((h->_y < t)) {
HXLINE( 208)					t = h->_y;
            				}
HXLINE( 209)				if (((h->_x + h->_width) > r)) {
HXLINE( 209)					r = (h->_x + h->_width);
            				}
HXLINE( 210)				if (((h->_y + h->_height) > b)) {
HXLINE( 210)					b = (h->_y + h->_height);
            				}
            			}
            		}
            		_hx_goto_18:;
HXLINE( 215)		this->_x = l;
HXLINE( 216)		this->_y = t;
HXLINE( 217)		this->_width = (r - l);
HXLINE( 218)		this->_height = (b - t);
HXLINE( 220)		this->super::update();
            	}


int Masklist_obj::get_count(){
            	HX_STACKFRAME(&_hx_pos_f519071837067109_227_get_count)
HXDLIN( 227)		return this->_count;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Masklist_obj,get_count,return )


hx::ObjectPtr< Masklist_obj > Masklist_obj::__new(::cpp::VirtualArray masks, ::com::stencyl::models::Actor par) {
	hx::ObjectPtr< Masklist_obj > __this = new Masklist_obj();
	__this->__construct(masks,par);
	return __this;
}

hx::ObjectPtr< Masklist_obj > Masklist_obj::__alloc(hx::Ctx *_hx_ctx,::cpp::VirtualArray masks, ::com::stencyl::models::Actor par) {
	Masklist_obj *__this = (Masklist_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Masklist_obj), true, "com.stencyl.models.collision.Masklist"));
	*(void **)__this = Masklist_obj::_hx_vtable;
	__this->__construct(masks,par);
	return __this;
}

Masklist_obj::Masklist_obj()
{
}

void Masklist_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Masklist);
	HX_MARK_MEMBER_NAME(count,"count");
	HX_MARK_MEMBER_NAME(_masks,"_masks");
	HX_MARK_MEMBER_NAME(_temp,"_temp");
	HX_MARK_MEMBER_NAME(_count,"_count");
	 ::com::stencyl::models::collision::Mask_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void Masklist_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(count,"count");
	HX_VISIT_MEMBER_NAME(_masks,"_masks");
	HX_VISIT_MEMBER_NAME(_temp,"_temp");
	HX_VISIT_MEMBER_NAME(_count,"_count");
	 ::com::stencyl::models::collision::Mask_obj::__Visit(HX_VISIT_ARG);
}

hx::Val Masklist_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"add") ) { return hx::Val( add_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"count") ) { return hx::Val( inCallProp == hx::paccAlways ? get_count() : count ); }
		if (HX_FIELD_EQ(inName,"_temp") ) { return hx::Val( _temp ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"remove") ) { return hx::Val( remove_dyn() ); }
		if (HX_FIELD_EQ(inName,"update") ) { return hx::Val( update_dyn() ); }
		if (HX_FIELD_EQ(inName,"_masks") ) { return hx::Val( _masks ); }
		if (HX_FIELD_EQ(inName,"_count") ) { return hx::Val( _count ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"collide") ) { return hx::Val( collide_dyn() ); }
		if (HX_FIELD_EQ(inName,"getMask") ) { return hx::Val( getMask_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"removeAt") ) { return hx::Val( removeAt_dyn() ); }
		if (HX_FIELD_EQ(inName,"assignTo") ) { return hx::Val( assignTo_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"removeAll") ) { return hx::Val( removeAll_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_count") ) { return hx::Val( get_count_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"collideMasklist") ) { return hx::Val( collideMasklist_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val Masklist_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"count") ) { count=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_temp") ) { _temp=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"_masks") ) { _masks=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_count") ) { _count=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Masklist_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("count","\xcf","\x44","\x63","\x4a"));
	outFields->push(HX_HCSTRING("_masks","\x48","\xd5","\x09","\xff"));
	outFields->push(HX_HCSTRING("_temp","\xf3","\xde","\x0a","\x00"));
	outFields->push(HX_HCSTRING("_count","\x10","\x8c","\x4a","\x46"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Masklist_obj_sMemberStorageInfo[] = {
	{hx::fsInt,(int)offsetof(Masklist_obj,count),HX_HCSTRING("count","\xcf","\x44","\x63","\x4a")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Masklist_obj,_masks),HX_HCSTRING("_masks","\x48","\xd5","\x09","\xff")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Masklist_obj,_temp),HX_HCSTRING("_temp","\xf3","\xde","\x0a","\x00")},
	{hx::fsInt,(int)offsetof(Masklist_obj,_count),HX_HCSTRING("_count","\x10","\x8c","\x4a","\x46")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Masklist_obj_sStaticStorageInfo = 0;
#endif

static ::String Masklist_obj_sMemberFields[] = {
	HX_HCSTRING("collide","\x7e","\xaf","\x63","\xed"),
	HX_HCSTRING("collideMasklist","\xe8","\x5c","\x68","\x36"),
	HX_HCSTRING("add","\x21","\xf2","\x49","\x00"),
	HX_HCSTRING("remove","\x44","\x9c","\x88","\x04"),
	HX_HCSTRING("removeAt","\x57","\x6e","\x1b","\xad"),
	HX_HCSTRING("removeAll","\x3d","\x17","\xe5","\xca"),
	HX_HCSTRING("getMask","\xa2","\xf0","\xd8","\x1a"),
	HX_HCSTRING("assignTo","\x8a","\xb9","\xc7","\x0e"),
	HX_HCSTRING("update","\x09","\x86","\x05","\x87"),
	HX_HCSTRING("count","\xcf","\x44","\x63","\x4a"),
	HX_HCSTRING("get_count","\x26","\xa1","\x0c","\x8e"),
	HX_HCSTRING("_masks","\x48","\xd5","\x09","\xff"),
	HX_HCSTRING("_temp","\xf3","\xde","\x0a","\x00"),
	HX_HCSTRING("_count","\x10","\x8c","\x4a","\x46"),
	::String(null()) };

static void Masklist_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Masklist_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Masklist_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Masklist_obj::__mClass,"__mClass");
};

#endif

hx::Class Masklist_obj::__mClass;

void Masklist_obj::__register()
{
	hx::Object *dummy = new Masklist_obj;
	Masklist_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("com.stencyl.models.collision.Masklist","\xbb","\xf3","\x1a","\xb1");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Masklist_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Masklist_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Masklist_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Masklist_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Masklist_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Masklist_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace com
} // end namespace stencyl
} // end namespace models
} // end namespace collision
