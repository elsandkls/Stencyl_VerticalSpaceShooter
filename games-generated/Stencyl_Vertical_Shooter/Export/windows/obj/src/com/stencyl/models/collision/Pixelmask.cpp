// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_Type
#include <Type.h>
#endif
#ifndef INCLUDED_com_stencyl_models_Actor
#include <com/stencyl/models/Actor.h>
#endif
#ifndef INCLUDED_com_stencyl_models_collision_Hitbox
#include <com/stencyl/models/collision/Hitbox.h>
#endif
#ifndef INCLUDED_com_stencyl_models_collision_Mask
#include <com/stencyl/models/collision/Mask.h>
#endif
#ifndef INCLUDED_com_stencyl_models_collision_Pixelmask
#include <com/stencyl/models/collision/Pixelmask.h>
#endif
#ifndef INCLUDED_com_stencyl_utils_Utils
#include <com/stencyl/utils/Utils.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_fb09b5e6a28d7738_27_new,"com.stencyl.models.collision.Pixelmask","new",0xbc6e9a53,"com.stencyl.models.collision.Pixelmask.new","com/stencyl/models/collision/Pixelmask.hx",27,0x800b107d)
HX_LOCAL_STACK_FRAME(_hx_pos_fb09b5e6a28d7738_55_collideMask,"com.stencyl.models.collision.Pixelmask","collideMask",0xe6c6287d,"com.stencyl.models.collision.Pixelmask.collideMask","com/stencyl/models/collision/Pixelmask.hx",55,0x800b107d)
HX_LOCAL_STACK_FRAME(_hx_pos_fb09b5e6a28d7738_71_collideHitbox,"com.stencyl.models.collision.Pixelmask","collideHitbox",0x5f0d9b69,"com.stencyl.models.collision.Pixelmask.collideHitbox","com/stencyl/models/collision/Pixelmask.hx",71,0x800b107d)
HX_LOCAL_STACK_FRAME(_hx_pos_fb09b5e6a28d7738_87_collidePixelmask,"com.stencyl.models.collision.Pixelmask","collidePixelmask",0x3050cd41,"com.stencyl.models.collision.Pixelmask.collidePixelmask","com/stencyl/models/collision/Pixelmask.hx",87,0x800b107d)
HX_LOCAL_STACK_FRAME(_hx_pos_fb09b5e6a28d7738_103_get_data,"com.stencyl.models.collision.Pixelmask","get_data",0xcc0356e0,"com.stencyl.models.collision.Pixelmask.get_data","com/stencyl/models/collision/Pixelmask.hx",103,0x800b107d)
HX_LOCAL_STACK_FRAME(_hx_pos_fb09b5e6a28d7738_105_set_data,"com.stencyl.models.collision.Pixelmask","set_data",0x7a60b054,"com.stencyl.models.collision.Pixelmask.set_data","com/stencyl/models/collision/Pixelmask.hx",105,0x800b107d)
namespace com{
namespace stencyl{
namespace models{
namespace collision{

void Pixelmask_obj::__construct( ::Dynamic source,hx::Null< int >  __o_x,hx::Null< int >  __o_y){
int x = __o_x.Default(0);
int y = __o_y.Default(0);
            	HX_STACKFRAME(&_hx_pos_fb09b5e6a28d7738_27_new)
HXLINE(  28)		super::__construct(null(),null(),null(),null(),null(),null());
HXLINE(  31)		if (::Std_obj::is(source,hx::ClassOf< ::openfl::display::BitmapData >())) {
HXLINE(  31)			this->_data = ( ( ::openfl::display::BitmapData)(source) );
            		}
HXLINE(  33)		if (hx::IsNull( this->_data )) {
HXLINE(  33)			HX_STACK_DO_THROW(HX_("Invalid Pixelmask source image.",81,66,7f,96));
            		}
HXLINE(  35)		this->threshold = (int)1;
HXLINE(  37)		this->_rect = ::com::stencyl::utils::Utils_obj::rect;
HXLINE(  38)		this->_point = ::com::stencyl::utils::Utils_obj::point;
HXLINE(  39)		this->_point2 = ::com::stencyl::utils::Utils_obj::point2;
HXLINE(  42)		this->_width = this->get_data()->width;
HXLINE(  43)		this->_height = this->get_data()->height;
HXLINE(  44)		this->_x = x;
HXLINE(  45)		this->_y = y;
HXLINE(  48)		{
HXLINE(  48)			::Dynamic this1 = this->_check;
HXDLIN(  48)			( ( ::haxe::ds::StringMap)(this1) )->set(::Type_obj::getClassName(hx::ClassOf< ::com::stencyl::models::collision::Mask >()),this->collideMask_dyn());
            		}
HXLINE(  49)		{
HXLINE(  49)			::Dynamic this2 = this->_check;
HXDLIN(  49)			( ( ::haxe::ds::StringMap)(this2) )->set(::Type_obj::getClassName(hx::ClassOf< ::com::stencyl::models::collision::Pixelmask >()),this->collidePixelmask_dyn());
            		}
HXLINE(  50)		{
HXLINE(  50)			::Dynamic this3 = this->_check;
HXDLIN(  50)			( ( ::haxe::ds::StringMap)(this3) )->set(::Type_obj::getClassName(hx::ClassOf< ::com::stencyl::models::collision::Hitbox >()),this->collideHitbox_dyn());
            		}
            	}

Dynamic Pixelmask_obj::__CreateEmpty() { return new Pixelmask_obj; }

void *Pixelmask_obj::_hx_vtable = 0;

Dynamic Pixelmask_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Pixelmask_obj > _hx_result = new Pixelmask_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2]);
	return _hx_result;
}

bool Pixelmask_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x3c8b8f79) {
		if (inClassId<=(int)0x2ff29145) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x2ff29145;
		} else {
			return inClassId==(int)0x3c8b8f79;
		}
	} else {
		return inClassId==(int)0x6b714215;
	}
}

bool Pixelmask_obj::collideMask( ::com::stencyl::models::collision::Mask other){
            	HX_STACKFRAME(&_hx_pos_fb09b5e6a28d7738_55_collideMask)
HXLINE(  56)		this->_point->x = (this->parent->colX + this->_x);
HXLINE(  57)		this->_point->y = (this->parent->colY + this->_y);
HXLINE(  58)		this->_rect->x = other->parent->colX;
HXLINE(  59)		this->_rect->y = other->parent->colY;
HXLINE(  60)		this->_rect->width = other->parent->cacheWidth;
HXLINE(  61)		this->_rect->height = other->parent->cacheHeight;
HXLINE(  65)		return false;
            	}


bool Pixelmask_obj::collideHitbox( ::com::stencyl::models::collision::Hitbox other){
            	HX_STACKFRAME(&_hx_pos_fb09b5e6a28d7738_71_collideHitbox)
HXLINE(  72)		this->_point->x = (this->parent->colX + this->_x);
HXLINE(  73)		this->_point->y = (this->parent->colY + this->_y);
HXLINE(  74)		this->_rect->x = (other->parent->colX + other->_x);
HXLINE(  75)		this->_rect->y = (other->parent->colY + other->_y);
HXLINE(  76)		this->_rect->width = other->_width;
HXLINE(  77)		this->_rect->height = other->_height;
HXLINE(  81)		return false;
            	}


bool Pixelmask_obj::collidePixelmask( ::com::stencyl::models::collision::Pixelmask other){
            	HX_STACKFRAME(&_hx_pos_fb09b5e6a28d7738_87_collidePixelmask)
HXLINE(  88)		this->_point->x = (this->parent->colX + this->_x);
HXLINE(  89)		this->_point->y = (this->parent->colY + this->_y);
HXLINE(  90)		this->_point2->x = (other->parent->colX + other->_x);
HXLINE(  91)		this->_point2->y = (other->parent->colY + other->_y);
HXLINE(  95)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Pixelmask_obj,collidePixelmask,return )

 ::openfl::display::BitmapData Pixelmask_obj::get_data(){
            	HX_STACKFRAME(&_hx_pos_fb09b5e6a28d7738_103_get_data)
HXDLIN( 103)		return this->_data;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Pixelmask_obj,get_data,return )

 ::openfl::display::BitmapData Pixelmask_obj::set_data( ::openfl::display::BitmapData value){
            	HX_STACKFRAME(&_hx_pos_fb09b5e6a28d7738_105_set_data)
HXLINE( 106)		this->_data = value;
HXLINE( 107)		this->_width = value->width;
HXLINE( 108)		this->_height = value->height;
HXLINE( 109)		this->update();
HXLINE( 110)		return this->_data;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Pixelmask_obj,set_data,return )


hx::ObjectPtr< Pixelmask_obj > Pixelmask_obj::__new( ::Dynamic source,hx::Null< int >  __o_x,hx::Null< int >  __o_y) {
	hx::ObjectPtr< Pixelmask_obj > __this = new Pixelmask_obj();
	__this->__construct(source,__o_x,__o_y);
	return __this;
}

hx::ObjectPtr< Pixelmask_obj > Pixelmask_obj::__alloc(hx::Ctx *_hx_ctx, ::Dynamic source,hx::Null< int >  __o_x,hx::Null< int >  __o_y) {
	Pixelmask_obj *__this = (Pixelmask_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Pixelmask_obj), true, "com.stencyl.models.collision.Pixelmask"));
	*(void **)__this = Pixelmask_obj::_hx_vtable;
	__this->__construct(source,__o_x,__o_y);
	return __this;
}

Pixelmask_obj::Pixelmask_obj()
{
}

void Pixelmask_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Pixelmask);
	HX_MARK_MEMBER_NAME(threshold,"threshold");
	HX_MARK_MEMBER_NAME(_data,"_data");
	HX_MARK_MEMBER_NAME(_rect,"_rect");
	HX_MARK_MEMBER_NAME(_point,"_point");
	HX_MARK_MEMBER_NAME(_point2,"_point2");
	 ::com::stencyl::models::collision::Mask_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void Pixelmask_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(threshold,"threshold");
	HX_VISIT_MEMBER_NAME(_data,"_data");
	HX_VISIT_MEMBER_NAME(_rect,"_rect");
	HX_VISIT_MEMBER_NAME(_point,"_point");
	HX_VISIT_MEMBER_NAME(_point2,"_point2");
	 ::com::stencyl::models::collision::Mask_obj::__Visit(HX_VISIT_ARG);
}

hx::Val Pixelmask_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"data") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_data() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"_data") ) { return hx::Val( _data ); }
		if (HX_FIELD_EQ(inName,"_rect") ) { return hx::Val( _rect ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"_point") ) { return hx::Val( _point ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"_point2") ) { return hx::Val( _point2 ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"get_data") ) { return hx::Val( get_data_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_data") ) { return hx::Val( set_data_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"threshold") ) { return hx::Val( threshold ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"collideMask") ) { return hx::Val( collideMask_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"collideHitbox") ) { return hx::Val( collideHitbox_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"collidePixelmask") ) { return hx::Val( collidePixelmask_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val Pixelmask_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"data") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_data(inValue.Cast<  ::openfl::display::BitmapData >()) ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"_data") ) { _data=inValue.Cast<  ::openfl::display::BitmapData >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_rect") ) { _rect=inValue.Cast<  ::openfl::geom::Rectangle >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"_point") ) { _point=inValue.Cast<  ::openfl::geom::Point >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"_point2") ) { _point2=inValue.Cast<  ::openfl::geom::Point >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"threshold") ) { threshold=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Pixelmask_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("threshold","\xab","\xc3","\xa3","\x34"));
	outFields->push(HX_HCSTRING("data","\x2a","\x56","\x63","\x42"));
	outFields->push(HX_HCSTRING("_data","\x09","\x72","\x74","\xf5"));
	outFields->push(HX_HCSTRING("_rect","\x03","\x69","\xb8","\xfe"));
	outFields->push(HX_HCSTRING("_point","\x91","\xfb","\x76","\xc2"));
	outFields->push(HX_HCSTRING("_point2","\x81","\x23","\xa5","\x65"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Pixelmask_obj_sMemberStorageInfo[] = {
	{hx::fsInt,(int)offsetof(Pixelmask_obj,threshold),HX_HCSTRING("threshold","\xab","\xc3","\xa3","\x34")},
	{hx::fsObject /*::openfl::display::BitmapData*/ ,(int)offsetof(Pixelmask_obj,_data),HX_HCSTRING("_data","\x09","\x72","\x74","\xf5")},
	{hx::fsObject /*::openfl::geom::Rectangle*/ ,(int)offsetof(Pixelmask_obj,_rect),HX_HCSTRING("_rect","\x03","\x69","\xb8","\xfe")},
	{hx::fsObject /*::openfl::geom::Point*/ ,(int)offsetof(Pixelmask_obj,_point),HX_HCSTRING("_point","\x91","\xfb","\x76","\xc2")},
	{hx::fsObject /*::openfl::geom::Point*/ ,(int)offsetof(Pixelmask_obj,_point2),HX_HCSTRING("_point2","\x81","\x23","\xa5","\x65")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Pixelmask_obj_sStaticStorageInfo = 0;
#endif

static ::String Pixelmask_obj_sMemberFields[] = {
	HX_HCSTRING("threshold","\xab","\xc3","\xa3","\x34"),
	HX_HCSTRING("collideMask","\x8a","\xb3","\x13","\xba"),
	HX_HCSTRING("collideHitbox","\xb6","\xc3","\x1d","\xc9"),
	HX_HCSTRING("collidePixelmask","\x14","\x13","\xaf","\x13"),
	HX_HCSTRING("get_data","\xb3","\x11","\x1e","\xc2"),
	HX_HCSTRING("set_data","\x27","\x6b","\x7b","\x70"),
	HX_HCSTRING("_data","\x09","\x72","\x74","\xf5"),
	HX_HCSTRING("_rect","\x03","\x69","\xb8","\xfe"),
	HX_HCSTRING("_point","\x91","\xfb","\x76","\xc2"),
	HX_HCSTRING("_point2","\x81","\x23","\xa5","\x65"),
	::String(null()) };

static void Pixelmask_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Pixelmask_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Pixelmask_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Pixelmask_obj::__mClass,"__mClass");
};

#endif

hx::Class Pixelmask_obj::__mClass;

void Pixelmask_obj::__register()
{
	hx::Object *dummy = new Pixelmask_obj;
	Pixelmask_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("com.stencyl.models.collision.Pixelmask","\xe1","\x74","\x40","\xf5");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Pixelmask_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Pixelmask_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Pixelmask_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Pixelmask_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Pixelmask_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Pixelmask_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace com
} // end namespace stencyl
} // end namespace models
} // end namespace collision
