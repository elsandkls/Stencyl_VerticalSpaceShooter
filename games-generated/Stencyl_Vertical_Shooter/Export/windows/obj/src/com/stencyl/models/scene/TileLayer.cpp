// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_box2D_dynamics_B2BodyDef
#include <box2D/dynamics/B2BodyDef.h>
#endif
#ifndef INCLUDED_com_stencyl_Config
#include <com/stencyl/Config.h>
#endif
#ifndef INCLUDED_com_stencyl_Engine
#include <com/stencyl/Engine.h>
#endif
#ifndef INCLUDED_com_stencyl_graphics_EngineScaleUpdateListener
#include <com/stencyl/graphics/EngineScaleUpdateListener.h>
#endif
#ifndef INCLUDED_com_stencyl_models_Actor
#include <com/stencyl/models/Actor.h>
#endif
#ifndef INCLUDED_com_stencyl_models_Resource
#include <com/stencyl/models/Resource.h>
#endif
#ifndef INCLUDED_com_stencyl_models_Scene
#include <com/stencyl/models/Scene.h>
#endif
#ifndef INCLUDED_com_stencyl_models_actor_ActorType
#include <com/stencyl/models/actor/ActorType.h>
#endif
#ifndef INCLUDED_com_stencyl_models_actor_Group
#include <com/stencyl/models/actor/Group.h>
#endif
#ifndef INCLUDED_com_stencyl_models_actor_Sprite
#include <com/stencyl/models/actor/Sprite.h>
#endif
#ifndef INCLUDED_com_stencyl_models_collision_Grid
#include <com/stencyl/models/collision/Grid.h>
#endif
#ifndef INCLUDED_com_stencyl_models_collision_Hitbox
#include <com/stencyl/models/collision/Hitbox.h>
#endif
#ifndef INCLUDED_com_stencyl_models_collision_Mask
#include <com/stencyl/models/collision/Mask.h>
#endif
#ifndef INCLUDED_com_stencyl_models_scene_Autotile
#include <com/stencyl/models/scene/Autotile.h>
#endif
#ifndef INCLUDED_com_stencyl_models_scene_AutotileFormat
#include <com/stencyl/models/scene/AutotileFormat.h>
#endif
#ifndef INCLUDED_com_stencyl_models_scene_Tile
#include <com/stencyl/models/scene/Tile.h>
#endif
#ifndef INCLUDED_com_stencyl_models_scene_TileLayer
#include <com/stencyl/models/scene/TileLayer.h>
#endif
#ifndef INCLUDED_com_stencyl_models_scene_Tileset
#include <com/stencyl/models/scene/Tileset.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_haxe_ds_ObjectMap
#include <haxe/ds/ObjectMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_ITileContainer
#include <openfl/display/ITileContainer.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_display_Tile
#include <openfl/display/Tile.h>
#endif
#ifndef INCLUDED_openfl_display_Tilemap
#include <openfl/display/Tilemap.h>
#endif
#ifndef INCLUDED_openfl_display_Tileset
#include <openfl/display/Tileset.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_d6f18a9be126aac1_53_new,"com.stencyl.models.scene.TileLayer","new",0x00774cfe,"com.stencyl.models.scene.TileLayer.new","com/stencyl/models/scene/TileLayer.hx",53,0xe7cbb0b2)
HX_LOCAL_STACK_FRAME(_hx_pos_d6f18a9be126aac1_106_clear,"com.stencyl.models.scene.TileLayer","clear",0x35cdd1ab,"com.stencyl.models.scene.TileLayer.clear","com/stencyl/models/scene/TileLayer.hx",106,0xe7cbb0b2)
HX_LOCAL_STACK_FRAME(_hx_pos_d6f18a9be126aac1_139_setPosition,"com.stencyl.models.scene.TileLayer","setPosition",0x7659b509,"com.stencyl.models.scene.TileLayer.setPosition","com/stencyl/models/scene/TileLayer.hx",139,0xe7cbb0b2)
HX_LOCAL_STACK_FRAME(_hx_pos_d6f18a9be126aac1_151_mountGrid,"com.stencyl.models.scene.TileLayer","mountGrid",0xe0223c5d,"com.stencyl.models.scene.TileLayer.mountGrid","com/stencyl/models/scene/TileLayer.hx",151,0xe7cbb0b2)
HX_LOCAL_STACK_FRAME(_hx_pos_d6f18a9be126aac1_188_setTileAt,"com.stencyl.models.scene.TileLayer","setTileAt",0xc9f7e821,"com.stencyl.models.scene.TileLayer.setTileAt","com/stencyl/models/scene/TileLayer.hx",188,0xe7cbb0b2)
HX_LOCAL_STACK_FRAME(_hx_pos_d6f18a9be126aac1_222_getTileAt,"com.stencyl.models.scene.TileLayer","getTileAt",0xe6a6fc15,"com.stencyl.models.scene.TileLayer.getTileAt","com/stencyl/models/scene/TileLayer.hx",222,0xe7cbb0b2)
HX_LOCAL_STACK_FRAME(_hx_pos_d6f18a9be126aac1_234_updateAutotilesNear,"com.stencyl.models.scene.TileLayer","updateAutotilesNear",0xd87b8c93,"com.stencyl.models.scene.TileLayer.updateAutotilesNear","com/stencyl/models/scene/TileLayer.hx",234,0xe7cbb0b2)
HX_LOCAL_STACK_FRAME(_hx_pos_d6f18a9be126aac1_259_updateAutotile,"com.stencyl.models.scene.TileLayer","updateAutotile",0xc46f2d68,"com.stencyl.models.scene.TileLayer.updateAutotile","com/stencyl/models/scene/TileLayer.hx",259,0xe7cbb0b2)
HX_LOCAL_STACK_FRAME(_hx_pos_d6f18a9be126aac1_296_draw,"com.stencyl.models.scene.TileLayer","draw",0x6159b9a6,"com.stencyl.models.scene.TileLayer.draw","com/stencyl/models/scene/TileLayer.hx",296,0xe7cbb0b2)
HX_LOCAL_STACK_FRAME(_hx_pos_d6f18a9be126aac1_440_updateScale,"com.stencyl.models.scene.TileLayer","updateScale",0xd965825f,"com.stencyl.models.scene.TileLayer.updateScale","com/stencyl/models/scene/TileLayer.hx",440,0xe7cbb0b2)
HX_LOCAL_STACK_FRAME(_hx_pos_d6f18a9be126aac1_451_getTilemap,"com.stencyl.models.scene.TileLayer","getTilemap",0xeb96e95a,"com.stencyl.models.scene.TileLayer.getTilemap","com/stencyl/models/scene/TileLayer.hx",451,0xe7cbb0b2)
HX_LOCAL_STACK_FRAME(_hx_pos_d6f18a9be126aac1_49_resetStatics,"com.stencyl.models.scene.TileLayer","resetStatics",0xcbc68198,"com.stencyl.models.scene.TileLayer.resetStatics","com/stencyl/models/scene/TileLayer.hx",49,0xe7cbb0b2)
HX_LOCAL_STACK_FRAME(_hx_pos_d6f18a9be126aac1_44_boot,"com.stencyl.models.scene.TileLayer","boot",0x600511d4,"com.stencyl.models.scene.TileLayer.boot","com/stencyl/models/scene/TileLayer.hx",44,0xe7cbb0b2)
HX_LOCAL_STACK_FRAME(_hx_pos_d6f18a9be126aac1_45_boot,"com.stencyl.models.scene.TileLayer","boot",0x600511d4,"com.stencyl.models.scene.TileLayer.boot","com/stencyl/models/scene/TileLayer.hx",45,0xe7cbb0b2)
HX_LOCAL_STACK_FRAME(_hx_pos_d6f18a9be126aac1_247_boot,"com.stencyl.models.scene.TileLayer","boot",0x600511d4,"com.stencyl.models.scene.TileLayer.boot","com/stencyl/models/scene/TileLayer.hx",247,0xe7cbb0b2)
namespace com{
namespace stencyl{
namespace models{
namespace scene{

void TileLayer_obj::__construct(int layerID, ::com::stencyl::models::Scene scene,int numCols,int numRows){
            	HX_GC_STACKFRAME(&_hx_pos_d6f18a9be126aac1_53_new)
HXLINE(  54)		super::__construct();
HXLINE(  56)		this->layerID = layerID;
HXLINE(  58)		this->scene = scene;
HXLINE(  59)		this->numRows = numRows;
HXLINE(  60)		this->numCols = numCols;
HXLINE(  61)		this->clear();
HXLINE(  66)		this->tilemaps =  ::haxe::ds::ObjectMap_obj::__alloc( HX_CTX );
            	}

Dynamic TileLayer_obj::__CreateEmpty() { return new TileLayer_obj; }

void *TileLayer_obj::_hx_vtable = 0;

Dynamic TileLayer_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< TileLayer_obj > _hx_result = new TileLayer_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3]);
	return _hx_result;
}

bool TileLayer_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x19c29573) {
		if (inClassId<=(int)0x17120186) {
			if (inClassId<=(int)0x0ddfced7) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x0ddfced7;
			} else {
				return inClassId==(int)0x17120186;
			}
		} else {
			return inClassId==(int)0x19c29573;
		}
	} else {
		if (inClassId<=(int)0x1df2a24c) {
			return inClassId==(int)0x1b123bf8 || inClassId==(int)0x1df2a24c;
		} else {
			return inClassId==(int)0x3f2b00af;
		}
	}
}

static ::com::stencyl::graphics::EngineScaleUpdateListener_obj _hx_com_stencyl_models_scene_TileLayer__hx_com_stencyl_graphics_EngineScaleUpdateListener= {
	( void (hx::Object::*)())&::com::stencyl::models::scene::TileLayer_obj::updateScale,
};

void *TileLayer_obj::_hx_getInterface(int inHash) {
	switch(inHash) {
		case (int)0xac8361ef: return &_hx_com_stencyl_models_scene_TileLayer__hx_com_stencyl_graphics_EngineScaleUpdateListener;
	}
	return super::_hx_getInterface(inHash);
}

void TileLayer_obj::clear(){
            	HX_STACKFRAME(&_hx_pos_d6f18a9be126aac1_106_clear)
HXLINE( 114)		if (hx::IsNotNull( this->tilemaps )) {
HXLINE( 115)			 ::Dynamic tm = this->tilemaps->iterator();
HXDLIN( 115)			while(( (bool)(tm->__Field(HX_("hasNext",6d,a5,46,18),hx::paccDynamic)()) )){
HXLINE( 115)				 ::openfl::display::Tilemap tm1 = ( ( ::openfl::display::Tilemap)(tm->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)()) );
HXLINE( 116)				tm1->removeTiles(null(),null());
            			}
            		}
HXLINE( 120)		this->noTiles = true;
HXLINE( 122)		this->rows = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 123)		this->autotileData = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 125)		{
HXLINE( 125)			int _g1 = (int)0;
HXDLIN( 125)			int _g = this->numRows;
HXDLIN( 125)			while((_g1 < _g)){
HXLINE( 125)				_g1 = (_g1 + (int)1);
HXDLIN( 125)				int row = (_g1 - (int)1);
HXLINE( 127)				this->rows[row] = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 128)				this->autotileData[row] = ::Array_obj< int >::__new(0);
HXLINE( 130)				{
HXLINE( 130)					int _g3 = (int)0;
HXDLIN( 130)					int _g2 = this->numCols;
HXDLIN( 130)					while((_g3 < _g2)){
HXLINE( 130)						_g3 = (_g3 + (int)1);
HXDLIN( 130)						int col = (_g3 - (int)1);
HXLINE( 132)						this->rows->__get(row).StaticCast< ::Array< ::Dynamic> >()[col] = null();
HXLINE( 133)						this->autotileData->__get(row).StaticCast< ::Array< int > >()[col] = (int)0;
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(TileLayer_obj,clear,(void))

void TileLayer_obj::setPosition(int x,int y){
            	HX_STACKFRAME(&_hx_pos_d6f18a9be126aac1_139_setPosition)
            	}


HX_DEFINE_DYNAMIC_FUNC2(TileLayer_obj,setPosition,(void))

void TileLayer_obj::mountGrid(){
            	HX_GC_STACKFRAME(&_hx_pos_d6f18a9be126aac1_151_mountGrid)
HXLINE( 152)		if (hx::IsNull( this->grid )) {
HXLINE( 154)			return;
            		}
HXLINE( 159)		 ::com::stencyl::Engine a = ::com::stencyl::Engine_obj::engine;
HXLINE( 165)		int a1 = this->grid->get_width();
HXLINE( 166)		int a2 = this->grid->get_height();
HXLINE( 157)		 ::com::stencyl::models::Actor a3 =  ::com::stencyl::models::Actor_obj::__alloc( HX_CTX ,a,(int)100000000,(int)1,(int)0,(int)0,(int)-1,a1,a2,null(), ::haxe::ds::StringMap_obj::__alloc( HX_CTX ),null(),null(),false,true,false,false,this->grid,::com::stencyl::Engine_obj::NO_PHYSICS,null(),null());
HXLINE( 179)		a3->set_name(HX_("Terrain",95,d3,68,f6));
HXLINE( 180)		a3->typeID = (int)-1;
HXLINE( 181)		a3->set_visible(false);
HXLINE( 182)		a3->ignoreGravity = true;
HXLINE( 184)		::com::stencyl::Engine_obj::engine->getGroup((int)1,null())->addChild(a3);
            	}


HX_DEFINE_DYNAMIC_FUNC0(TileLayer_obj,mountGrid,(void))

void TileLayer_obj::setTileAt(int row,int col, ::com::stencyl::models::scene::Tile tile, ::Dynamic __o_updateAutotile){
 ::Dynamic updateAutotile = __o_updateAutotile.Default(true);
            	HX_STACKFRAME(&_hx_pos_d6f18a9be126aac1_188_setTileAt)
HXLINE( 189)		bool _hx_tmp;
HXDLIN( 189)		bool _hx_tmp1;
HXDLIN( 189)		bool _hx_tmp2;
HXDLIN( 189)		if ((col >= (int)0)) {
HXLINE( 189)			_hx_tmp2 = (row < (int)0);
            		}
            		else {
HXLINE( 189)			_hx_tmp2 = true;
            		}
HXDLIN( 189)		if (!(_hx_tmp2)) {
HXLINE( 189)			_hx_tmp1 = (col >= this->numCols);
            		}
            		else {
HXLINE( 189)			_hx_tmp1 = true;
            		}
HXDLIN( 189)		if (!(_hx_tmp1)) {
HXLINE( 189)			_hx_tmp = (row >= this->numRows);
            		}
            		else {
HXLINE( 189)			_hx_tmp = true;
            		}
HXDLIN( 189)		if (_hx_tmp) {
HXLINE( 191)			return;
            		}
HXLINE( 194)		bool _hx_tmp3;
HXDLIN( 194)		if (this->noTiles) {
HXLINE( 194)			_hx_tmp3 = hx::IsNotNull( tile );
            		}
            		else {
HXLINE( 194)			_hx_tmp3 = false;
            		}
HXDLIN( 194)		if (_hx_tmp3) {
HXLINE( 196)			this->noTiles = false;
            		}
HXLINE( 204)		 ::com::stencyl::models::scene::Tile old = this->rows->__get(row).StaticCast< ::Array< ::Dynamic> >()->__get(col).StaticCast<  ::com::stencyl::models::scene::Tile >();
HXLINE( 205)		if (updateAutotile) {
HXLINE( 208)			bool updateAutotile1;
HXDLIN( 208)			if (hx::IsNotNull( old )) {
HXLINE( 208)				updateAutotile1 = hx::IsNotNull( old->autotiles );
            			}
            			else {
HXLINE( 208)				updateAutotile1 = false;
            			}
HXDLIN( 208)			if (!(updateAutotile1)) {
HXLINE( 209)				if (hx::IsNotNull( tile )) {
HXLINE( 209)					updateAutotile = hx::IsNotNull( tile->autotiles );
            				}
            				else {
HXLINE( 209)					updateAutotile = false;
            				}
            			}
            			else {
HXLINE( 208)				updateAutotile = true;
            			}
            		}
HXLINE( 212)		this->rows->__get(row).StaticCast< ::Array< ::Dynamic> >()[col] = tile;
HXLINE( 213)		this->autotileData->__get(row).StaticCast< ::Array< int > >()[col] = (int)0;
HXLINE( 215)		if (updateAutotile) {
HXLINE( 217)			this->updateAutotilesNear(row,col);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(TileLayer_obj,setTileAt,(void))

 ::com::stencyl::models::scene::Tile TileLayer_obj::getTileAt(int row,int col){
            	HX_STACKFRAME(&_hx_pos_d6f18a9be126aac1_222_getTileAt)
HXLINE( 223)		bool _hx_tmp;
HXDLIN( 223)		bool _hx_tmp1;
HXDLIN( 223)		bool _hx_tmp2;
HXDLIN( 223)		if ((col >= (int)0)) {
HXLINE( 223)			_hx_tmp2 = (row < (int)0);
            		}
            		else {
HXLINE( 223)			_hx_tmp2 = true;
            		}
HXDLIN( 223)		if (!(_hx_tmp2)) {
HXLINE( 223)			_hx_tmp1 = (col >= this->numCols);
            		}
            		else {
HXLINE( 223)			_hx_tmp1 = true;
            		}
HXDLIN( 223)		if (!(_hx_tmp1)) {
HXLINE( 223)			_hx_tmp = (row >= this->numRows);
            		}
            		else {
HXLINE( 223)			_hx_tmp = true;
            		}
HXDLIN( 223)		if (_hx_tmp) {
HXLINE( 225)			return null();
            		}
HXLINE( 228)		return this->rows->__get(row).StaticCast< ::Array< ::Dynamic> >()->__get(col).StaticCast<  ::com::stencyl::models::scene::Tile >();
            	}


HX_DEFINE_DYNAMIC_FUNC2(TileLayer_obj,getTileAt,return )

void TileLayer_obj::updateAutotilesNear(int yc,int xc){
            	HX_STACKFRAME(&_hx_pos_d6f18a9be126aac1_234_updateAutotilesNear)
HXDLIN( 234)		int _g1 = (yc - (int)1);
HXDLIN( 234)		int _g = (yc + (int)2);
HXDLIN( 234)		while((_g1 < _g)){
HXDLIN( 234)			_g1 = (_g1 + (int)1);
HXDLIN( 234)			int y = (_g1 - (int)1);
HXLINE( 236)			{
HXLINE( 236)				int _g3 = (xc - (int)1);
HXDLIN( 236)				int _g2 = (xc + (int)2);
HXDLIN( 236)				while((_g3 < _g2)){
HXLINE( 236)					_g3 = (_g3 + (int)1);
HXDLIN( 236)					int x = (_g3 - (int)1);
HXLINE( 238)					bool _hx_tmp;
HXDLIN( 238)					bool _hx_tmp1;
HXDLIN( 238)					bool _hx_tmp2;
HXDLIN( 238)					if ((x >= (int)0)) {
HXLINE( 238)						_hx_tmp2 = (y < (int)0);
            					}
            					else {
HXLINE( 238)						_hx_tmp2 = true;
            					}
HXDLIN( 238)					if (!(_hx_tmp2)) {
HXLINE( 238)						_hx_tmp1 = (x >= this->numCols);
            					}
            					else {
HXLINE( 238)						_hx_tmp1 = true;
            					}
HXDLIN( 238)					if (!(_hx_tmp1)) {
HXLINE( 238)						_hx_tmp = (y >= this->numRows);
            					}
            					else {
HXLINE( 238)						_hx_tmp = true;
            					}
HXDLIN( 238)					if (_hx_tmp) {
HXLINE( 239)						continue;
            					}
HXLINE( 241)					this->updateAutotile(y,x);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(TileLayer_obj,updateAutotilesNear,(void))

void TileLayer_obj::updateAutotile(int y,int x){
            	HX_STACKFRAME(&_hx_pos_d6f18a9be126aac1_259_updateAutotile)
HXLINE( 260)		 ::com::stencyl::models::scene::Tile t = this->rows->__get(y).StaticCast< ::Array< ::Dynamic> >()->__get(x).StaticCast<  ::com::stencyl::models::scene::Tile >();
HXLINE( 263)		bool _hx_tmp;
HXDLIN( 263)		if (hx::IsNotNull( t )) {
HXLINE( 263)			_hx_tmp = hx::IsNull( t->autotiles );
            		}
            		else {
HXLINE( 263)			_hx_tmp = true;
            		}
HXDLIN( 263)		if (_hx_tmp) {
HXLINE( 265)			return;
            		}
HXLINE( 270)		int autotileFlags = (int)0;
HXLINE( 272)		{
HXLINE( 272)			 ::Dynamic flag = ::com::stencyl::models::scene::TileLayer_obj::autotileFlagPointMap->keys();
HXDLIN( 272)			while(( (bool)(flag->__Field(HX_("hasNext",6d,a5,46,18),hx::paccDynamic)()) )){
HXLINE( 272)				int flag1 = ( (int)(flag->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)()) );
HXLINE( 274)				 ::openfl::geom::Point point = ::com::stencyl::models::scene::TileLayer_obj::autotileFlagPointMap->get(flag1).StaticCast<  ::openfl::geom::Point >();
HXLINE( 275)				int col = ::Std_obj::_hx_int((x + point->x));
HXLINE( 276)				int row = ::Std_obj::_hx_int((y + point->y));
HXLINE( 280)				bool _hx_tmp1;
HXDLIN( 280)				bool _hx_tmp2;
HXDLIN( 280)				bool _hx_tmp3;
HXDLIN( 280)				bool _hx_tmp4;
HXDLIN( 280)				if ((col >= (int)0)) {
HXLINE( 280)					_hx_tmp4 = (row < (int)0);
            				}
            				else {
HXLINE( 280)					_hx_tmp4 = true;
            				}
HXDLIN( 280)				if (!(_hx_tmp4)) {
HXLINE( 280)					_hx_tmp3 = (col >= this->numCols);
            				}
            				else {
HXLINE( 280)					_hx_tmp3 = true;
            				}
HXDLIN( 280)				if (!(_hx_tmp3)) {
HXLINE( 280)					_hx_tmp2 = (row >= this->numRows);
            				}
            				else {
HXLINE( 280)					_hx_tmp2 = true;
            				}
HXDLIN( 280)				if (!(_hx_tmp2)) {
HXLINE( 280)					_hx_tmp1 = hx::IsEq( this->rows->__get(row).StaticCast< ::Array< ::Dynamic> >()->__get(col).StaticCast<  ::com::stencyl::models::scene::Tile >(),t );
            				}
            				else {
HXLINE( 280)					_hx_tmp1 = true;
            				}
HXDLIN( 280)				if (_hx_tmp1) {
HXLINE( 282)					continue;
            				}
HXLINE( 285)				autotileFlags = ((int)autotileFlags | (int)flag1);
            			}
            		}
HXLINE( 290)		::Array< int > _hx_tmp5 = this->autotileData->__get(y).StaticCast< ::Array< int > >();
HXDLIN( 290)		_hx_tmp5[x] = t->autotileFormat->animIndex->__get(autotileFlags);
            	}


HX_DEFINE_DYNAMIC_FUNC2(TileLayer_obj,updateAutotile,(void))

void TileLayer_obj::draw(int viewX,int viewY){
            	HX_GC_STACKFRAME(&_hx_pos_d6f18a9be126aac1_296_draw)
HXLINE( 297)		if (this->noTiles) {
HXLINE( 299)			return;
            		}
HXLINE( 304)		{
HXLINE( 304)			 ::Dynamic tm = this->tilemaps->iterator();
HXDLIN( 304)			while(( (bool)(tm->__Field(HX_("hasNext",6d,a5,46,18),hx::paccDynamic)()) )){
HXLINE( 304)				 ::openfl::display::Tilemap tm1 = ( ( ::openfl::display::Tilemap)(tm->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)()) );
HXLINE( 305)				tm1->removeTiles(null(),null());
            			}
            		}
HXLINE( 317)		viewX = ::Math_obj::floor(viewX);
HXLINE( 318)		viewY = ::Math_obj::floor(viewY);
HXLINE( 320)		int width = this->numCols;
HXLINE( 321)		int height = this->numRows;
HXLINE( 323)		int tw = this->scene->tileWidth;
HXLINE( 324)		int th = this->scene->tileHeight;
HXLINE( 326)		int startX = ::Std_obj::_hx_int(((Float)((Float)viewX / (Float)::com::stencyl::Engine_obj::SCALE) / (Float)tw));
HXLINE( 327)		int startY = ::Std_obj::_hx_int(((Float)((Float)viewY / (Float)::com::stencyl::Engine_obj::SCALE) / (Float)th));
HXLINE( 328)		int endX = (((int)2 + startX) + ::Std_obj::_hx_int(((Float)::com::stencyl::Engine_obj::screenWidth / (Float)tw)));
HXLINE( 329)		int endY = (((int)2 + startY) + ::Std_obj::_hx_int(((Float)::com::stencyl::Engine_obj::screenHeight / (Float)th)));
HXLINE( 331)		endX = ::Std_obj::_hx_int(::Math_obj::min(endX,width));
HXLINE( 332)		endY = ::Std_obj::_hx_int(::Math_obj::min(endY,height));
HXLINE( 334)		int px = (int)0;
HXLINE( 335)		int py = (int)0;
HXLINE( 337)		int y = startY;
HXLINE( 339)		while((y < endY)){
HXLINE( 341)			int x = startX;
HXLINE( 343)			while((x < endX)){
HXLINE( 345)				 ::com::stencyl::models::scene::Tile t = this->getTileAt(y,x);
HXLINE( 347)				if (hx::IsNull( t )) {
HXLINE( 349)					x = (x + (int)1);
HXLINE( 350)					px = (px + tw);
HXLINE( 351)					continue;
            				}
HXLINE( 364)				bool _hx_tmp;
HXDLIN( 364)				if (hx::IsNotNull( ::com::stencyl::models::scene::TileLayer_obj::cacheSource->get(((t->parent->ID * (int)1000000) + t->tileID)).StaticCast<  ::openfl::geom::Rectangle >() )) {
HXLINE( 364)					_hx_tmp = t->updateSource;
            				}
            				else {
HXLINE( 364)					_hx_tmp = true;
            				}
HXDLIN( 364)				if (_hx_tmp) {
HXLINE( 366)					t->updateSource = false;
HXLINE( 368)					bool _hx_tmp1;
HXDLIN( 368)					if (hx::IsNull( t->pixels )) {
HXLINE( 368)						_hx_tmp1 = hx::IsNull( t->autotiles );
            					}
            					else {
HXLINE( 368)						_hx_tmp1 = false;
            					}
HXDLIN( 368)					if (_hx_tmp1) {
HXLINE( 370)						::Dynamic this1 = ::com::stencyl::models::scene::TileLayer_obj::cacheSource;
HXDLIN( 370)						int key = ((t->parent->ID * (int)1000000) + t->tileID);
HXDLIN( 370)						( ( ::haxe::ds::IntMap)(this1) )->set(key,t->parent->getImageSourceForTile(t->tileID,tw,th));
            					}
            					else {
HXLINE( 375)						::Dynamic this2 = ::com::stencyl::models::scene::TileLayer_obj::cacheSource;
HXDLIN( 375)						int key1 = ((t->parent->ID * (int)1000000) + t->tileID);
HXDLIN( 375)						( ( ::haxe::ds::IntMap)(this2) )->set(key1,t->getSource(tw,th));
            					}
            				}
HXLINE( 379)				 ::openfl::geom::Rectangle source = ::com::stencyl::models::scene::TileLayer_obj::cacheSource->get(((t->parent->ID * (int)1000000) + t->tileID)).StaticCast<  ::openfl::geom::Rectangle >();
HXLINE( 381)				if (hx::IsNull( source )) {
HXLINE( 383)					x = (x + (int)1);
HXLINE( 384)					px = (px + tw);
HXLINE( 385)					continue;
            				}
HXLINE( 389)				if (hx::IsNotNull( t->autotiles )) {
HXLINE( 391)					::Array< ::Dynamic> t1 = t->autotiles;
HXDLIN( 391)					t = t1->__get(this->autotileData->__get(y).StaticCast< ::Array< int > >()->__get(x)).StaticCast<  ::com::stencyl::models::scene::Tile >();
            				}
HXLINE( 408)				if (hx::IsNull( t->data )) {
HXLINE( 410)					 ::Dynamic tileID = t->parent->sheetMap->get(t->tileID);
HXLINE( 411)					 ::openfl::display::Tilemap _hx_tmp2 = this->getTilemap(t->parent->flTileset);
HXDLIN( 411)					Float _hx_tmp3 = ((x * tw) * ::com::stencyl::Engine_obj::SCALE);
HXDLIN( 411)					_hx_tmp2->addTile( ::openfl::display::Tile_obj::__alloc( HX_CTX ,tileID,_hx_tmp3,((y * th) * ::com::stencyl::Engine_obj::SCALE),null(),null(),null(),null(),null()));
            				}
            				else {
HXLINE( 415)					int tileID1 = t->currFrame;
HXLINE( 416)					 ::openfl::display::Tilemap _hx_tmp4 = this->getTilemap(t->data);
HXDLIN( 416)					Float _hx_tmp5 = ((x * tw) * ::com::stencyl::Engine_obj::SCALE);
HXDLIN( 416)					_hx_tmp4->addTile( ::openfl::display::Tile_obj::__alloc( HX_CTX ,tileID1,_hx_tmp5,((y * th) * ::com::stencyl::Engine_obj::SCALE),null(),null(),null(),null(),null()));
            				}
HXLINE( 420)				x = (x + (int)1);
HXLINE( 421)				px = (px + tw);
            			}
HXLINE( 424)			px = (int)0;
HXLINE( 425)			py = (py + th);
HXLINE( 427)			y = (y + (int)1);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(TileLayer_obj,draw,(void))

void TileLayer_obj::updateScale(){
            	HX_STACKFRAME(&_hx_pos_d6f18a9be126aac1_440_updateScale)
HXDLIN( 440)		 ::Dynamic tilemap = this->tilemaps->iterator();
HXDLIN( 440)		while(( (bool)(tilemap->__Field(HX_("hasNext",6d,a5,46,18),hx::paccDynamic)()) )){
HXDLIN( 440)			 ::openfl::display::Tilemap tilemap1 = ( ( ::openfl::display::Tilemap)(tilemap->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)()) );
HXLINE( 442)			tilemap1->set_width((::com::stencyl::Engine_obj::sceneWidth * ::com::stencyl::Engine_obj::SCALE));
HXLINE( 443)			tilemap1->set_height((::com::stencyl::Engine_obj::sceneHeight * ::com::stencyl::Engine_obj::SCALE));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(TileLayer_obj,updateScale,(void))

 ::openfl::display::Tilemap TileLayer_obj::getTilemap( ::openfl::display::Tileset fltileset){
            	HX_GC_STACKFRAME(&_hx_pos_d6f18a9be126aac1_451_getTilemap)
HXLINE( 452)		if (!(this->tilemaps->exists(fltileset))) {
HXLINE( 455)			int tm = ::Std_obj::_hx_int((::com::stencyl::Engine_obj::sceneWidth * ::com::stencyl::Engine_obj::SCALE));
HXLINE( 456)			int tm1 = ::Std_obj::_hx_int((::com::stencyl::Engine_obj::sceneHeight * ::com::stencyl::Engine_obj::SCALE));
HXLINE( 454)			 ::openfl::display::Tilemap tm2 =  ::openfl::display::Tilemap_obj::__alloc( HX_CTX ,tm,tm1,fltileset,::com::stencyl::Config_obj::antialias);
HXLINE( 460)			this->tilemaps->set(fltileset,tm2);
HXLINE( 461)			this->addChild(tm2);
            		}
HXLINE( 463)		return this->tilemaps->get(fltileset).StaticCast<  ::openfl::display::Tilemap >();
            	}


HX_DEFINE_DYNAMIC_FUNC1(TileLayer_obj,getTilemap,return )

int TileLayer_obj::TILESET_CACHE_MULTIPLIER;

 ::haxe::ds::IntMap TileLayer_obj::cacheSource;

void TileLayer_obj::resetStatics(){
            	HX_GC_STACKFRAME(&_hx_pos_d6f18a9be126aac1_49_resetStatics)
HXDLIN(  49)		::com::stencyl::models::scene::TileLayer_obj::cacheSource =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(TileLayer_obj,resetStatics,(void))

 ::haxe::ds::IntMap TileLayer_obj::autotileFlagPointMap;


hx::ObjectPtr< TileLayer_obj > TileLayer_obj::__new(int layerID, ::com::stencyl::models::Scene scene,int numCols,int numRows) {
	hx::ObjectPtr< TileLayer_obj > __this = new TileLayer_obj();
	__this->__construct(layerID,scene,numCols,numRows);
	return __this;
}

hx::ObjectPtr< TileLayer_obj > TileLayer_obj::__alloc(hx::Ctx *_hx_ctx,int layerID, ::com::stencyl::models::Scene scene,int numCols,int numRows) {
	TileLayer_obj *__this = (TileLayer_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(TileLayer_obj), true, "com.stencyl.models.scene.TileLayer"));
	*(void **)__this = TileLayer_obj::_hx_vtable;
	__this->__construct(layerID,scene,numCols,numRows);
	return __this;
}

TileLayer_obj::TileLayer_obj()
{
}

void TileLayer_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(TileLayer);
	HX_MARK_MEMBER_NAME(layerID,"layerID");
	HX_MARK_MEMBER_NAME(rows,"rows");
	HX_MARK_MEMBER_NAME(autotileData,"autotileData");
	HX_MARK_MEMBER_NAME(grid,"grid");
	HX_MARK_MEMBER_NAME(scene,"scene");
	HX_MARK_MEMBER_NAME(numRows,"numRows");
	HX_MARK_MEMBER_NAME(numCols,"numCols");
	HX_MARK_MEMBER_NAME(tilemaps,"tilemaps");
	HX_MARK_MEMBER_NAME(noTiles,"noTiles");
	 ::openfl::display::Sprite_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void TileLayer_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(layerID,"layerID");
	HX_VISIT_MEMBER_NAME(rows,"rows");
	HX_VISIT_MEMBER_NAME(autotileData,"autotileData");
	HX_VISIT_MEMBER_NAME(grid,"grid");
	HX_VISIT_MEMBER_NAME(scene,"scene");
	HX_VISIT_MEMBER_NAME(numRows,"numRows");
	HX_VISIT_MEMBER_NAME(numCols,"numCols");
	HX_VISIT_MEMBER_NAME(tilemaps,"tilemaps");
	HX_VISIT_MEMBER_NAME(noTiles,"noTiles");
	 ::openfl::display::Sprite_obj::__Visit(HX_VISIT_ARG);
}

hx::Val TileLayer_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"rows") ) { return hx::Val( rows ); }
		if (HX_FIELD_EQ(inName,"grid") ) { return hx::Val( grid ); }
		if (HX_FIELD_EQ(inName,"draw") ) { return hx::Val( draw_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"scene") ) { return hx::Val( scene ); }
		if (HX_FIELD_EQ(inName,"clear") ) { return hx::Val( clear_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"layerID") ) { return hx::Val( layerID ); }
		if (HX_FIELD_EQ(inName,"numRows") ) { return hx::Val( numRows ); }
		if (HX_FIELD_EQ(inName,"numCols") ) { return hx::Val( numCols ); }
		if (HX_FIELD_EQ(inName,"noTiles") ) { return hx::Val( noTiles ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"tilemaps") ) { return hx::Val( tilemaps ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"mountGrid") ) { return hx::Val( mountGrid_dyn() ); }
		if (HX_FIELD_EQ(inName,"setTileAt") ) { return hx::Val( setTileAt_dyn() ); }
		if (HX_FIELD_EQ(inName,"getTileAt") ) { return hx::Val( getTileAt_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"getTilemap") ) { return hx::Val( getTilemap_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"setPosition") ) { return hx::Val( setPosition_dyn() ); }
		if (HX_FIELD_EQ(inName,"updateScale") ) { return hx::Val( updateScale_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"autotileData") ) { return hx::Val( autotileData ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"updateAutotile") ) { return hx::Val( updateAutotile_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"updateAutotilesNear") ) { return hx::Val( updateAutotilesNear_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool TileLayer_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 11:
		if (HX_FIELD_EQ(inName,"cacheSource") ) { outValue = ( cacheSource ); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"resetStatics") ) { outValue = resetStatics_dyn(); return true; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"autotileFlagPointMap") ) { outValue = ( autotileFlagPointMap ); return true; }
	}
	return false;
}

hx::Val TileLayer_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"rows") ) { rows=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"grid") ) { grid=inValue.Cast<  ::com::stencyl::models::collision::Grid >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"scene") ) { scene=inValue.Cast<  ::com::stencyl::models::Scene >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"layerID") ) { layerID=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"numRows") ) { numRows=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"numCols") ) { numCols=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"noTiles") ) { noTiles=inValue.Cast< bool >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"tilemaps") ) { tilemaps=inValue.Cast<  ::haxe::ds::ObjectMap >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"autotileData") ) { autotileData=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool TileLayer_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 11:
		if (HX_FIELD_EQ(inName,"cacheSource") ) { cacheSource=ioValue.Cast<  ::haxe::ds::IntMap >(); return true; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"autotileFlagPointMap") ) { autotileFlagPointMap=ioValue.Cast<  ::haxe::ds::IntMap >(); return true; }
	}
	return false;
}

void TileLayer_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("layerID","\xec","\x97","\x41","\x42"));
	outFields->push(HX_HCSTRING("rows","\x19","\xf5","\xae","\x4b"));
	outFields->push(HX_HCSTRING("autotileData","\xe7","\xe2","\x03","\xe4"));
	outFields->push(HX_HCSTRING("grid","\xc6","\xd6","\x6b","\x44"));
	outFields->push(HX_HCSTRING("scene","\x4c","\xd9","\xd1","\x78"));
	outFields->push(HX_HCSTRING("numRows","\x7f","\x9a","\x2f","\x9f"));
	outFields->push(HX_HCSTRING("numCols","\x99","\x5d","\x45","\x95"));
	outFields->push(HX_HCSTRING("tilemaps","\x85","\x38","\x83","\x97"));
	outFields->push(HX_HCSTRING("noTiles","\x84","\x81","\x38","\xe3"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo TileLayer_obj_sMemberStorageInfo[] = {
	{hx::fsInt,(int)offsetof(TileLayer_obj,layerID),HX_HCSTRING("layerID","\xec","\x97","\x41","\x42")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(TileLayer_obj,rows),HX_HCSTRING("rows","\x19","\xf5","\xae","\x4b")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(TileLayer_obj,autotileData),HX_HCSTRING("autotileData","\xe7","\xe2","\x03","\xe4")},
	{hx::fsObject /*::com::stencyl::models::collision::Grid*/ ,(int)offsetof(TileLayer_obj,grid),HX_HCSTRING("grid","\xc6","\xd6","\x6b","\x44")},
	{hx::fsObject /*::com::stencyl::models::Scene*/ ,(int)offsetof(TileLayer_obj,scene),HX_HCSTRING("scene","\x4c","\xd9","\xd1","\x78")},
	{hx::fsInt,(int)offsetof(TileLayer_obj,numRows),HX_HCSTRING("numRows","\x7f","\x9a","\x2f","\x9f")},
	{hx::fsInt,(int)offsetof(TileLayer_obj,numCols),HX_HCSTRING("numCols","\x99","\x5d","\x45","\x95")},
	{hx::fsObject /*::haxe::ds::ObjectMap*/ ,(int)offsetof(TileLayer_obj,tilemaps),HX_HCSTRING("tilemaps","\x85","\x38","\x83","\x97")},
	{hx::fsBool,(int)offsetof(TileLayer_obj,noTiles),HX_HCSTRING("noTiles","\x84","\x81","\x38","\xe3")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo TileLayer_obj_sStaticStorageInfo[] = {
	{hx::fsInt,(void *) &TileLayer_obj::TILESET_CACHE_MULTIPLIER,HX_HCSTRING("TILESET_CACHE_MULTIPLIER","\x89","\xc8","\x95","\xf2")},
	{hx::fsObject /*::haxe::ds::IntMap*/ ,(void *) &TileLayer_obj::cacheSource,HX_HCSTRING("cacheSource","\xbd","\xdc","\xd2","\x50")},
	{hx::fsObject /*::haxe::ds::IntMap*/ ,(void *) &TileLayer_obj::autotileFlagPointMap,HX_HCSTRING("autotileFlagPointMap","\xb5","\x05","\xc1","\xd4")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String TileLayer_obj_sMemberFields[] = {
	HX_HCSTRING("layerID","\xec","\x97","\x41","\x42"),
	HX_HCSTRING("rows","\x19","\xf5","\xae","\x4b"),
	HX_HCSTRING("autotileData","\xe7","\xe2","\x03","\xe4"),
	HX_HCSTRING("grid","\xc6","\xd6","\x6b","\x44"),
	HX_HCSTRING("scene","\x4c","\xd9","\xd1","\x78"),
	HX_HCSTRING("numRows","\x7f","\x9a","\x2f","\x9f"),
	HX_HCSTRING("numCols","\x99","\x5d","\x45","\x95"),
	HX_HCSTRING("tilemaps","\x85","\x38","\x83","\x97"),
	HX_HCSTRING("noTiles","\x84","\x81","\x38","\xe3"),
	HX_HCSTRING("clear","\x8d","\x71","\x5b","\x48"),
	HX_HCSTRING("setPosition","\x6b","\x6a","\x5b","\xfb"),
	HX_HCSTRING("mountGrid","\x3f","\x75","\xfa","\x93"),
	HX_HCSTRING("setTileAt","\x03","\x21","\xd0","\x7d"),
	HX_HCSTRING("getTileAt","\xf7","\x34","\x7f","\x9a"),
	HX_HCSTRING("updateAutotilesNear","\xf5","\x73","\x24","\x36"),
	HX_HCSTRING("updateAutotile","\x46","\x81","\x73","\x7a"),
	HX_HCSTRING("draw","\x04","\x2c","\x70","\x42"),
	HX_HCSTRING("updateScale","\xc1","\x37","\x67","\x5e"),
	HX_HCSTRING("getTilemap","\x38","\x76","\xf0","\x94"),
	::String(null()) };

static void TileLayer_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(TileLayer_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(TileLayer_obj::TILESET_CACHE_MULTIPLIER,"TILESET_CACHE_MULTIPLIER");
	HX_MARK_MEMBER_NAME(TileLayer_obj::cacheSource,"cacheSource");
	HX_MARK_MEMBER_NAME(TileLayer_obj::autotileFlagPointMap,"autotileFlagPointMap");
};

#ifdef HXCPP_VISIT_ALLOCS
static void TileLayer_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(TileLayer_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(TileLayer_obj::TILESET_CACHE_MULTIPLIER,"TILESET_CACHE_MULTIPLIER");
	HX_VISIT_MEMBER_NAME(TileLayer_obj::cacheSource,"cacheSource");
	HX_VISIT_MEMBER_NAME(TileLayer_obj::autotileFlagPointMap,"autotileFlagPointMap");
};

#endif

hx::Class TileLayer_obj::__mClass;

static ::String TileLayer_obj_sStaticFields[] = {
	HX_HCSTRING("TILESET_CACHE_MULTIPLIER","\x89","\xc8","\x95","\xf2"),
	HX_HCSTRING("cacheSource","\xbd","\xdc","\xd2","\x50"),
	HX_HCSTRING("resetStatics","\xf6","\x81","\x43","\xa8"),
	HX_HCSTRING("autotileFlagPointMap","\xb5","\x05","\xc1","\xd4"),
	::String(null())
};

void TileLayer_obj::__register()
{
	hx::Object *dummy = new TileLayer_obj;
	TileLayer_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("com.stencyl.models.scene.TileLayer","\x0c","\xb6","\xd9","\x2a");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &TileLayer_obj::__GetStatic;
	__mClass->mSetStaticField = &TileLayer_obj::__SetStatic;
	__mClass->mMarkFunc = TileLayer_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(TileLayer_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(TileLayer_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< TileLayer_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = TileLayer_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = TileLayer_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = TileLayer_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void TileLayer_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_d6f18a9be126aac1_44_boot)
HXDLIN(  44)		TILESET_CACHE_MULTIPLIER = (int)1000000;
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_d6f18a9be126aac1_45_boot)
HXDLIN(  45)		cacheSource =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
            	}
{
            		HX_BEGIN_LOCAL_FUNC_S0(hx::LocalFunc,_hx_Closure_0) HXARGC(0)
            		 ::Dynamic _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_d6f18a9be126aac1_247_boot)
HXDLIN( 247)			 ::haxe::ds::IntMap _g =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXDLIN( 247)			{
HXDLIN( 247)				int key = ::com::stencyl::models::scene::Autotile_obj::CORNER_TL;
HXDLIN( 247)				_g->set(key, ::openfl::geom::Point_obj::__alloc( HX_CTX ,(int)-1,(int)-1));
            			}
HXDLIN( 247)			{
HXDLIN( 247)				int key1 = ::com::stencyl::models::scene::Autotile_obj::CORNER_TR;
HXDLIN( 247)				_g->set(key1, ::openfl::geom::Point_obj::__alloc( HX_CTX ,(int)1,(int)-1));
            			}
HXDLIN( 247)			{
HXDLIN( 247)				int key2 = ::com::stencyl::models::scene::Autotile_obj::CORNER_BL;
HXDLIN( 247)				_g->set(key2, ::openfl::geom::Point_obj::__alloc( HX_CTX ,(int)-1,(int)1));
            			}
HXDLIN( 247)			{
HXDLIN( 247)				int key3 = ::com::stencyl::models::scene::Autotile_obj::CORNER_BR;
HXDLIN( 247)				_g->set(key3, ::openfl::geom::Point_obj::__alloc( HX_CTX ,(int)1,(int)1));
            			}
HXDLIN( 247)			{
HXDLIN( 247)				int key4 = ::com::stencyl::models::scene::Autotile_obj::SIDE_T;
HXDLIN( 247)				_g->set(key4, ::openfl::geom::Point_obj::__alloc( HX_CTX ,(int)0,(int)-1));
            			}
HXDLIN( 247)			{
HXDLIN( 247)				int key5 = ::com::stencyl::models::scene::Autotile_obj::SIDE_B;
HXDLIN( 247)				_g->set(key5, ::openfl::geom::Point_obj::__alloc( HX_CTX ,(int)0,(int)1));
            			}
HXDLIN( 247)			{
HXDLIN( 247)				int key6 = ::com::stencyl::models::scene::Autotile_obj::SIDE_L;
HXDLIN( 247)				_g->set(key6, ::openfl::geom::Point_obj::__alloc( HX_CTX ,(int)-1,(int)0));
            			}
HXDLIN( 247)			{
HXDLIN( 247)				int key7 = ::com::stencyl::models::scene::Autotile_obj::SIDE_R;
HXDLIN( 247)				_g->set(key7, ::openfl::geom::Point_obj::__alloc( HX_CTX ,(int)1,(int)0));
            			}
HXDLIN( 247)			return _g;
            		}
            		HX_END_LOCAL_FUNC0(return)

            	HX_STACKFRAME(&_hx_pos_d6f18a9be126aac1_247_boot)
HXDLIN( 247)		autotileFlagPointMap =  ::Dynamic(new _hx_Closure_0())();
            	}
}

} // end namespace com
} // end namespace stencyl
} // end namespace models
} // end namespace scene
