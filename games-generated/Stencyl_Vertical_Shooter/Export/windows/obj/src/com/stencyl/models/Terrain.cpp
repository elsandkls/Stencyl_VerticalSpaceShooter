// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_box2D_collision_B2AABB
#include <box2D/collision/B2AABB.h>
#endif
#ifndef INCLUDED_box2D_collision_shapes_B2CircleShape
#include <box2D/collision/shapes/B2CircleShape.h>
#endif
#ifndef INCLUDED_box2D_collision_shapes_B2PolygonShape
#include <box2D/collision/shapes/B2PolygonShape.h>
#endif
#ifndef INCLUDED_box2D_collision_shapes_B2Shape
#include <box2D/collision/shapes/B2Shape.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Mat22
#include <box2D/common/math/B2Mat22.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Transform
#include <box2D/common/math/B2Transform.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Vec2
#include <box2D/common/math/B2Vec2.h>
#endif
#ifndef INCLUDED_box2D_dynamics_B2Body
#include <box2D/dynamics/B2Body.h>
#endif
#ifndef INCLUDED_box2D_dynamics_B2BodyDef
#include <box2D/dynamics/B2BodyDef.h>
#endif
#ifndef INCLUDED_box2D_dynamics_B2Fixture
#include <box2D/dynamics/B2Fixture.h>
#endif
#ifndef INCLUDED_box2D_dynamics_B2FixtureDef
#include <box2D/dynamics/B2FixtureDef.h>
#endif
#ifndef INCLUDED_com_stencyl_Engine
#include <com/stencyl/Engine.h>
#endif
#ifndef INCLUDED_com_stencyl_models_Actor
#include <com/stencyl/models/Actor.h>
#endif
#ifndef INCLUDED_com_stencyl_models_Resource
#include <com/stencyl/models/Resource.h>
#endif
#ifndef INCLUDED_com_stencyl_models_Terrain
#include <com/stencyl/models/Terrain.h>
#endif
#ifndef INCLUDED_com_stencyl_models_actor_ActorType
#include <com/stencyl/models/actor/ActorType.h>
#endif
#ifndef INCLUDED_com_stencyl_models_actor_Sprite
#include <com/stencyl/models/actor/Sprite.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_240d402b88069d46_31_new,"com.stencyl.models.Terrain","new",0x839d3d92,"com.stencyl.models.Terrain.new","com/stencyl/models/Terrain.hx",31,0x534cda1d)
HX_LOCAL_STACK_FRAME(_hx_pos_240d402b88069d46_105_follow,"com.stencyl.models.Terrain","follow",0x173bef7f,"com.stencyl.models.Terrain.follow","com/stencyl/models/Terrain.hx",105,0x534cda1d)
HX_LOCAL_STACK_FRAME(_hx_pos_240d402b88069d46_115_resetSize,"com.stencyl.models.Terrain","resetSize",0xf50a08e2,"com.stencyl.models.Terrain.resetSize","com/stencyl/models/Terrain.hx",115,0x534cda1d)
HX_LOCAL_STACK_FRAME(_hx_pos_240d402b88069d46_120_setRegionDiameter,"com.stencyl.models.Terrain","setRegionDiameter",0xba93e7d5,"com.stencyl.models.Terrain.setRegionDiameter","com/stencyl/models/Terrain.hx",120,0x534cda1d)
HX_LOCAL_STACK_FRAME(_hx_pos_240d402b88069d46_124_setRegionSize,"com.stencyl.models.Terrain","setRegionSize",0x33fbf5c9,"com.stencyl.models.Terrain.setRegionSize","com/stencyl/models/Terrain.hx",124,0x534cda1d)
HX_LOCAL_STACK_FRAME(_hx_pos_240d402b88069d46_173_setLocation,"com.stencyl.models.Terrain","setLocation",0x86cc2729,"com.stencyl.models.Terrain.setLocation","com/stencyl/models/Terrain.hx",173,0x534cda1d)
HX_LOCAL_STACK_FRAME(_hx_pos_240d402b88069d46_180_getWidth,"com.stencyl.models.Terrain","getWidth",0x027d431e,"com.stencyl.models.Terrain.getWidth","com/stencyl/models/Terrain.hx",180,0x534cda1d)
HX_LOCAL_STACK_FRAME(_hx_pos_240d402b88069d46_185_getHeight,"com.stencyl.models.Terrain","getHeight",0xe16cefcf,"com.stencyl.models.Terrain.getHeight","com/stencyl/models/Terrain.hx",185,0x534cda1d)
HX_LOCAL_STACK_FRAME(_hx_pos_240d402b88069d46_190_getFillColor,"com.stencyl.models.Terrain","getFillColor",0xb78690f8,"com.stencyl.models.Terrain.getFillColor","com/stencyl/models/Terrain.hx",190,0x534cda1d)
HX_LOCAL_STACK_FRAME(_hx_pos_240d402b88069d46_17_boot,"com.stencyl.models.Terrain","boot",0x9e11a2c0,"com.stencyl.models.Terrain.boot","com/stencyl/models/Terrain.hx",17,0x534cda1d)
namespace com{
namespace stencyl{
namespace models{

void Terrain_obj::__construct( ::com::stencyl::Engine game,Float x,Float y,::Array< ::Dynamic> shapes,int groupID,hx::Null< int >  __o_fillColor){
int fillColor = __o_fillColor.Default(0);
            	HX_GC_STACKFRAME(&_hx_pos_240d402b88069d46_31_new)
HXLINE(  32)		super::__construct(game,(int)-1,groupID,x,y,(int)-1,(int)1,(int)1,null(),null(),null(),null(),false,true,false,false,shapes->__get((int)0).StaticCast<  ::box2D::collision::shapes::B2Shape >(),null(),null(),null());
HXLINE(  37)		if ((fillColor == (int)0)) {
HXLINE(  37)			fillColor = (int)0;
            		}
HXLINE(  38)		this->fillColor = fillColor;
HXLINE(  40)		this->alwaysSimulate = true;
HXLINE(  41)		this->isRegion = false;
HXLINE(  42)		this->isTerrainRegion = true;
HXLINE(  44)		this->copy = shapes->__get((int)0).StaticCast<  ::box2D::collision::shapes::B2Shape >();
HXLINE(  46)		this->body->setSleepingAllowed(true);
HXLINE(  47)		this->body->setAwake(false);
HXLINE(  48)		this->body->setIgnoreGravity(true);
HXLINE(  51)		Float lowerXBound = (int)0;
HXLINE(  52)		Float upperXBound = (int)0;
HXLINE(  53)		Float lowerYBound = (int)0;
HXLINE(  54)		Float upperYBound = (int)0;
HXLINE(  56)		if (::Std_obj::is(shapes->__get((int)0).StaticCast<  ::box2D::collision::shapes::B2Shape >(),hx::ClassOf< ::box2D::collision::shapes::B2PolygonShape >())) {
HXLINE(  58)			this->isCircle = false;
HXLINE(  59)			 ::box2D::common::math::B2Transform trans =  ::box2D::common::math::B2Transform_obj::__alloc( HX_CTX ,null(),null());
HXLINE(  60)			trans->setIdentity();
HXLINE(  62)			 ::box2D::collision::B2AABB aabb =  ::box2D::collision::B2AABB_obj::__alloc( HX_CTX );
HXLINE(  64)			hx::TCast<  ::box2D::collision::shapes::B2PolygonShape >::cast(shapes->__get((int)0).StaticCast<  ::box2D::collision::shapes::B2Shape >())->computeAABB(aabb,trans);
HXLINE(  66)			lowerXBound = aabb->lowerBound->x;
HXLINE(  67)			upperXBound = aabb->upperBound->x;
HXLINE(  68)			lowerYBound = aabb->lowerBound->y;
HXLINE(  69)			upperYBound = aabb->upperBound->y;
HXLINE(  71)			{
HXLINE(  71)				int _g1 = (int)0;
HXDLIN(  71)				int _g = shapes->length;
HXDLIN(  71)				while((_g1 < _g)){
HXLINE(  71)					_g1 = (_g1 + (int)1);
HXDLIN(  71)					int i = (_g1 - (int)1);
HXLINE(  73)					 ::box2D::dynamics::B2FixtureDef fixture =  ::box2D::dynamics::B2FixtureDef_obj::__alloc( HX_CTX );
HXLINE(  74)					fixture->isSensor = false;
HXLINE(  75)					fixture->userData = hx::ObjectPtr<OBJ_>(this);
HXLINE(  76)					fixture->shape = shapes->__get(i).StaticCast<  ::box2D::collision::shapes::B2Shape >();
HXLINE(  77)					fixture->friction = ((Float)1.0);
HXLINE(  78)					fixture->density = ((Float)0.1);
HXLINE(  79)					fixture->restitution = (int)0;
HXLINE(  80)					fixture->groupID = groupID;
HXLINE(  82)					this->body->createFixture(fixture);
HXLINE(  84)					hx::TCast<  ::box2D::collision::shapes::B2PolygonShape >::cast(shapes->__get(i).StaticCast<  ::box2D::collision::shapes::B2Shape >())->computeAABB(aabb,trans);
HXLINE(  85)					lowerXBound = ::Math_obj::min(lowerXBound,aabb->lowerBound->x);
HXLINE(  86)					upperXBound = ::Math_obj::max(upperXBound,aabb->upperBound->x);
HXLINE(  87)					lowerYBound = ::Math_obj::min(lowerYBound,aabb->lowerBound->y);
HXLINE(  88)					upperYBound = ::Math_obj::max(upperYBound,aabb->upperBound->y);
            				}
            			}
HXLINE(  91)			this->originalWidth = (this->regionWidth = ::Math_obj::round(::com::stencyl::Engine_obj::toPixelUnits(::Math_obj::abs((lowerXBound - upperXBound)))));
HXLINE(  92)			this->originalHeight = (this->regionHeight = ::Math_obj::round(::com::stencyl::Engine_obj::toPixelUnits(::Math_obj::abs((lowerYBound - upperYBound)))));
            		}
            		else {
HXLINE(  95)			if (::Std_obj::is(shapes->__get((int)0).StaticCast<  ::box2D::collision::shapes::B2Shape >(),hx::ClassOf< ::box2D::collision::shapes::B2CircleShape >())) {
HXLINE(  97)				this->isCircle = true;
HXLINE(  99)				this->originalWidth = (this->regionWidth = ::com::stencyl::Engine_obj::toPixelUnits((shapes->__get((int)0).StaticCast<  ::box2D::collision::shapes::B2Shape >()->m_radius * (int)2)));
HXLINE( 100)				this->originalHeight = (this->regionHeight = ::com::stencyl::Engine_obj::toPixelUnits((shapes->__get((int)0).StaticCast<  ::box2D::collision::shapes::B2Shape >()->m_radius * (int)2)));
            			}
            		}
            	}

Dynamic Terrain_obj::__CreateEmpty() { return new Terrain_obj; }

void *Terrain_obj::_hx_vtable = 0;

Dynamic Terrain_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Terrain_obj > _hx_result = new Terrain_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5]);
	return _hx_result;
}

bool Terrain_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x19c29573) {
		if (inClassId<=(int)0x11cd7c1c) {
			if (inClassId<=(int)0x0ddfced7) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x0ddfced7;
			} else {
				return inClassId==(int)0x11cd7c1c;
			}
		} else {
			return inClassId==(int)0x17120186 || inClassId==(int)0x19c29573;
		}
	} else {
		if (inClassId<=(int)0x3f2b00af) {
			return inClassId==(int)0x1b123bf8 || inClassId==(int)0x3f2b00af;
		} else {
			return inClassId==(int)0x4fb21980;
		}
	}
}

void Terrain_obj::follow( ::com::stencyl::models::Actor actor){
            	HX_STACKFRAME(&_hx_pos_240d402b88069d46_105_follow)
HXLINE( 106)		Float actor1 = actor->realX;
HXDLIN( 106)		Float x = (actor1 + ((Float)actor->cacheWidth / (Float)(int)2));
HXLINE( 107)		Float actor2 = actor->realY;
HXDLIN( 107)		Float y = (actor2 + ((Float)actor->cacheHeight / (Float)(int)2));
HXLINE( 109)		this->setX(x,null(),null());
HXLINE( 110)		this->setY(y,null(),null());
            	}


void Terrain_obj::resetSize(){
            	HX_STACKFRAME(&_hx_pos_240d402b88069d46_115_resetSize)
HXDLIN( 115)		this->setRegionSize(this->originalWidth,this->originalHeight);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Terrain_obj,resetSize,(void))

void Terrain_obj::setRegionDiameter(Float diameter){
            	HX_STACKFRAME(&_hx_pos_240d402b88069d46_120_setRegionDiameter)
HXDLIN( 120)		this->setRegionSize(diameter,diameter);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Terrain_obj,setRegionDiameter,(void))

void Terrain_obj::setRegionSize(Float width,Float height){
            	HX_GC_STACKFRAME(&_hx_pos_240d402b88069d46_124_setRegionSize)
HXLINE( 125)		Float oldWidth = this->regionWidth;
HXLINE( 126)		Float oldHeight = this->regionHeight;
HXLINE( 128)		width = ::com::stencyl::Engine_obj::toPhysicalUnits(width);
HXLINE( 129)		height = ::com::stencyl::Engine_obj::toPhysicalUnits(height);
HXLINE( 131)		 ::box2D::collision::shapes::B2Shape shape;
HXLINE( 133)		if (this->isCircle) {
HXLINE( 135)			 ::box2D::collision::shapes::B2CircleShape s =  ::box2D::collision::shapes::B2CircleShape_obj::__alloc( HX_CTX ,null());
HXLINE( 136)			s->m_radius = ((Float)width / (Float)(int)2);
HXLINE( 137)			shape = s;
            		}
            		else {
HXLINE( 142)			 ::box2D::collision::shapes::B2PolygonShape s2 =  ::box2D::collision::shapes::B2PolygonShape_obj::__alloc( HX_CTX );
HXLINE( 143)			s2->setAsBox(((Float)width / (Float)(int)2),((Float)height / (Float)(int)2));
HXLINE( 144)			shape = s2;
            		}
HXLINE( 147)		 ::box2D::dynamics::B2FixtureDef fixture =  ::box2D::dynamics::B2FixtureDef_obj::__alloc( HX_CTX );
HXLINE( 148)		fixture->isSensor = true;
HXLINE( 149)		fixture->userData = hx::ObjectPtr<OBJ_>(this);
HXLINE( 150)		fixture->shape = shape;
HXLINE( 152)		bool _hx_tmp;
HXDLIN( 152)		if (hx::IsNotNull( this->body )) {
HXLINE( 152)			_hx_tmp = hx::IsNotNull( this->body->getFixtureList() );
            		}
            		else {
HXLINE( 152)			_hx_tmp = false;
            		}
HXDLIN( 152)		if (_hx_tmp) {
HXLINE( 154)			while((this->body->m_fixtureCount > (int)0)){
HXLINE( 156)				 ::box2D::dynamics::B2Body _hx_tmp1 = this->body;
HXDLIN( 156)				_hx_tmp1->DestroyFixture(this->body->getFixtureList());
            			}
HXLINE( 159)			this->body->createFixture(fixture);
HXLINE( 161)			this->regionWidth = ::com::stencyl::Engine_obj::toPixelUnits(width);
HXLINE( 162)			this->regionHeight = ::com::stencyl::Engine_obj::toPixelUnits(height);
            		}
HXLINE( 165)		Float dw = (this->regionWidth - oldWidth);
HXLINE( 166)		Float dh = (this->regionHeight - oldHeight);
HXLINE( 169)		Float _hx_tmp2 = this->getX(null());
HXDLIN( 169)		Float _hx_tmp3 = (_hx_tmp2 + ((Float)dw / (Float)(int)2));
HXDLIN( 169)		Float _hx_tmp4 = this->getY(null());
HXDLIN( 169)		this->setLocation(_hx_tmp3,(_hx_tmp4 + ((Float)dh / (Float)(int)2)));
            	}


HX_DEFINE_DYNAMIC_FUNC2(Terrain_obj,setRegionSize,(void))

void Terrain_obj::setLocation(Float x,Float y){
            	HX_STACKFRAME(&_hx_pos_240d402b88069d46_173_setLocation)
HXLINE( 174)		this->setX((x + ((Float)this->regionWidth / (Float)(int)2)),null(),null());
HXLINE( 175)		this->setY((y + ((Float)this->regionHeight / (Float)(int)2)),null(),null());
            	}


Float Terrain_obj::getWidth(){
            	HX_STACKFRAME(&_hx_pos_240d402b88069d46_180_getWidth)
HXDLIN( 180)		return this->regionWidth;
            	}


Float Terrain_obj::getHeight(){
            	HX_STACKFRAME(&_hx_pos_240d402b88069d46_185_getHeight)
HXDLIN( 185)		return this->regionHeight;
            	}


int Terrain_obj::getFillColor(){
            	HX_STACKFRAME(&_hx_pos_240d402b88069d46_190_getFillColor)
HXDLIN( 190)		return this->fillColor;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Terrain_obj,getFillColor,return )

int Terrain_obj::UNSET_ID;


hx::ObjectPtr< Terrain_obj > Terrain_obj::__new( ::com::stencyl::Engine game,Float x,Float y,::Array< ::Dynamic> shapes,int groupID,hx::Null< int >  __o_fillColor) {
	hx::ObjectPtr< Terrain_obj > __this = new Terrain_obj();
	__this->__construct(game,x,y,shapes,groupID,__o_fillColor);
	return __this;
}

hx::ObjectPtr< Terrain_obj > Terrain_obj::__alloc(hx::Ctx *_hx_ctx, ::com::stencyl::Engine game,Float x,Float y,::Array< ::Dynamic> shapes,int groupID,hx::Null< int >  __o_fillColor) {
	Terrain_obj *__this = (Terrain_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Terrain_obj), true, "com.stencyl.models.Terrain"));
	*(void **)__this = Terrain_obj::_hx_vtable;
	__this->__construct(game,x,y,shapes,groupID,__o_fillColor);
	return __this;
}

Terrain_obj::Terrain_obj()
{
}

void Terrain_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Terrain);
	HX_MARK_MEMBER_NAME(isCircle,"isCircle");
	HX_MARK_MEMBER_NAME(fillColor,"fillColor");
	HX_MARK_MEMBER_NAME(copy,"copy");
	HX_MARK_MEMBER_NAME(originalWidth,"originalWidth");
	HX_MARK_MEMBER_NAME(originalHeight,"originalHeight");
	HX_MARK_MEMBER_NAME(regionWidth,"regionWidth");
	HX_MARK_MEMBER_NAME(regionHeight,"regionHeight");
	 ::com::stencyl::models::Actor_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void Terrain_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(isCircle,"isCircle");
	HX_VISIT_MEMBER_NAME(fillColor,"fillColor");
	HX_VISIT_MEMBER_NAME(copy,"copy");
	HX_VISIT_MEMBER_NAME(originalWidth,"originalWidth");
	HX_VISIT_MEMBER_NAME(originalHeight,"originalHeight");
	HX_VISIT_MEMBER_NAME(regionWidth,"regionWidth");
	HX_VISIT_MEMBER_NAME(regionHeight,"regionHeight");
	 ::com::stencyl::models::Actor_obj::__Visit(HX_VISIT_ARG);
}

hx::Val Terrain_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"copy") ) { return hx::Val( copy ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"follow") ) { return hx::Val( follow_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"isCircle") ) { return hx::Val( isCircle ); }
		if (HX_FIELD_EQ(inName,"getWidth") ) { return hx::Val( getWidth_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"fillColor") ) { return hx::Val( fillColor ); }
		if (HX_FIELD_EQ(inName,"resetSize") ) { return hx::Val( resetSize_dyn() ); }
		if (HX_FIELD_EQ(inName,"getHeight") ) { return hx::Val( getHeight_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"regionWidth") ) { return hx::Val( regionWidth ); }
		if (HX_FIELD_EQ(inName,"setLocation") ) { return hx::Val( setLocation_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"regionHeight") ) { return hx::Val( regionHeight ); }
		if (HX_FIELD_EQ(inName,"getFillColor") ) { return hx::Val( getFillColor_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"originalWidth") ) { return hx::Val( originalWidth ); }
		if (HX_FIELD_EQ(inName,"setRegionSize") ) { return hx::Val( setRegionSize_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"originalHeight") ) { return hx::Val( originalHeight ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"setRegionDiameter") ) { return hx::Val( setRegionDiameter_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val Terrain_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"copy") ) { copy=inValue.Cast<  ::box2D::collision::shapes::B2Shape >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"isCircle") ) { isCircle=inValue.Cast< bool >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"fillColor") ) { fillColor=inValue.Cast< int >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"regionWidth") ) { regionWidth=inValue.Cast< Float >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"regionHeight") ) { regionHeight=inValue.Cast< Float >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"originalWidth") ) { originalWidth=inValue.Cast< Float >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"originalHeight") ) { originalHeight=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Terrain_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("isCircle","\x9a","\x0d","\x77","\xae"));
	outFields->push(HX_HCSTRING("fillColor","\xe0","\x97","\x03","\x19"));
	outFields->push(HX_HCSTRING("copy","\xb5","\xbb","\xc4","\x41"));
	outFields->push(HX_HCSTRING("originalWidth","\xf5","\xab","\x53","\x25"));
	outFields->push(HX_HCSTRING("originalHeight","\x18","\x43","\x32","\x3a"));
	outFields->push(HX_HCSTRING("regionWidth","\x72","\x70","\xdf","\xf5"));
	outFields->push(HX_HCSTRING("regionHeight","\xfb","\x6b","\xf2","\xe3"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Terrain_obj_sMemberStorageInfo[] = {
	{hx::fsBool,(int)offsetof(Terrain_obj,isCircle),HX_HCSTRING("isCircle","\x9a","\x0d","\x77","\xae")},
	{hx::fsInt,(int)offsetof(Terrain_obj,fillColor),HX_HCSTRING("fillColor","\xe0","\x97","\x03","\x19")},
	{hx::fsObject /*::box2D::collision::shapes::B2Shape*/ ,(int)offsetof(Terrain_obj,copy),HX_HCSTRING("copy","\xb5","\xbb","\xc4","\x41")},
	{hx::fsFloat,(int)offsetof(Terrain_obj,originalWidth),HX_HCSTRING("originalWidth","\xf5","\xab","\x53","\x25")},
	{hx::fsFloat,(int)offsetof(Terrain_obj,originalHeight),HX_HCSTRING("originalHeight","\x18","\x43","\x32","\x3a")},
	{hx::fsFloat,(int)offsetof(Terrain_obj,regionWidth),HX_HCSTRING("regionWidth","\x72","\x70","\xdf","\xf5")},
	{hx::fsFloat,(int)offsetof(Terrain_obj,regionHeight),HX_HCSTRING("regionHeight","\xfb","\x6b","\xf2","\xe3")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo Terrain_obj_sStaticStorageInfo[] = {
	{hx::fsInt,(void *) &Terrain_obj::UNSET_ID,HX_HCSTRING("UNSET_ID","\xd1","\x4e","\x5d","\xcb")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String Terrain_obj_sMemberFields[] = {
	HX_HCSTRING("isCircle","\x9a","\x0d","\x77","\xae"),
	HX_HCSTRING("fillColor","\xe0","\x97","\x03","\x19"),
	HX_HCSTRING("copy","\xb5","\xbb","\xc4","\x41"),
	HX_HCSTRING("originalWidth","\xf5","\xab","\x53","\x25"),
	HX_HCSTRING("originalHeight","\x18","\x43","\x32","\x3a"),
	HX_HCSTRING("regionWidth","\x72","\x70","\xdf","\xf5"),
	HX_HCSTRING("regionHeight","\xfb","\x6b","\xf2","\xe3"),
	HX_HCSTRING("follow","\x71","\x91","\x96","\xf9"),
	HX_HCSTRING("resetSize","\x30","\xaa","\x3f","\x92"),
	HX_HCSTRING("setRegionDiameter","\x23","\x87","\x60","\x2d"),
	HX_HCSTRING("setRegionSize","\x17","\x56","\x57","\x7c"),
	HX_HCSTRING("setLocation","\xf7","\x37","\xa7","\x15"),
	HX_HCSTRING("getWidth","\x90","\xc5","\x39","\x2a"),
	HX_HCSTRING("getHeight","\x1d","\x91","\xa2","\x7e"),
	HX_HCSTRING("getFillColor","\x6a","\x34","\x5a","\x28"),
	::String(null()) };

static void Terrain_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Terrain_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(Terrain_obj::UNSET_ID,"UNSET_ID");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Terrain_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Terrain_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(Terrain_obj::UNSET_ID,"UNSET_ID");
};

#endif

hx::Class Terrain_obj::__mClass;

static ::String Terrain_obj_sStaticFields[] = {
	HX_HCSTRING("UNSET_ID","\xd1","\x4e","\x5d","\xcb"),
	::String(null())
};

void Terrain_obj::__register()
{
	hx::Object *dummy = new Terrain_obj;
	Terrain_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("com.stencyl.models.Terrain","\xa0","\xcc","\x6e","\x37");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Terrain_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Terrain_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Terrain_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Terrain_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Terrain_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Terrain_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Terrain_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Terrain_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_240d402b88069d46_17_boot)
HXDLIN(  17)		UNSET_ID = (int)-1;
            	}
}

} // end namespace com
} // end namespace stencyl
} // end namespace models
