// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_box2D_collision_shapes_B2CircleShape
#include <box2D/collision/shapes/B2CircleShape.h>
#endif
#ifndef INCLUDED_box2D_collision_shapes_B2Shape
#include <box2D/collision/shapes/B2Shape.h>
#endif
#ifndef INCLUDED_box2D_dynamics_B2FixtureDef
#include <box2D/dynamics/B2FixtureDef.h>
#endif
#ifndef INCLUDED_com_stencyl_io_AbstractReader
#include <com/stencyl/io/AbstractReader.h>
#endif
#ifndef INCLUDED_com_stencyl_io_ShapeReader
#include <com/stencyl/io/ShapeReader.h>
#endif
#ifndef INCLUDED_com_stencyl_io_SpriteReader
#include <com/stencyl/io/SpriteReader.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_MbsResource
#include <com/stencyl/io/mbs/MbsResource.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_actortype_MbsAnimShape
#include <com/stencyl/io/mbs/actortype/MbsAnimShape.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_actortype_MbsAnimation
#include <com/stencyl/io/mbs/actortype/MbsAnimation.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_actortype_MbsSprite
#include <com/stencyl/io/mbs/actortype/MbsSprite.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_shape_MbsCircle
#include <com/stencyl/io/mbs/shape/MbsCircle.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_shape_MbsPoint
#include <com/stencyl/io/mbs/shape/MbsPoint.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_shape_MbsPolygon
#include <com/stencyl/io/mbs/shape/MbsPolygon.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_shape_MbsShape
#include <com/stencyl/io/mbs/shape/MbsShape.h>
#endif
#ifndef INCLUDED_com_stencyl_models_Resource
#include <com/stencyl/models/Resource.h>
#endif
#ifndef INCLUDED_com_stencyl_models_actor_Animation
#include <com/stencyl/models/actor/Animation.h>
#endif
#ifndef INCLUDED_com_stencyl_models_actor_Sprite
#include <com/stencyl/models/actor/Sprite.h>
#endif
#ifndef INCLUDED_com_stencyl_models_collision_Hitbox
#include <com/stencyl/models/collision/Hitbox.h>
#endif
#ifndef INCLUDED_com_stencyl_models_collision_Mask
#include <com/stencyl/models/collision/Mask.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_mbs_core_ComposedType
#include <mbs/core/ComposedType.h>
#endif
#ifndef INCLUDED_mbs_core_MbsObject
#include <mbs/core/MbsObject.h>
#endif
#ifndef INCLUDED_mbs_core_MbsType
#include <mbs/core/MbsType.h>
#endif
#ifndef INCLUDED_mbs_io_MbsIntList
#include <mbs/io/MbsIntList.h>
#endif
#ifndef INCLUDED_mbs_io_MbsList
#include <mbs/io/MbsList.h>
#endif
#ifndef INCLUDED_mbs_io_MbsListBase
#include <mbs/io/MbsListBase.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_72088625a8c91d5a_27_new,"com.stencyl.io.SpriteReader","new",0xa1c49a93,"com.stencyl.io.SpriteReader.new","com/stencyl/io/SpriteReader.hx",27,0x0e7f12de)
HX_LOCAL_STACK_FRAME(_hx_pos_72088625a8c91d5a_32_accepts,"com.stencyl.io.SpriteReader","accepts",0x02c7741e,"com.stencyl.io.SpriteReader.accepts","com/stencyl/io/SpriteReader.hx",32,0x0e7f12de)
HX_LOCAL_STACK_FRAME(_hx_pos_72088625a8c91d5a_36_read,"com.stencyl.io.SpriteReader","read",0xece76dc3,"com.stencyl.io.SpriteReader.read","com/stencyl/io/SpriteReader.hx",36,0x0e7f12de)
HX_LOCAL_STACK_FRAME(_hx_pos_72088625a8c91d5a_58_readAnimation,"com.stencyl.io.SpriteReader","readAnimation",0xd90410c1,"com.stencyl.io.SpriteReader.readAnimation","com/stencyl/io/SpriteReader.hx",58,0x0e7f12de)
HX_LOCAL_STACK_FRAME(_hx_pos_72088625a8c91d5a_111_readSimpleShapes,"com.stencyl.io.SpriteReader","readSimpleShapes",0x73125667,"com.stencyl.io.SpriteReader.readSimpleShapes","com/stencyl/io/SpriteReader.hx",111,0x0e7f12de)
HX_LOCAL_STACK_FRAME(_hx_pos_72088625a8c91d5a_166_readShapes,"com.stencyl.io.SpriteReader","readShapes",0xb64ef055,"com.stencyl.io.SpriteReader.readShapes","com/stencyl/io/SpriteReader.hx",166,0x0e7f12de)
namespace com{
namespace stencyl{
namespace io{

void SpriteReader_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_72088625a8c91d5a_27_new)
            	}

Dynamic SpriteReader_obj::__CreateEmpty() { return new SpriteReader_obj; }

void *SpriteReader_obj::_hx_vtable = 0;

Dynamic SpriteReader_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< SpriteReader_obj > _hx_result = new SpriteReader_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool SpriteReader_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x516c2ab9;
}

static ::com::stencyl::io::AbstractReader_obj _hx_com_stencyl_io_SpriteReader__hx_com_stencyl_io_AbstractReader= {
	( bool (hx::Object::*)(::String))&::com::stencyl::io::SpriteReader_obj::accepts,
	(  ::com::stencyl::models::Resource (hx::Object::*)( ::Dynamic))&::com::stencyl::io::SpriteReader_obj::read,
};

void *SpriteReader_obj::_hx_getInterface(int inHash) {
	switch(inHash) {
		case (int)0xf08c5996: return &_hx_com_stencyl_io_SpriteReader__hx_com_stencyl_io_AbstractReader;
	}
	#ifdef HXCPP_SCRIPTABLE
	return super::_hx_getInterface(inHash);
	#else
	return 0;
	#endif
}

bool SpriteReader_obj::accepts(::String type){
            	HX_STACKFRAME(&_hx_pos_72088625a8c91d5a_32_accepts)
HXDLIN(  32)		return (type == ::com::stencyl::io::mbs::actortype::MbsSprite_obj::MBS_SPRITE->getName());
            	}


HX_DEFINE_DYNAMIC_FUNC1(SpriteReader_obj,accepts,return )

 ::com::stencyl::models::Resource SpriteReader_obj::read( ::Dynamic obj){
            	HX_GC_STACKFRAME(&_hx_pos_72088625a8c91d5a_36_read)
HXLINE(  39)		 ::com::stencyl::io::mbs::actortype::MbsSprite r = ( ( ::com::stencyl::io::mbs::actortype::MbsSprite)(obj) );
HXLINE(  41)		int defaultAnimation = r->getDefaultAnimation();
HXLINE(  42)		bool readableImages = r->getReadableImages();
HXLINE(  43)		::Array< ::Dynamic> animations = ::Array_obj< ::Dynamic>::__new();
HXLINE(  44)		int sprite = r->getId();
HXDLIN(  44)		int sprite1 = r->getAtlasID();
HXDLIN(  44)		 ::com::stencyl::models::actor::Sprite sprite2 =  ::com::stencyl::models::actor::Sprite_obj::__alloc( HX_CTX ,sprite,sprite1,r->getName(),defaultAnimation,readableImages);
HXLINE(  46)		 ::mbs::io::MbsList animList = r->getAnimations();
HXLINE(  47)		{
HXLINE(  47)			int _g1 = (int)0;
HXDLIN(  47)			int _g = animList->length();
HXDLIN(  47)			while((_g1 < _g)){
HXLINE(  47)				_g1 = (_g1 + (int)1);
HXDLIN(  47)				int i = (_g1 - (int)1);
HXLINE(  49)				 ::com::stencyl::io::mbs::actortype::MbsAnimation animReader = animList->getNextObject().StaticCast<  ::com::stencyl::io::mbs::actortype::MbsAnimation >();
HXLINE(  50)				 ::com::stencyl::models::actor::Animation anim = this->readAnimation(animReader,sprite2);
HXLINE(  51)				sprite2->animations->set(anim->animID,anim);
            			}
            		}
HXLINE(  54)		return sprite2;
            	}


HX_DEFINE_DYNAMIC_FUNC1(SpriteReader_obj,read,return )

 ::com::stencyl::models::actor::Animation SpriteReader_obj::readAnimation( ::com::stencyl::io::mbs::actortype::MbsAnimation r, ::com::stencyl::models::actor::Sprite parent){
            	HX_GC_STACKFRAME(&_hx_pos_72088625a8c91d5a_58_readAnimation)
HXLINE(  59)		int animID = r->getId();
HXLINE(  60)		::String animName = r->getName();
HXLINE(  62)		int imgWidth = r->getWidth();
HXLINE(  63)		int imgHeight = r->getHeight();
HXLINE(  65)		Float originX = r->getOriginX();
HXLINE(  66)		Float originY = r->getOriginY();
HXLINE(  68)		int frameCount = r->getNumFrames();
HXLINE(  69)		int framesAcross = r->getAcross();
HXLINE(  70)		int framesDown = r->getDown();
HXLINE(  72)		int simpleShapes = ::Std_obj::_hx_int(((Float)imgWidth / (Float)framesAcross));
HXDLIN(  72)		 ::haxe::ds::IntMap simpleShapes1 = this->readSimpleShapes(r,simpleShapes,::Std_obj::_hx_int(((Float)imgHeight / (Float)framesDown)));
HXLINE(  73)		int physicsShapes = ::Std_obj::_hx_int(((Float)imgWidth / (Float)framesAcross));
HXDLIN(  73)		 ::haxe::ds::IntMap physicsShapes1 = this->readShapes(r,physicsShapes,::Std_obj::_hx_int(((Float)imgHeight / (Float)framesDown)));
HXLINE(  74)		bool looping = r->getLoop();
HXLINE(  75)		bool sync = r->getSync();
HXLINE(  76)		::Array< int > durations = ::Array_obj< int >::__new();
HXLINE(  77)		int counter = (int)0;
HXLINE(  79)		 ::mbs::io::MbsIntList s = r->getDurations();
HXLINE(  81)		{
HXLINE(  81)			int _g1 = (int)0;
HXDLIN(  81)			int _g = s->length();
HXDLIN(  81)			while((_g1 < _g)){
HXLINE(  81)				_g1 = (_g1 + (int)1);
HXDLIN(  81)				int counter1 = (_g1 - (int)1);
HXLINE(  84)				durations[counter1] = s->readInt();
HXLINE(  86)				durations[counter1] = ::Math_obj::floor(((Float)durations->__get(counter1) / (Float)(int)10));
HXLINE(  87)				::Array< int > durations1 = durations;
HXDLIN(  87)				int counter2 = counter1;
HXDLIN(  87)				durations1[counter2] = (durations1->__get(counter2) * (int)10);
            			}
            		}
HXLINE(  90)		return  ::com::stencyl::models::actor::Animation_obj::__alloc( HX_CTX ,animID,animName,parent,simpleShapes1,physicsShapes1,looping,sync,imgWidth,imgHeight,originX,originY,durations,frameCount,framesAcross,framesDown);
            	}


HX_DEFINE_DYNAMIC_FUNC2(SpriteReader_obj,readAnimation,return )

 ::haxe::ds::IntMap SpriteReader_obj::readSimpleShapes( ::com::stencyl::io::mbs::actortype::MbsAnimation r,Float imgWidth,Float imgHeight){
            	HX_GC_STACKFRAME(&_hx_pos_72088625a8c91d5a_111_readSimpleShapes)
HXLINE( 112)		 ::haxe::ds::IntMap shapes =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXLINE( 114)		 ::mbs::io::MbsList shapeList = r->getShapes();
HXLINE( 116)		{
HXLINE( 116)			int _g1 = (int)0;
HXDLIN( 116)			int _g = shapeList->length();
HXDLIN( 116)			while((_g1 < _g)){
HXLINE( 116)				_g1 = (_g1 + (int)1);
HXDLIN( 116)				int i = (_g1 - (int)1);
HXLINE( 118)				 ::com::stencyl::io::mbs::actortype::MbsAnimShape shape = shapeList->getNextObject().StaticCast<  ::com::stencyl::io::mbs::actortype::MbsAnimShape >();
HXLINE( 120)				int shapeID = shape->getId();
HXLINE( 121)				int groupID = shape->getGroupID();
HXLINE( 122)				bool sensor = shape->getSensor();
HXLINE( 124)				 ::Dynamic shapeData = shape->getShape();
HXLINE( 126)				if (::Std_obj::is(shapeData,hx::ClassOf< ::com::stencyl::io::mbs::shape::MbsPolygon >())) {
HXLINE( 128)					 ::com::stencyl::io::mbs::shape::MbsPolygon polygon = ( ( ::com::stencyl::io::mbs::shape::MbsPolygon)(shapeData) );
HXLINE( 129)					 ::mbs::io::MbsList points = polygon->getPoints();
HXLINE( 130)					if ((points->length() != (int)4)) {
HXLINE( 131)						continue;
            					}
HXLINE( 133)					 ::com::stencyl::io::mbs::shape::MbsPoint pt = points->getNextObject().StaticCast<  ::com::stencyl::io::mbs::shape::MbsPoint >();
HXLINE( 134)					int vIndex = (int)0;
HXLINE( 135)					int i1 = (int)1;
HXLINE( 136)					int x0 = (int)10000000;
HXLINE( 137)					int y0 = (int)10000000;
HXLINE( 138)					int x1 = (int)0;
HXLINE( 139)					int y1 = (int)0;
HXLINE( 140)					int x = ::Std_obj::_hx_int(pt->getX());
HXLINE( 141)					int y = ::Std_obj::_hx_int(pt->getY());
HXLINE( 143)					while((vIndex < points->length())){
HXLINE( 145)						x0 = ::Std_obj::_hx_int(::Math_obj::min(x0,pt->getX()));
HXLINE( 146)						y0 = ::Std_obj::_hx_int(::Math_obj::min(y0,pt->getY()));
HXLINE( 147)						x1 = ::Std_obj::_hx_int(::Math_obj::max(x1,pt->getX()));
HXLINE( 148)						y1 = ::Std_obj::_hx_int(::Math_obj::max(y1,pt->getY()));
HXLINE( 150)						vIndex = (vIndex + (int)1);
HXLINE( 151)						if ((vIndex < points->length())) {
HXLINE( 152)							pt = points->getNextObject().StaticCast<  ::com::stencyl::io::mbs::shape::MbsPoint >();
            						}
            					}
HXLINE( 155)					int w = (x1 - x0);
HXLINE( 156)					int h = (y1 - y0);
HXLINE( 158)					shapes->set(shapeID, ::com::stencyl::models::collision::Hitbox_obj::__alloc( HX_CTX ,w,h,x,y,!(sensor),groupID));
            				}
            			}
            		}
HXLINE( 162)		return shapes;
            	}


HX_DEFINE_DYNAMIC_FUNC3(SpriteReader_obj,readSimpleShapes,return )

 ::haxe::ds::IntMap SpriteReader_obj::readShapes( ::com::stencyl::io::mbs::actortype::MbsAnimation r,int imgWidth,int imgHeight){
            	HX_GC_STACKFRAME(&_hx_pos_72088625a8c91d5a_166_readShapes)
HXLINE( 167)		 ::haxe::ds::IntMap shapes =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXLINE( 172)		 ::mbs::io::MbsList shapeList = r->getShapes();
HXLINE( 174)		{
HXLINE( 174)			int _g1 = (int)0;
HXDLIN( 174)			int _g = shapeList->length();
HXDLIN( 174)			while((_g1 < _g)){
HXLINE( 174)				_g1 = (_g1 + (int)1);
HXDLIN( 174)				int i = (_g1 - (int)1);
HXLINE( 176)				 ::com::stencyl::io::mbs::actortype::MbsAnimShape shapeReader = shapeList->getNextObject().StaticCast<  ::com::stencyl::io::mbs::actortype::MbsAnimShape >();
HXLINE( 178)				int shapeID = shapeReader->getId();
HXLINE( 179)				int groupID = shapeReader->getGroupID();
HXLINE( 180)				bool sensor = shapeReader->getSensor();
HXLINE( 182)				 ::mbs::core::MbsObject shapeData = ( ( ::mbs::core::MbsObject)(shapeReader->getShape()) );
HXLINE( 184)				 ::Dynamic shape;
HXLINE( 186)				if (::Std_obj::is(shapeData,hx::ClassOf< ::com::stencyl::io::mbs::shape::MbsCircle >())) {
HXLINE( 188)					 ::com::stencyl::io::mbs::shape::MbsCircle circle = ( ( ::com::stencyl::io::mbs::shape::MbsCircle)(shapeData) );
HXLINE( 189)					Float shape1 = circle->getRadius();
HXDLIN( 189)					Float shape2 = circle->getPosition()->getX();
HXDLIN( 189)					shape = ::com::stencyl::io::ShapeReader_obj::createCircle(shape1,shape2,circle->getPosition()->getY(),imgWidth,imgHeight);
            				}
            				else {
HXLINE( 193)					 ::com::stencyl::io::mbs::shape::MbsPolygon polygon = ( ( ::com::stencyl::io::mbs::shape::MbsPolygon)(shapeData) );
HXLINE( 194)					::String shape3 = shapeData->getMbsType()->getName();
HXDLIN( 194)					shape = ::com::stencyl::io::ShapeReader_obj::createPolygon(shape3,::com::stencyl::io::ShapeReader_obj::readPoints(polygon->getPoints())->copy(),imgWidth,imgHeight);
            				}
HXLINE( 197)				 ::box2D::dynamics::B2FixtureDef fixtureDef =  ::box2D::dynamics::B2FixtureDef_obj::__alloc( HX_CTX );
HXLINE( 198)				fixtureDef->shape = ( ( ::box2D::collision::shapes::B2Shape)(shape) );
HXLINE( 200)				fixtureDef->density = shapeReader->getDensity();
HXLINE( 203)				fixtureDef->friction = shapeReader->getFriction();
HXLINE( 204)				fixtureDef->restitution = shapeReader->getRestitution();
HXLINE( 206)				fixtureDef->isSensor = sensor;
HXLINE( 207)				fixtureDef->groupID = shapeReader->getGroupID();
HXLINE( 209)				shapes->set(shapeID,fixtureDef);
            			}
            		}
HXLINE( 212)		return shapes;
            	}


HX_DEFINE_DYNAMIC_FUNC3(SpriteReader_obj,readShapes,return )


hx::ObjectPtr< SpriteReader_obj > SpriteReader_obj::__new() {
	hx::ObjectPtr< SpriteReader_obj > __this = new SpriteReader_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< SpriteReader_obj > SpriteReader_obj::__alloc(hx::Ctx *_hx_ctx) {
	SpriteReader_obj *__this = (SpriteReader_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(SpriteReader_obj), false, "com.stencyl.io.SpriteReader"));
	*(void **)__this = SpriteReader_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

SpriteReader_obj::SpriteReader_obj()
{
}

hx::Val SpriteReader_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"read") ) { return hx::Val( read_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"accepts") ) { return hx::Val( accepts_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"readShapes") ) { return hx::Val( readShapes_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"readAnimation") ) { return hx::Val( readAnimation_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"readSimpleShapes") ) { return hx::Val( readSimpleShapes_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *SpriteReader_obj_sMemberStorageInfo = 0;
static hx::StaticInfo *SpriteReader_obj_sStaticStorageInfo = 0;
#endif

static ::String SpriteReader_obj_sMemberFields[] = {
	HX_HCSTRING("accepts","\x6b","\x14","\xba","\x9a"),
	HX_HCSTRING("read","\x56","\x4b","\xa7","\x4b"),
	HX_HCSTRING("readAnimation","\xce","\x68","\xa3","\xde"),
	HX_HCSTRING("readSimpleShapes","\x7a","\xc4","\x31","\xae"),
	HX_HCSTRING("readShapes","\x28","\xbe","\xa5","\x16"),
	::String(null()) };

static void SpriteReader_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(SpriteReader_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void SpriteReader_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(SpriteReader_obj::__mClass,"__mClass");
};

#endif

hx::Class SpriteReader_obj::__mClass;

void SpriteReader_obj::__register()
{
	hx::Object *dummy = new SpriteReader_obj;
	SpriteReader_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("com.stencyl.io.SpriteReader","\x21","\x55","\x01","\x5f");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = SpriteReader_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(SpriteReader_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< SpriteReader_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = SpriteReader_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = SpriteReader_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = SpriteReader_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace com
} // end namespace stencyl
} // end namespace io
