// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_box2D_collision_shapes_B2CircleShape
#include <box2D/collision/shapes/B2CircleShape.h>
#endif
#ifndef INCLUDED_box2D_collision_shapes_B2EdgeShape
#include <box2D/collision/shapes/B2EdgeShape.h>
#endif
#ifndef INCLUDED_box2D_collision_shapes_B2PolygonShape
#include <box2D/collision/shapes/B2PolygonShape.h>
#endif
#ifndef INCLUDED_box2D_collision_shapes_B2Shape
#include <box2D/collision/shapes/B2Shape.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Vec2
#include <box2D/common/math/B2Vec2.h>
#endif
#ifndef INCLUDED_com_stencyl_Engine
#include <com/stencyl/Engine.h>
#endif
#ifndef INCLUDED_com_stencyl_io_ShapeReader
#include <com/stencyl/io/ShapeReader.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_shape_MbsPoint
#include <com/stencyl/io/mbs/shape/MbsPoint.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_mbs_core_MbsObject
#include <mbs/core/MbsObject.h>
#endif
#ifndef INCLUDED_mbs_io_MbsList
#include <mbs/io/MbsList.h>
#endif
#ifndef INCLUDED_mbs_io_MbsListBase
#include <mbs/io/MbsListBase.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_a700a4b0c9a51b2a_30_readPoint,"com.stencyl.io.ShapeReader","readPoint",0x65143e57,"com.stencyl.io.ShapeReader.readPoint","com/stencyl/io/ShapeReader.hx",30,0x1bde4cb2)
HX_LOCAL_STACK_FRAME(_hx_pos_a700a4b0c9a51b2a_34_readPoints,"com.stencyl.io.ShapeReader","readPoints",0x0ca24e3c,"com.stencyl.io.ShapeReader.readPoints","com/stencyl/io/ShapeReader.hx",34,0x1bde4cb2)
HX_LOCAL_STACK_FRAME(_hx_pos_a700a4b0c9a51b2a_44_createCircle,"com.stencyl.io.ShapeReader","createCircle",0xc53b990f,"com.stencyl.io.ShapeReader.createCircle","com/stencyl/io/ShapeReader.hx",44,0x1bde4cb2)
HX_LOCAL_STACK_FRAME(_hx_pos_a700a4b0c9a51b2a_56_createPolygon,"com.stencyl.io.ShapeReader","createPolygon",0xebc4fa9b,"com.stencyl.io.ShapeReader.createPolygon","com/stencyl/io/ShapeReader.hx",56,0x1bde4cb2)
HX_LOCAL_STACK_FRAME(_hx_pos_a700a4b0c9a51b2a_173_CheckVertexDirection,"com.stencyl.io.ShapeReader","CheckVertexDirection",0x37d9d856,"com.stencyl.io.ShapeReader.CheckVertexDirection","com/stencyl/io/ShapeReader.hx",173,0x1bde4cb2)
HX_LOCAL_STACK_FRAME(_hx_pos_a700a4b0c9a51b2a_196_EnsureCorrectVertexDirection,"com.stencyl.io.ShapeReader","EnsureCorrectVertexDirection",0xfb419252,"com.stencyl.io.ShapeReader.EnsureCorrectVertexDirection","com/stencyl/io/ShapeReader.hx",196,0x1bde4cb2)
HX_LOCAL_STACK_FRAME(_hx_pos_a700a4b0c9a51b2a_208_ReverseVertices,"com.stencyl.io.ShapeReader","ReverseVertices",0xc706f818,"com.stencyl.io.ShapeReader.ReverseVertices","com/stencyl/io/ShapeReader.hx",208,0x1bde4cb2)
HX_LOCAL_STACK_FRAME(_hx_pos_a700a4b0c9a51b2a_227_getWidth,"com.stencyl.io.ShapeReader","getWidth",0x21f6bef3,"com.stencyl.io.ShapeReader.getWidth","com/stencyl/io/ShapeReader.hx",227,0x1bde4cb2)
HX_LOCAL_STACK_FRAME(_hx_pos_a700a4b0c9a51b2a_241_getHeight,"com.stencyl.io.ShapeReader","getHeight",0x4c3fce5a,"com.stencyl.io.ShapeReader.getHeight","com/stencyl/io/ShapeReader.hx",241,0x1bde4cb2)
namespace com{
namespace stencyl{
namespace io{

void ShapeReader_obj::__construct() { }

Dynamic ShapeReader_obj::__CreateEmpty() { return new ShapeReader_obj; }

void *ShapeReader_obj::_hx_vtable = 0;

Dynamic ShapeReader_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< ShapeReader_obj > _hx_result = new ShapeReader_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool ShapeReader_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x1e0604d3;
}

 ::openfl::geom::Point ShapeReader_obj::readPoint( ::com::stencyl::io::mbs::shape::MbsPoint r){
            	HX_GC_STACKFRAME(&_hx_pos_a700a4b0c9a51b2a_30_readPoint)
HXDLIN(  30)		Float _hx_tmp = r->getX();
HXDLIN(  30)		return  ::openfl::geom::Point_obj::__alloc( HX_CTX ,_hx_tmp,r->getY());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(ShapeReader_obj,readPoint,return )

::Array< ::Dynamic> ShapeReader_obj::readPoints( ::mbs::io::MbsList list){
            	HX_GC_STACKFRAME(&_hx_pos_a700a4b0c9a51b2a_34_readPoints)
HXLINE(  35)		::Array< ::Dynamic> this1 = ::Array_obj< ::Dynamic>::__new(list->length());
HXDLIN(  35)		::Array< ::Dynamic> points = this1;
HXLINE(  36)		{
HXLINE(  36)			int _g1 = (int)0;
HXDLIN(  36)			int _g = list->length();
HXDLIN(  36)			while((_g1 < _g)){
HXLINE(  36)				_g1 = (_g1 + (int)1);
HXDLIN(  36)				int i = (_g1 - (int)1);
HXLINE(  38)				{
HXLINE(  38)					 ::com::stencyl::io::mbs::shape::MbsPoint r = list->getNextObject().StaticCast<  ::com::stencyl::io::mbs::shape::MbsPoint >();
HXDLIN(  38)					Float val = r->getX();
HXDLIN(  38)					 ::openfl::geom::Point val1 =  ::openfl::geom::Point_obj::__alloc( HX_CTX ,val,r->getY());
HXDLIN(  38)					points->__unsafe_set(i,val1);
            				}
            			}
            		}
HXLINE(  40)		return points;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(ShapeReader_obj,readPoints,return )

 ::box2D::collision::shapes::B2CircleShape ShapeReader_obj::createCircle(Float radius,Float x,Float y,hx::Null< Float >  __o_imgWidth,hx::Null< Float >  __o_imgHeight){
Float imgWidth = __o_imgWidth.Default(-1);
Float imgHeight = __o_imgHeight.Default(-1);
            	HX_GC_STACKFRAME(&_hx_pos_a700a4b0c9a51b2a_44_createCircle)
HXLINE(  45)		Float diameter = (radius * (int)2);
HXLINE(  47)		 ::box2D::collision::shapes::B2CircleShape c =  ::box2D::collision::shapes::B2CircleShape_obj::__alloc( HX_CTX ,null());
HXLINE(  48)		c->m_radius = ::com::stencyl::Engine_obj::toPhysicalUnits(radius);
HXLINE(  49)		c->m_p->x = ::com::stencyl::Engine_obj::toPhysicalUnits((x - ((Float)(imgWidth - diameter) / (Float)(int)2)));
HXLINE(  50)		c->m_p->y = ::com::stencyl::Engine_obj::toPhysicalUnits((y - ((Float)(imgHeight - diameter) / (Float)(int)2)));
HXLINE(  52)		return c;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(ShapeReader_obj,createCircle,return )

 ::Dynamic ShapeReader_obj::createPolygon(::String type,::Array< ::Dynamic> points,hx::Null< int >  __o_imgWidth,hx::Null< int >  __o_imgHeight){
int imgWidth = __o_imgWidth.Default(0);
int imgHeight = __o_imgHeight.Default(0);
            	HX_GC_STACKFRAME(&_hx_pos_a700a4b0c9a51b2a_56_createPolygon)
HXLINE(  57)		Float x = (int)0;
HXLINE(  58)		Float y = (int)0;
HXLINE(  59)		Float w = (int)0;
HXLINE(  60)		Float h = (int)0;
HXLINE(  62)		::Array< ::Dynamic> vertices = ::Array_obj< ::Dynamic>::__new();
HXLINE(  64)		int numVertices = points->length;
HXLINE(  65)		int vIndex = (int)0;
HXLINE(  66)		int i = (int)1;
HXLINE(  68)		int offsetX = ::Std_obj::_hx_int(((Float)-(imgWidth) / (Float)(int)2));
HXLINE(  69)		int offsetY = ::Std_obj::_hx_int(((Float)-(imgHeight) / (Float)(int)2));
HXLINE(  71)		bool _hx_tmp;
HXDLIN(  71)		if ((type != HX_("MbsPolygon",bc,ae,5b,28))) {
HXLINE(  71)			_hx_tmp = (type == HX_("MbsPolyRegion",5e,5d,18,96));
            		}
            		else {
HXLINE(  71)			_hx_tmp = true;
            		}
HXDLIN(  71)		if (_hx_tmp) {
HXLINE(  74)			vIndex = (int)0;
HXLINE(  76)			while((vIndex < numVertices)){
HXLINE(  78)				 ::openfl::geom::Point point = points->__get(vIndex).StaticCast<  ::openfl::geom::Point >();
HXLINE(  80)				Float vX = ::com::stencyl::Engine_obj::toPhysicalUnits((point->x + offsetX));
HXLINE(  81)				Float vY = ::com::stencyl::Engine_obj::toPhysicalUnits((point->y + offsetY));
HXLINE(  82)				vertices[vIndex] =  ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,vX,vY);
HXLINE(  84)				vIndex = (vIndex + (int)1);
            			}
HXLINE(  87)			::com::stencyl::io::ShapeReader_obj::EnsureCorrectVertexDirection(vertices);
HXLINE(  89)			return ::box2D::collision::shapes::B2PolygonShape_obj::asArray(vertices,vertices->length);
            		}
            		else {
HXLINE(  92)			if ((type == HX_("MbsWireframe",8a,2a,06,90))) {
HXLINE(  94)				while((vIndex < numVertices)){
HXLINE(  96)					 ::openfl::geom::Point point1 = points->__get(vIndex).StaticCast<  ::openfl::geom::Point >();
HXLINE(  97)					Float _hx_tmp1 = ::com::stencyl::Engine_obj::toPhysicalUnits(point1->x);
HXDLIN(  97)					vertices->push( ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,_hx_tmp1,::com::stencyl::Engine_obj::toPhysicalUnits(point1->y)));
HXLINE(  98)					vIndex = (vIndex + (int)1);
            				}
HXLINE( 101)				w = ::com::stencyl::io::ShapeReader_obj::getWidth(vertices);
HXLINE( 102)				h = ::com::stencyl::io::ShapeReader_obj::getHeight(vertices);
HXLINE( 104)				::cpp::VirtualArray arr = ::cpp::VirtualArray_obj::__new();
HXLINE( 106)				{
HXLINE( 106)					int _g1 = (int)0;
HXDLIN( 106)					int _g = (vertices->length + (int)1);
HXDLIN( 106)					while((_g1 < _g)){
HXLINE( 106)						_g1 = (_g1 + (int)1);
HXDLIN( 106)						int i1 = (_g1 - (int)1);
HXLINE( 108)						 ::box2D::common::math::B2Vec2 vertices1 = vertices->__get(hx::Mod(i1,vertices->length)).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXDLIN( 108)						 ::box2D::collision::shapes::B2EdgeShape edge =  ::box2D::collision::shapes::B2EdgeShape_obj::__alloc( HX_CTX ,vertices1,vertices->__get(hx::Mod((i1 + (int)1),vertices->length)).StaticCast<  ::box2D::common::math::B2Vec2 >());
HXLINE( 109)						arr->push(edge);
HXLINE( 111)						edge->m_hasVertex0 = true;
HXLINE( 112)						edge->m_hasVertex3 = true;
HXLINE( 114)						 ::box2D::common::math::B2Vec2 v0 = vertices->__get(hx::Mod((i1 - (int)1),vertices->length)).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXLINE( 115)						 ::box2D::common::math::B2Vec2 v3 = vertices->__get(hx::Mod((i1 + (int)2),vertices->length)).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXLINE( 117)						if (hx::IsNull( v0 )) {
HXLINE( 119)							v0 = vertices->__get((vertices->length - (int)1)).StaticCast<  ::box2D::common::math::B2Vec2 >();
            						}
HXLINE( 122)						if (hx::IsNull( v3 )) {
HXLINE( 124)							v3 = vertices->__get((int)0).StaticCast<  ::box2D::common::math::B2Vec2 >();
            						}
HXLINE( 127)						edge->m_v0 = v0;
HXLINE( 128)						edge->m_v3 = v3;
            					}
            				}
HXLINE( 142)				 ::haxe::ds::IntMap toReturn =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXLINE( 143)				toReturn->set((int)0,arr);
HXLINE( 144)				toReturn->set((int)1,w);
HXLINE( 145)				toReturn->set((int)2,h);
HXLINE( 147)				return toReturn;
            			}
            		}
HXLINE( 150)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(ShapeReader_obj,createPolygon,return )

bool ShapeReader_obj::CheckVertexDirection(::Array< ::Dynamic> v){
            	HX_STACKFRAME(&_hx_pos_a700a4b0c9a51b2a_173_CheckVertexDirection)
HXLINE( 174)		if ((v->length > (int)2)) {
HXLINE( 176)			Float wind = (int)0;
HXLINE( 177)			int i = (int)0;
HXLINE( 179)			while(true){
HXLINE( 179)				bool _hx_tmp;
HXDLIN( 179)				if ((wind == (int)0)) {
HXLINE( 179)					_hx_tmp = (i < (v->length - (int)2));
            				}
            				else {
HXLINE( 179)					_hx_tmp = false;
            				}
HXDLIN( 179)				if (!(_hx_tmp)) {
HXLINE( 179)					goto _hx_goto_8;
            				}
HXLINE( 181)				wind = v->__get(i).StaticCast<  ::box2D::common::math::B2Vec2 >()->winding(v->__get((i + (int)1)).StaticCast<  ::box2D::common::math::B2Vec2 >(),v->__get((i + (int)2)).StaticCast<  ::box2D::common::math::B2Vec2 >());
HXLINE( 182)				i = (i + (int)1);
            			}
            			_hx_goto_8:;
HXLINE( 185)			if ((wind < (int)0)) {
HXLINE( 187)				return false;
            			}
            		}
HXLINE( 191)		return true;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(ShapeReader_obj,CheckVertexDirection,return )

bool ShapeReader_obj::EnsureCorrectVertexDirection(::Array< ::Dynamic> v){
            	HX_STACKFRAME(&_hx_pos_a700a4b0c9a51b2a_196_EnsureCorrectVertexDirection)
HXLINE( 197)		if (!(::com::stencyl::io::ShapeReader_obj::CheckVertexDirection(v))) {
HXLINE( 199)			::com::stencyl::io::ShapeReader_obj::ReverseVertices(v);
HXLINE( 200)			return false;
            		}
HXLINE( 203)		return true;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(ShapeReader_obj,EnsureCorrectVertexDirection,return )

void ShapeReader_obj::ReverseVertices(::Array< ::Dynamic> v){
            	HX_STACKFRAME(&_hx_pos_a700a4b0c9a51b2a_208_ReverseVertices)
HXLINE( 209)		int low = (int)0;
HXLINE( 210)		int high = (v->length - (int)1);
HXLINE( 211)		Float tmp;
HXLINE( 213)		while((high > low)){
HXLINE( 215)			tmp = v->__get(low).StaticCast<  ::box2D::common::math::B2Vec2 >()->x;
HXLINE( 216)			v->__get(low).StaticCast<  ::box2D::common::math::B2Vec2 >()->x = v->__get(high).StaticCast<  ::box2D::common::math::B2Vec2 >()->x;
HXLINE( 217)			v->__get(high).StaticCast<  ::box2D::common::math::B2Vec2 >()->x = tmp;
HXLINE( 218)			tmp = v->__get(low).StaticCast<  ::box2D::common::math::B2Vec2 >()->y;
HXLINE( 219)			v->__get(low).StaticCast<  ::box2D::common::math::B2Vec2 >()->y = v->__get(high).StaticCast<  ::box2D::common::math::B2Vec2 >()->y;
HXLINE( 220)			v->__get(high).StaticCast<  ::box2D::common::math::B2Vec2 >()->y = tmp;
HXLINE( 221)			low = (low + (int)1);
HXLINE( 222)			high = (high - (int)1);
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(ShapeReader_obj,ReverseVertices,(void))

Float ShapeReader_obj::getWidth(::Array< ::Dynamic> vertices){
            	HX_STACKFRAME(&_hx_pos_a700a4b0c9a51b2a_227_getWidth)
HXLINE( 228)		Float minX = (int)10000000;
HXLINE( 229)		Float maxX = (int)0;
HXLINE( 231)		{
HXLINE( 231)			int _g = (int)0;
HXDLIN( 231)			while((_g < vertices->length)){
HXLINE( 231)				 ::box2D::common::math::B2Vec2 v = vertices->__get(_g).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXDLIN( 231)				_g = (_g + (int)1);
HXLINE( 233)				minX = ::Math_obj::min(minX,v->x);
HXLINE( 234)				maxX = ::Math_obj::max(maxX,v->x);
            			}
            		}
HXLINE( 237)		return (maxX - minX);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(ShapeReader_obj,getWidth,return )

Float ShapeReader_obj::getHeight(::Array< ::Dynamic> vertices){
            	HX_STACKFRAME(&_hx_pos_a700a4b0c9a51b2a_241_getHeight)
HXLINE( 242)		Float minY = (int)10000000;
HXLINE( 243)		Float maxY = (int)0;
HXLINE( 245)		{
HXLINE( 245)			int _g = (int)0;
HXDLIN( 245)			while((_g < vertices->length)){
HXLINE( 245)				 ::box2D::common::math::B2Vec2 v = vertices->__get(_g).StaticCast<  ::box2D::common::math::B2Vec2 >();
HXDLIN( 245)				_g = (_g + (int)1);
HXLINE( 247)				minY = ::Math_obj::min(minY,v->y);
HXLINE( 248)				maxY = ::Math_obj::max(maxY,v->y);
            			}
            		}
HXLINE( 251)		return (maxY - minY);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(ShapeReader_obj,getHeight,return )


ShapeReader_obj::ShapeReader_obj()
{
}

bool ShapeReader_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"getWidth") ) { outValue = getWidth_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"readPoint") ) { outValue = readPoint_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"getHeight") ) { outValue = getHeight_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"readPoints") ) { outValue = readPoints_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"createCircle") ) { outValue = createCircle_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"createPolygon") ) { outValue = createPolygon_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"ReverseVertices") ) { outValue = ReverseVertices_dyn(); return true; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"CheckVertexDirection") ) { outValue = CheckVertexDirection_dyn(); return true; }
		break;
	case 28:
		if (HX_FIELD_EQ(inName,"EnsureCorrectVertexDirection") ) { outValue = EnsureCorrectVertexDirection_dyn(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *ShapeReader_obj_sMemberStorageInfo = 0;
static hx::StaticInfo *ShapeReader_obj_sStaticStorageInfo = 0;
#endif

static void ShapeReader_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(ShapeReader_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void ShapeReader_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(ShapeReader_obj::__mClass,"__mClass");
};

#endif

hx::Class ShapeReader_obj::__mClass;

static ::String ShapeReader_obj_sStaticFields[] = {
	HX_HCSTRING("readPoint","\x1a","\x01","\x77","\x97"),
	HX_HCSTRING("readPoints","\x19","\xf6","\xa9","\xf0"),
	HX_HCSTRING("createCircle","\x2c","\xb2","\x62","\x78"),
	HX_HCSTRING("createPolygon","\xde","\xda","\xd3","\xfa"),
	HX_HCSTRING("CheckVertexDirection","\x73","\xd6","\x9a","\x62"),
	HX_HCSTRING("EnsureCorrectVertexDirection","\x6f","\x75","\x89","\x51"),
	HX_HCSTRING("ReverseVertices","\x1b","\xaf","\xc0","\xdf"),
	HX_HCSTRING("getWidth","\x90","\xc5","\x39","\x2a"),
	HX_HCSTRING("getHeight","\x1d","\x91","\xa2","\x7e"),
	::String(null())
};

void ShapeReader_obj::__register()
{
	hx::Object *dummy = new ShapeReader_obj;
	ShapeReader_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("com.stencyl.io.ShapeReader","\x6b","\x1f","\x48","\xca");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &ShapeReader_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = ShapeReader_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(ShapeReader_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< ShapeReader_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = ShapeReader_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ShapeReader_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ShapeReader_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace com
} // end namespace stencyl
} // end namespace io
