// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_com_stencyl_Engine
#include <com/stencyl/Engine.h>
#endif
#ifndef INCLUDED_com_stencyl_models_Atlas
#include <com/stencyl/models/Atlas.h>
#endif
#ifndef INCLUDED_com_stencyl_models_GameModel
#include <com/stencyl/models/GameModel.h>
#endif
#ifndef INCLUDED_com_stencyl_models_Resource
#include <com/stencyl/models/Resource.h>
#endif
#ifndef INCLUDED_com_stencyl_models_scene_AutotileFormat
#include <com/stencyl/models/scene/AutotileFormat.h>
#endif
#ifndef INCLUDED_com_stencyl_models_scene_Corners
#include <com/stencyl/models/scene/Corners.h>
#endif
#ifndef INCLUDED_com_stencyl_models_scene_Tile
#include <com/stencyl/models/scene/Tile.h>
#endif
#ifndef INCLUDED_com_stencyl_models_scene_Tileset
#include <com/stencyl/models/scene/Tileset.h>
#endif
#ifndef INCLUDED_com_stencyl_utils_Assets
#include <com/stencyl/utils/Assets.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_Tileset
#include <openfl/display/Tileset.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_182cc35112715a86_45_new,"com.stencyl.models.scene.Tile","new",0x6987e0f7,"com.stencyl.models.scene.Tile.new","com/stencyl/models/scene/Tile.hx",45,0x47a425d9)
HX_LOCAL_STACK_FRAME(_hx_pos_182cc35112715a86_73_update,"com.stencyl.models.scene.Tile","update",0xcd8aadd2,"com.stencyl.models.scene.Tile.update","com/stencyl/models/scene/Tile.hx",73,0x47a425d9)
HX_LOCAL_STACK_FRAME(_hx_pos_182cc35112715a86_106_getSource,"com.stencyl.models.scene.Tile","getSource",0xd55155e8,"com.stencyl.models.scene.Tile.getSource","com/stencyl/models/scene/Tile.hx",106,0x47a425d9)
HX_LOCAL_STACK_FRAME(_hx_pos_182cc35112715a86_112_loadGraphics,"com.stencyl.models.scene.Tile","loadGraphics",0xaf87899a,"com.stencyl.models.scene.Tile.loadGraphics","com/stencyl/models/scene/Tile.hx",112,0x47a425d9)
HX_LOCAL_STACK_FRAME(_hx_pos_182cc35112715a86_139_unloadGraphics,"com.stencyl.models.scene.Tile","unloadGraphics",0xf7cd85b3,"com.stencyl.models.scene.Tile.unloadGraphics","com/stencyl/models/scene/Tile.hx",139,0x47a425d9)
HX_LOCAL_STACK_FRAME(_hx_pos_182cc35112715a86_155_loadAnimationPixels,"com.stencyl.models.scene.Tile","loadAnimationPixels",0x10632462,"com.stencyl.models.scene.Tile.loadAnimationPixels","com/stencyl/models/scene/Tile.hx",155,0x47a425d9)
HX_LOCAL_STACK_FRAME(_hx_pos_182cc35112715a86_174_createAutotileAnimations,"com.stencyl.models.scene.Tile","createAutotileAnimations",0x5c693591,"com.stencyl.models.scene.Tile.createAutotileAnimations","com/stencyl/models/scene/Tile.hx",174,0x47a425d9)
HX_LOCAL_STACK_FRAME(_hx_pos_182cc35112715a86_191_createAutotileAnimations,"com.stencyl.models.scene.Tile","createAutotileAnimations",0x5c693591,"com.stencyl.models.scene.Tile.createAutotileAnimations","com/stencyl/models/scene/Tile.hx",191,0x47a425d9)
HX_LOCAL_STACK_FRAME(_hx_pos_182cc35112715a86_212_sourceRect,"com.stencyl.models.scene.Tile","sourceRect",0x3d3a73e8,"com.stencyl.models.scene.Tile.sourceRect","com/stencyl/models/scene/Tile.hx",212,0x47a425d9)
HX_LOCAL_STACK_FRAME(_hx_pos_182cc35112715a86_210_boot,"com.stencyl.models.scene.Tile","boot",0xe575f7bb,"com.stencyl.models.scene.Tile.boot","com/stencyl/models/scene/Tile.hx",210,0x47a425d9)
namespace com{
namespace stencyl{
namespace models{
namespace scene{

void Tile_obj::__construct(int tileID,int collisionID,::String metadata,int frameIndex,::Array< int > durations, ::com::stencyl::models::scene::AutotileFormat autotileFormat, ::haxe::ds::IntMap autotileMergeSet, ::com::stencyl::models::scene::Tileset parent){
            	HX_GC_STACKFRAME(&_hx_pos_182cc35112715a86_45_new)
HXLINE(  46)		this->tileID = tileID;
HXLINE(  47)		this->collisionID = collisionID;
HXLINE(  48)		this->metadata = metadata;
HXLINE(  49)		this->frameIndex = frameIndex;
HXLINE(  50)		this->durations = durations;
HXLINE(  51)		this->parent = parent;
HXLINE(  53)		::Dynamic this1 = ::com::stencyl::models::GameModel_obj::get()->atlases;
HXDLIN(  53)		 ::com::stencyl::models::Atlas atlas = ( ( ::haxe::ds::IntMap)(this1) )->get(parent->atlasID).StaticCast<  ::com::stencyl::models::Atlas >();
HXLINE(  55)		if (hx::IsNotNull( autotileFormat )) {
HXLINE(  57)			this->autotileFormat = autotileFormat;
HXLINE(  58)			this->autotileMergeSet = autotileMergeSet;
HXLINE(  59)			::Array< ::Dynamic> _g = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN(  59)			{
HXLINE(  59)				int _g2 = (int)0;
HXDLIN(  59)				int _g1 = autotileFormat->autotileArrayLength;
HXDLIN(  59)				while((_g2 < _g1)){
HXLINE(  59)					_g2 = (_g2 + (int)1);
HXDLIN(  59)					int i = (_g2 - (int)1);
HXDLIN(  59)					_g->push( ::com::stencyl::models::scene::Tile_obj::__alloc( HX_CTX ,tileID,collisionID,metadata,frameIndex,durations,null(),null(),parent));
            				}
            			}
HXDLIN(  59)			this->autotiles = _g;
            		}
HXLINE(  62)		bool _hx_tmp;
HXDLIN(  62)		if (hx::IsNotNull( atlas )) {
HXLINE(  62)			_hx_tmp = atlas->active;
            		}
            		else {
HXLINE(  62)			_hx_tmp = false;
            		}
HXDLIN(  62)		if (_hx_tmp) {
HXLINE(  64)			this->loadGraphics();
            		}
HXLINE(  67)		this->currFrame = (int)0;
HXLINE(  68)		this->currTime = (int)0;
HXLINE(  69)		this->updateSource = false;
            	}

Dynamic Tile_obj::__CreateEmpty() { return new Tile_obj; }

void *Tile_obj::_hx_vtable = 0;

Dynamic Tile_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Tile_obj > _hx_result = new Tile_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7]);
	return _hx_result;
}

bool Tile_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x0ed3a37d;
}

void Tile_obj::update(Float elapsedTime){
            	HX_STACKFRAME(&_hx_pos_182cc35112715a86_73_update)
HXLINE(  74)		if ((this->durations->length == (int)1)) {
HXLINE(  76)			return;
            		}
HXLINE(  79)		if (!(::com::stencyl::Engine_obj::paused)) {
HXLINE(  81)			 ::com::stencyl::models::scene::Tile _hx_tmp = hx::ObjectPtr<OBJ_>(this);
HXDLIN(  81)			_hx_tmp->currTime = (_hx_tmp->currTime + ::Math_obj::floor(elapsedTime));
HXLINE(  83)			int _hx_tmp1 = this->currTime;
HXDLIN(  83)			if ((_hx_tmp1 > ::Std_obj::_hx_int(this->durations->__get(this->currFrame)))) {
HXLINE(  85)				 ::com::stencyl::models::scene::Tile _hx_tmp2 = hx::ObjectPtr<OBJ_>(this);
HXDLIN(  85)				int _hx_tmp3 = _hx_tmp2->currTime;
HXDLIN(  85)				_hx_tmp2->currTime = (_hx_tmp3 - ::Std_obj::_hx_int(this->durations->__get(this->currFrame)));
HXLINE(  87)				if (((this->currFrame + (int)1) < this->durations->length)) {
HXLINE(  89)					this->currFrame++;
            				}
            				else {
HXLINE(  94)					this->currFrame = (int)0;
            				}
HXLINE(  97)				this->updateSource = true;
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Tile_obj,update,(void))

 ::openfl::geom::Rectangle Tile_obj::getSource(int tileWidth,int tileHeight){
            	HX_GC_STACKFRAME(&_hx_pos_182cc35112715a86_106_getSource)
HXDLIN( 106)		Float _hx_tmp = ((this->currFrame * tileWidth) * ::com::stencyl::Engine_obj::SCALE);
HXDLIN( 106)		Float _hx_tmp1 = (tileWidth * ::com::stencyl::Engine_obj::SCALE);
HXDLIN( 106)		return  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,_hx_tmp,(int)0,_hx_tmp1,(tileHeight * ::com::stencyl::Engine_obj::SCALE));
            	}


HX_DEFINE_DYNAMIC_FUNC2(Tile_obj,getSource,return )

void Tile_obj::loadGraphics(){
            	HX_STACKFRAME(&_hx_pos_182cc35112715a86_112_loadGraphics)
HXLINE( 113)		 ::openfl::display::BitmapData imgData = null();
HXLINE( 115)		bool _hx_tmp;
HXDLIN( 115)		if ((this->durations->length <= (int)1)) {
HXLINE( 115)			_hx_tmp = hx::IsNotNull( this->autotileFormat );
            		}
            		else {
HXLINE( 115)			_hx_tmp = true;
            		}
HXDLIN( 115)		if (_hx_tmp) {
HXLINE( 117)			imgData = ::com::stencyl::utils::Assets_obj::getBitmapData(((((((HX_("assets/graphics/",38,e5,fb,63) + ::com::stencyl::Engine_obj::IMG_BASE) + HX_("/tileset-",a8,d3,cf,55)) + this->parent->ID) + HX_("-",2d,00,00,00)) + this->tileID) + HX_(".png",3b,2d,bd,1e)),false);
            		}
HXLINE( 124)		if (hx::IsNotNull( this->autotileFormat )) {
HXLINE( 126)			int i = (int)0;
HXLINE( 127)			{
HXLINE( 127)				int _g = (int)0;
HXDLIN( 127)				::Array< ::Dynamic> _g1 = this->createAutotileAnimations(imgData,this->autotileFormat);
HXDLIN( 127)				while((_g < _g1->length)){
HXLINE( 127)					 ::openfl::display::BitmapData animSheet = _g1->__get(_g).StaticCast<  ::openfl::display::BitmapData >();
HXDLIN( 127)					_g = (_g + (int)1);
HXLINE( 129)					::Array< ::Dynamic> _hx_tmp1 = this->autotiles;
HXDLIN( 129)					i = (i + (int)1);
HXDLIN( 129)					_hx_tmp1->__get((i - (int)1)).StaticCast<  ::com::stencyl::models::scene::Tile >()->loadAnimationPixels(animSheet);
            				}
            			}
            		}
            		else {
HXLINE( 134)			this->loadAnimationPixels(imgData);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Tile_obj,loadGraphics,(void))

void Tile_obj::unloadGraphics(){
            	HX_STACKFRAME(&_hx_pos_182cc35112715a86_139_unloadGraphics)
HXLINE( 140)		this->pixels = null();
HXLINE( 141)		this->data = null();
HXLINE( 143)		if (hx::IsNotNull( this->autotiles )) {
HXLINE( 145)			int _g = (int)0;
HXDLIN( 145)			::Array< ::Dynamic> _g1 = this->autotiles;
HXDLIN( 145)			while((_g < _g1->length)){
HXLINE( 145)				 ::com::stencyl::models::scene::Tile t = _g1->__get(_g).StaticCast<  ::com::stencyl::models::scene::Tile >();
HXDLIN( 145)				_g = (_g + (int)1);
HXLINE( 147)				t->pixels = null();
HXLINE( 148)				t->data = null();
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Tile_obj,unloadGraphics,(void))

void Tile_obj::loadAnimationPixels( ::openfl::display::BitmapData pixels){
            	HX_GC_STACKFRAME(&_hx_pos_182cc35112715a86_155_loadAnimationPixels)
HXDLIN( 155)		if (hx::IsNotNull( pixels )) {
HXLINE( 157)			this->pixels = pixels;
HXLINE( 160)			this->data =  ::openfl::display::Tileset_obj::__alloc( HX_CTX ,pixels,null());
HXLINE( 162)			{
HXLINE( 162)				int _g1 = (int)0;
HXDLIN( 162)				int _g = this->durations->length;
HXDLIN( 162)				while((_g1 < _g)){
HXLINE( 162)					_g1 = (_g1 + (int)1);
HXDLIN( 162)					int i = (_g1 - (int)1);
HXLINE( 164)					this->currFrame = i;
HXLINE( 165)					 ::openfl::display::Tileset _hx_tmp = this->data;
HXDLIN( 165)					_hx_tmp->addRect(this->getSource(this->parent->tileWidth,this->parent->tileHeight));
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Tile_obj,loadAnimationPixels,(void))

::Array< ::Dynamic> Tile_obj::createAutotileAnimations( ::openfl::display::BitmapData imgData, ::com::stencyl::models::scene::AutotileFormat format){
            	HX_GC_STACKFRAME(&_hx_pos_182cc35112715a86_174_createAutotileAnimations)
HXLINE( 175)		::Array< ::Dynamic> allAnimations = ::Array_obj< ::Dynamic>::__new();
HXLINE( 177)		int frames = this->durations->length;
HXLINE( 179)		int tw = ::Std_obj::_hx_int(((Float)((Float)imgData->width / (Float)frames) / (Float)format->tilesAcross));
HXLINE( 180)		int th = ::Std_obj::_hx_int(((Float)imgData->height / (Float)format->tilesDown));
HXLINE( 182)		int half_tw = ::Std_obj::_hx_int(((Float)tw / (Float)(int)2));
HXLINE( 183)		int half_th = ::Std_obj::_hx_int(((Float)th / (Float)(int)2));
HXLINE( 185)		::com::stencyl::models::scene::Tile_obj::dummyRect->width = half_tw;
HXLINE( 186)		::com::stencyl::models::scene::Tile_obj::dummyRect->height = half_th;
HXLINE( 188)		{
HXLINE( 188)			int _g = (int)0;
HXDLIN( 188)			::Array< ::Dynamic> _g1 = format->animCorners;
HXDLIN( 188)			while((_g < _g1->length)){
            				HX_BEGIN_LOCAL_FUNC_S2(hx::LocalFunc,_hx_Closure_0, ::Dynamic,f, ::openfl::display::BitmapData,a1) HXARGC(2)
            				void _hx_run( ::openfl::geom::Rectangle a2, ::openfl::geom::Point a3){
            					HX_GC_STACKFRAME(&_hx_pos_182cc35112715a86_191_createAutotileAnimations)
HXLINE( 191)					f(a1,a2,a3,null(),null(),null());
            				}
            				HX_END_LOCAL_FUNC2((void))

HXLINE( 188)				 ::com::stencyl::models::scene::Corners corners = _g1->__get(_g).StaticCast<  ::com::stencyl::models::scene::Corners >();
HXDLIN( 188)				_g = (_g + (int)1);
HXLINE( 190)				 ::openfl::display::BitmapData tileImg =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,(tw * frames),th,null(),null());
HXLINE( 191)				 ::Dynamic f = tileImg->copyPixels_dyn();
HXDLIN( 191)				 ::openfl::display::BitmapData a1 = imgData;
HXDLIN( 191)				 ::Dynamic copyPixels =  ::Dynamic(new _hx_Closure_0(f,a1));
HXLINE( 193)				{
HXLINE( 193)					int _g3 = (int)0;
HXDLIN( 193)					int _g2 = frames;
HXDLIN( 193)					while((_g3 < _g2)){
HXLINE( 193)						_g3 = (_g3 + (int)1);
HXDLIN( 193)						int frame = (_g3 - (int)1);
HXLINE( 195)						int srcFrameOffset = ((tw * format->tilesAcross) * frame);
HXLINE( 196)						int destFrameOffset = (tw * frame);
HXLINE( 198)						 ::openfl::geom::Point p = corners->tl;
HXDLIN( 198)						::com::stencyl::models::scene::Tile_obj::dummyRect->x = (srcFrameOffset + (p->x * ::com::stencyl::models::scene::Tile_obj::dummyRect->width));
HXDLIN( 198)						::com::stencyl::models::scene::Tile_obj::dummyRect->y = (p->y * ::com::stencyl::models::scene::Tile_obj::dummyRect->height);
HXDLIN( 198)						 ::openfl::geom::Rectangle _hx_tmp = ::com::stencyl::models::scene::Tile_obj::dummyRect;
HXDLIN( 198)						copyPixels(_hx_tmp, ::openfl::geom::Point_obj::__alloc( HX_CTX ,destFrameOffset,(int)0));
HXLINE( 199)						 ::openfl::geom::Point p1 = corners->tr;
HXDLIN( 199)						::com::stencyl::models::scene::Tile_obj::dummyRect->x = (srcFrameOffset + (p1->x * ::com::stencyl::models::scene::Tile_obj::dummyRect->width));
HXDLIN( 199)						::com::stencyl::models::scene::Tile_obj::dummyRect->y = (p1->y * ::com::stencyl::models::scene::Tile_obj::dummyRect->height);
HXDLIN( 199)						 ::openfl::geom::Rectangle _hx_tmp1 = ::com::stencyl::models::scene::Tile_obj::dummyRect;
HXDLIN( 199)						copyPixels(_hx_tmp1, ::openfl::geom::Point_obj::__alloc( HX_CTX ,(destFrameOffset + half_tw),(int)0));
HXLINE( 200)						 ::openfl::geom::Point p2 = corners->br;
HXDLIN( 200)						::com::stencyl::models::scene::Tile_obj::dummyRect->x = (srcFrameOffset + (p2->x * ::com::stencyl::models::scene::Tile_obj::dummyRect->width));
HXDLIN( 200)						::com::stencyl::models::scene::Tile_obj::dummyRect->y = (p2->y * ::com::stencyl::models::scene::Tile_obj::dummyRect->height);
HXDLIN( 200)						 ::openfl::geom::Rectangle _hx_tmp2 = ::com::stencyl::models::scene::Tile_obj::dummyRect;
HXDLIN( 200)						copyPixels(_hx_tmp2, ::openfl::geom::Point_obj::__alloc( HX_CTX ,(destFrameOffset + half_tw),half_th));
HXLINE( 201)						 ::openfl::geom::Point p3 = corners->bl;
HXDLIN( 201)						::com::stencyl::models::scene::Tile_obj::dummyRect->x = (srcFrameOffset + (p3->x * ::com::stencyl::models::scene::Tile_obj::dummyRect->width));
HXDLIN( 201)						::com::stencyl::models::scene::Tile_obj::dummyRect->y = (p3->y * ::com::stencyl::models::scene::Tile_obj::dummyRect->height);
HXDLIN( 201)						 ::openfl::geom::Rectangle _hx_tmp3 = ::com::stencyl::models::scene::Tile_obj::dummyRect;
HXDLIN( 201)						copyPixels(_hx_tmp3, ::openfl::geom::Point_obj::__alloc( HX_CTX ,destFrameOffset,half_th));
            					}
            				}
HXLINE( 204)				allAnimations->push(tileImg);
            			}
            		}
HXLINE( 207)		return allAnimations;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Tile_obj,createAutotileAnimations,return )

 ::openfl::geom::Rectangle Tile_obj::sourceRect( ::openfl::geom::Point p,int srcFrameOffset){
            	HX_STACKFRAME(&_hx_pos_182cc35112715a86_212_sourceRect)
HXLINE( 213)		::com::stencyl::models::scene::Tile_obj::dummyRect->x = (srcFrameOffset + (p->x * ::com::stencyl::models::scene::Tile_obj::dummyRect->width));
HXLINE( 214)		::com::stencyl::models::scene::Tile_obj::dummyRect->y = (p->y * ::com::stencyl::models::scene::Tile_obj::dummyRect->height);
HXLINE( 215)		return ::com::stencyl::models::scene::Tile_obj::dummyRect;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Tile_obj,sourceRect,return )

 ::openfl::geom::Rectangle Tile_obj::dummyRect;


hx::ObjectPtr< Tile_obj > Tile_obj::__new(int tileID,int collisionID,::String metadata,int frameIndex,::Array< int > durations, ::com::stencyl::models::scene::AutotileFormat autotileFormat, ::haxe::ds::IntMap autotileMergeSet, ::com::stencyl::models::scene::Tileset parent) {
	hx::ObjectPtr< Tile_obj > __this = new Tile_obj();
	__this->__construct(tileID,collisionID,metadata,frameIndex,durations,autotileFormat,autotileMergeSet,parent);
	return __this;
}

hx::ObjectPtr< Tile_obj > Tile_obj::__alloc(hx::Ctx *_hx_ctx,int tileID,int collisionID,::String metadata,int frameIndex,::Array< int > durations, ::com::stencyl::models::scene::AutotileFormat autotileFormat, ::haxe::ds::IntMap autotileMergeSet, ::com::stencyl::models::scene::Tileset parent) {
	Tile_obj *__this = (Tile_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Tile_obj), true, "com.stencyl.models.scene.Tile"));
	*(void **)__this = Tile_obj::_hx_vtable;
	__this->__construct(tileID,collisionID,metadata,frameIndex,durations,autotileFormat,autotileMergeSet,parent);
	return __this;
}

Tile_obj::Tile_obj()
{
}

void Tile_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Tile);
	HX_MARK_MEMBER_NAME(tileID,"tileID");
	HX_MARK_MEMBER_NAME(collisionID,"collisionID");
	HX_MARK_MEMBER_NAME(metadata,"metadata");
	HX_MARK_MEMBER_NAME(frameIndex,"frameIndex");
	HX_MARK_MEMBER_NAME(parent,"parent");
	HX_MARK_MEMBER_NAME(autotileFormat,"autotileFormat");
	HX_MARK_MEMBER_NAME(autotiles,"autotiles");
	HX_MARK_MEMBER_NAME(autotileMergeSet,"autotileMergeSet");
	HX_MARK_MEMBER_NAME(pixels,"pixels");
	HX_MARK_MEMBER_NAME(durations,"durations");
	HX_MARK_MEMBER_NAME(frames,"frames");
	HX_MARK_MEMBER_NAME(currFrame,"currFrame");
	HX_MARK_MEMBER_NAME(currTime,"currTime");
	HX_MARK_MEMBER_NAME(updateSource,"updateSource");
	HX_MARK_MEMBER_NAME(data,"data");
	HX_MARK_END_CLASS();
}

void Tile_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(tileID,"tileID");
	HX_VISIT_MEMBER_NAME(collisionID,"collisionID");
	HX_VISIT_MEMBER_NAME(metadata,"metadata");
	HX_VISIT_MEMBER_NAME(frameIndex,"frameIndex");
	HX_VISIT_MEMBER_NAME(parent,"parent");
	HX_VISIT_MEMBER_NAME(autotileFormat,"autotileFormat");
	HX_VISIT_MEMBER_NAME(autotiles,"autotiles");
	HX_VISIT_MEMBER_NAME(autotileMergeSet,"autotileMergeSet");
	HX_VISIT_MEMBER_NAME(pixels,"pixels");
	HX_VISIT_MEMBER_NAME(durations,"durations");
	HX_VISIT_MEMBER_NAME(frames,"frames");
	HX_VISIT_MEMBER_NAME(currFrame,"currFrame");
	HX_VISIT_MEMBER_NAME(currTime,"currTime");
	HX_VISIT_MEMBER_NAME(updateSource,"updateSource");
	HX_VISIT_MEMBER_NAME(data,"data");
}

hx::Val Tile_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"data") ) { return hx::Val( data ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"tileID") ) { return hx::Val( tileID ); }
		if (HX_FIELD_EQ(inName,"parent") ) { return hx::Val( parent ); }
		if (HX_FIELD_EQ(inName,"pixels") ) { return hx::Val( pixels ); }
		if (HX_FIELD_EQ(inName,"frames") ) { return hx::Val( frames ); }
		if (HX_FIELD_EQ(inName,"update") ) { return hx::Val( update_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"metadata") ) { return hx::Val( metadata ); }
		if (HX_FIELD_EQ(inName,"currTime") ) { return hx::Val( currTime ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"autotiles") ) { return hx::Val( autotiles ); }
		if (HX_FIELD_EQ(inName,"durations") ) { return hx::Val( durations ); }
		if (HX_FIELD_EQ(inName,"currFrame") ) { return hx::Val( currFrame ); }
		if (HX_FIELD_EQ(inName,"getSource") ) { return hx::Val( getSource_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"frameIndex") ) { return hx::Val( frameIndex ); }
		if (HX_FIELD_EQ(inName,"sourceRect") ) { return hx::Val( sourceRect_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"collisionID") ) { return hx::Val( collisionID ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"updateSource") ) { return hx::Val( updateSource ); }
		if (HX_FIELD_EQ(inName,"loadGraphics") ) { return hx::Val( loadGraphics_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"autotileFormat") ) { return hx::Val( autotileFormat ); }
		if (HX_FIELD_EQ(inName,"unloadGraphics") ) { return hx::Val( unloadGraphics_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"autotileMergeSet") ) { return hx::Val( autotileMergeSet ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"loadAnimationPixels") ) { return hx::Val( loadAnimationPixels_dyn() ); }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"createAutotileAnimations") ) { return hx::Val( createAutotileAnimations_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Tile_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 9:
		if (HX_FIELD_EQ(inName,"dummyRect") ) { outValue = ( dummyRect ); return true; }
	}
	return false;
}

hx::Val Tile_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"data") ) { data=inValue.Cast<  ::openfl::display::Tileset >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"tileID") ) { tileID=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"parent") ) { parent=inValue.Cast<  ::com::stencyl::models::scene::Tileset >(); return inValue; }
		if (HX_FIELD_EQ(inName,"pixels") ) { pixels=inValue.Cast<  ::openfl::display::BitmapData >(); return inValue; }
		if (HX_FIELD_EQ(inName,"frames") ) { frames=inValue.Cast< ::Array< int > >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"metadata") ) { metadata=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"currTime") ) { currTime=inValue.Cast< int >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"autotiles") ) { autotiles=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"durations") ) { durations=inValue.Cast< ::Array< int > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"currFrame") ) { currFrame=inValue.Cast< int >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"frameIndex") ) { frameIndex=inValue.Cast< int >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"collisionID") ) { collisionID=inValue.Cast< int >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"updateSource") ) { updateSource=inValue.Cast< bool >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"autotileFormat") ) { autotileFormat=inValue.Cast<  ::com::stencyl::models::scene::AutotileFormat >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"autotileMergeSet") ) { autotileMergeSet=inValue.Cast<  ::haxe::ds::IntMap >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool Tile_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 9:
		if (HX_FIELD_EQ(inName,"dummyRect") ) { dummyRect=ioValue.Cast<  ::openfl::geom::Rectangle >(); return true; }
	}
	return false;
}

void Tile_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("tileID","\x89","\xb2","\x28","\x1e"));
	outFields->push(HX_HCSTRING("collisionID","\xcd","\x68","\x8b","\x1d"));
	outFields->push(HX_HCSTRING("metadata","\x6f","\xe7","\x19","\x40"));
	outFields->push(HX_HCSTRING("frameIndex","\xa5","\xcf","\x3a","\xa1"));
	outFields->push(HX_HCSTRING("parent","\x2a","\x05","\x7e","\xed"));
	outFields->push(HX_HCSTRING("autotileFormat","\x34","\x85","\xf9","\xb1"));
	outFields->push(HX_HCSTRING("autotiles","\xb6","\xcb","\x12","\x5b"));
	outFields->push(HX_HCSTRING("autotileMergeSet","\x07","\x63","\xfb","\xc5"));
	outFields->push(HX_HCSTRING("pixels","\x2d","\xef","\xa9","\x8c"));
	outFields->push(HX_HCSTRING("durations","\x9f","\x5a","\xbf","\xe7"));
	outFields->push(HX_HCSTRING("frames","\xa6","\xaf","\x85","\xac"));
	outFields->push(HX_HCSTRING("currFrame","\xdb","\xaf","\x58","\x6a"));
	outFields->push(HX_HCSTRING("currTime","\x1f","\xa4","\x04","\x90"));
	outFields->push(HX_HCSTRING("updateSource","\xc4","\x57","\xf5","\x31"));
	outFields->push(HX_HCSTRING("data","\x2a","\x56","\x63","\x42"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Tile_obj_sMemberStorageInfo[] = {
	{hx::fsInt,(int)offsetof(Tile_obj,tileID),HX_HCSTRING("tileID","\x89","\xb2","\x28","\x1e")},
	{hx::fsInt,(int)offsetof(Tile_obj,collisionID),HX_HCSTRING("collisionID","\xcd","\x68","\x8b","\x1d")},
	{hx::fsString,(int)offsetof(Tile_obj,metadata),HX_HCSTRING("metadata","\x6f","\xe7","\x19","\x40")},
	{hx::fsInt,(int)offsetof(Tile_obj,frameIndex),HX_HCSTRING("frameIndex","\xa5","\xcf","\x3a","\xa1")},
	{hx::fsObject /*::com::stencyl::models::scene::Tileset*/ ,(int)offsetof(Tile_obj,parent),HX_HCSTRING("parent","\x2a","\x05","\x7e","\xed")},
	{hx::fsObject /*::com::stencyl::models::scene::AutotileFormat*/ ,(int)offsetof(Tile_obj,autotileFormat),HX_HCSTRING("autotileFormat","\x34","\x85","\xf9","\xb1")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Tile_obj,autotiles),HX_HCSTRING("autotiles","\xb6","\xcb","\x12","\x5b")},
	{hx::fsObject /*::haxe::ds::IntMap*/ ,(int)offsetof(Tile_obj,autotileMergeSet),HX_HCSTRING("autotileMergeSet","\x07","\x63","\xfb","\xc5")},
	{hx::fsObject /*::openfl::display::BitmapData*/ ,(int)offsetof(Tile_obj,pixels),HX_HCSTRING("pixels","\x2d","\xef","\xa9","\x8c")},
	{hx::fsObject /*Array< int >*/ ,(int)offsetof(Tile_obj,durations),HX_HCSTRING("durations","\x9f","\x5a","\xbf","\xe7")},
	{hx::fsObject /*Array< int >*/ ,(int)offsetof(Tile_obj,frames),HX_HCSTRING("frames","\xa6","\xaf","\x85","\xac")},
	{hx::fsInt,(int)offsetof(Tile_obj,currFrame),HX_HCSTRING("currFrame","\xdb","\xaf","\x58","\x6a")},
	{hx::fsInt,(int)offsetof(Tile_obj,currTime),HX_HCSTRING("currTime","\x1f","\xa4","\x04","\x90")},
	{hx::fsBool,(int)offsetof(Tile_obj,updateSource),HX_HCSTRING("updateSource","\xc4","\x57","\xf5","\x31")},
	{hx::fsObject /*::openfl::display::Tileset*/ ,(int)offsetof(Tile_obj,data),HX_HCSTRING("data","\x2a","\x56","\x63","\x42")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo Tile_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*::openfl::geom::Rectangle*/ ,(void *) &Tile_obj::dummyRect,HX_HCSTRING("dummyRect","\x6c","\xbb","\xe1","\xb5")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String Tile_obj_sMemberFields[] = {
	HX_HCSTRING("tileID","\x89","\xb2","\x28","\x1e"),
	HX_HCSTRING("collisionID","\xcd","\x68","\x8b","\x1d"),
	HX_HCSTRING("metadata","\x6f","\xe7","\x19","\x40"),
	HX_HCSTRING("frameIndex","\xa5","\xcf","\x3a","\xa1"),
	HX_HCSTRING("parent","\x2a","\x05","\x7e","\xed"),
	HX_HCSTRING("autotileFormat","\x34","\x85","\xf9","\xb1"),
	HX_HCSTRING("autotiles","\xb6","\xcb","\x12","\x5b"),
	HX_HCSTRING("autotileMergeSet","\x07","\x63","\xfb","\xc5"),
	HX_HCSTRING("pixels","\x2d","\xef","\xa9","\x8c"),
	HX_HCSTRING("durations","\x9f","\x5a","\xbf","\xe7"),
	HX_HCSTRING("frames","\xa6","\xaf","\x85","\xac"),
	HX_HCSTRING("currFrame","\xdb","\xaf","\x58","\x6a"),
	HX_HCSTRING("currTime","\x1f","\xa4","\x04","\x90"),
	HX_HCSTRING("updateSource","\xc4","\x57","\xf5","\x31"),
	HX_HCSTRING("data","\x2a","\x56","\x63","\x42"),
	HX_HCSTRING("update","\x09","\x86","\x05","\x87"),
	HX_HCSTRING("getSource","\x11","\x3a","\x88","\xae"),
	HX_HCSTRING("loadGraphics","\x11","\xe5","\xd0","\xcb"),
	HX_HCSTRING("unloadGraphics","\xea","\xec","\xbd","\xbd"),
	HX_HCSTRING("loadAnimationPixels","\xcb","\x35","\x3e","\x84"),
	HX_HCSTRING("createAutotileAnimations","\x88","\x67","\x49","\x1b"),
	HX_HCSTRING("sourceRect","\x9f","\x33","\x0b","\x74"),
	::String(null()) };

static void Tile_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Tile_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(Tile_obj::dummyRect,"dummyRect");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Tile_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Tile_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(Tile_obj::dummyRect,"dummyRect");
};

#endif

hx::Class Tile_obj::__mClass;

static ::String Tile_obj_sStaticFields[] = {
	HX_HCSTRING("dummyRect","\x6c","\xbb","\xe1","\xb5"),
	::String(null())
};

void Tile_obj::__register()
{
	hx::Object *dummy = new Tile_obj;
	Tile_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("com.stencyl.models.scene.Tile","\x85","\x99","\xc0","\x87");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Tile_obj::__GetStatic;
	__mClass->mSetStaticField = &Tile_obj::__SetStatic;
	__mClass->mMarkFunc = Tile_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Tile_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Tile_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Tile_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Tile_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Tile_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Tile_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Tile_obj::__boot()
{
{
            	HX_GC_STACKFRAME(&_hx_pos_182cc35112715a86_210_boot)
HXDLIN( 210)		dummyRect =  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            	}
}

} // end namespace com
} // end namespace stencyl
} // end namespace models
} // end namespace scene
