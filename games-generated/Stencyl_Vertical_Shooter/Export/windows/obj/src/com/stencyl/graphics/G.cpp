// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_com_stencyl_Config
#include <com/stencyl/Config.h>
#endif
#ifndef INCLUDED_com_stencyl_Engine
#include <com/stencyl/Engine.h>
#endif
#ifndef INCLUDED_com_stencyl_graphics_G
#include <com/stencyl/graphics/G.h>
#endif
#ifndef INCLUDED_com_stencyl_graphics__G_TemporaryImage
#include <com/stencyl/graphics/_G/TemporaryImage.h>
#endif
#ifndef INCLUDED_com_stencyl_graphics_fonts_BitmapFont
#include <com/stencyl/graphics/fonts/BitmapFont.h>
#endif
#ifndef INCLUDED_com_stencyl_models_Actor
#include <com/stencyl/models/Actor.h>
#endif
#ifndef INCLUDED_com_stencyl_models_Font
#include <com/stencyl/models/Font.h>
#endif
#ifndef INCLUDED_com_stencyl_models_Resource
#include <com/stencyl/models/Resource.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_Graphics
#include <openfl/display/Graphics.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_6550bfc6d7343f4a_70_new,"com.stencyl.graphics.G","new",0xf21f39a5,"com.stencyl.graphics.G.new","com/stencyl/graphics/G.hx",70,0x0bf8b3aa)
static const Float _hx_array_data_44f68333_1[] = {
	0.0,0.0,(Float)0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_6550bfc6d7343f4a_123_resetGraphicsSettings,"com.stencyl.graphics.G","resetGraphicsSettings",0x4ea98742,"com.stencyl.graphics.G.resetGraphicsSettings","com/stencyl/graphics/G.hx",123,0x0bf8b3aa)
HX_LOCAL_STACK_FRAME(_hx_pos_6550bfc6d7343f4a_133_setFont,"com.stencyl.graphics.G","setFont",0x0a1e8e56,"com.stencyl.graphics.G.setFont","com/stencyl/graphics/G.hx",133,0x0bf8b3aa)
HX_LOCAL_STACK_FRAME(_hx_pos_6550bfc6d7343f4a_164_startGraphics,"com.stencyl.graphics.G","startGraphics",0x4a9eecd2,"com.stencyl.graphics.G.startGraphics","com/stencyl/graphics/G.hx",164,0x0bf8b3aa)
HX_LOCAL_STACK_FRAME(_hx_pos_6550bfc6d7343f4a_190_endGraphics,"com.stencyl.graphics.G","endGraphics",0xde14420b,"com.stencyl.graphics.G.endGraphics","com/stencyl/graphics/G.hx",190,0x0bf8b3aa)
HX_LOCAL_STACK_FRAME(_hx_pos_6550bfc6d7343f4a_201_translate,"com.stencyl.graphics.G","translate",0xa8890253,"com.stencyl.graphics.G.translate","com/stencyl/graphics/G.hx",201,0x0bf8b3aa)
HX_LOCAL_STACK_FRAME(_hx_pos_6550bfc6d7343f4a_208_moveTo,"com.stencyl.graphics.G","moveTo",0x60c4c2c7,"com.stencyl.graphics.G.moveTo","com/stencyl/graphics/G.hx",208,0x0bf8b3aa)
HX_LOCAL_STACK_FRAME(_hx_pos_6550bfc6d7343f4a_227_translateToScreen,"com.stencyl.graphics.G","translateToScreen",0x68edacba,"com.stencyl.graphics.G.translateToScreen","com/stencyl/graphics/G.hx",227,0x0bf8b3aa)
HX_LOCAL_STACK_FRAME(_hx_pos_6550bfc6d7343f4a_236_translateToActor,"com.stencyl.graphics.G","translateToActor",0x10527d67,"com.stencyl.graphics.G.translateToActor","com/stencyl/graphics/G.hx",236,0x0bf8b3aa)
HX_LOCAL_STACK_FRAME(_hx_pos_6550bfc6d7343f4a_278_getCacheKey,"com.stencyl.graphics.G","getCacheKey",0xd4027578,"com.stencyl.graphics.G.getCacheKey","com/stencyl/graphics/G.hx",278,0x0bf8b3aa)
HX_LOCAL_STACK_FRAME(_hx_pos_6550bfc6d7343f4a_282_drawString,"com.stencyl.graphics.G","drawString",0x1bf01d50,"com.stencyl.graphics.G.drawString","com/stencyl/graphics/G.hx",282,0x0bf8b3aa)
HX_LOCAL_STACK_FRAME(_hx_pos_6550bfc6d7343f4a_377_drawLine,"com.stencyl.graphics.G","drawLine",0x19f49eb3,"com.stencyl.graphics.G.drawLine","com/stencyl/graphics/G.hx",377,0x0bf8b3aa)
HX_LOCAL_STACK_FRAME(_hx_pos_6550bfc6d7343f4a_392_fillPixel,"com.stencyl.graphics.G","fillPixel",0xf0541808,"com.stencyl.graphics.G.fillPixel","com/stencyl/graphics/G.hx",392,0x0bf8b3aa)
HX_LOCAL_STACK_FRAME(_hx_pos_6550bfc6d7343f4a_410_drawRect,"com.stencyl.graphics.G","drawRect",0x1de8d3e3,"com.stencyl.graphics.G.drawRect","com/stencyl/graphics/G.hx",410,0x0bf8b3aa)
HX_LOCAL_STACK_FRAME(_hx_pos_6550bfc6d7343f4a_424_fillRect,"com.stencyl.graphics.G","fillRect",0x2a9121e2,"com.stencyl.graphics.G.fillRect","com/stencyl/graphics/G.hx",424,0x0bf8b3aa)
HX_LOCAL_STACK_FRAME(_hx_pos_6550bfc6d7343f4a_440_drawRoundRect,"com.stencyl.graphics.G","drawRoundRect",0x16265573,"com.stencyl.graphics.G.drawRoundRect","com/stencyl/graphics/G.hx",440,0x0bf8b3aa)
HX_LOCAL_STACK_FRAME(_hx_pos_6550bfc6d7343f4a_454_fillRoundRect,"com.stencyl.graphics.G","fillRoundRect",0x9847eb14,"com.stencyl.graphics.G.fillRoundRect","com/stencyl/graphics/G.hx",454,0x0bf8b3aa)
HX_LOCAL_STACK_FRAME(_hx_pos_6550bfc6d7343f4a_470_drawCircle,"com.stencyl.graphics.G","drawCircle",0x60cd668f,"com.stencyl.graphics.G.drawCircle","com/stencyl/graphics/G.hx",470,0x0bf8b3aa)
HX_LOCAL_STACK_FRAME(_hx_pos_6550bfc6d7343f4a_483_fillCircle,"com.stencyl.graphics.G","fillCircle",0x22a4724e,"com.stencyl.graphics.G.fillCircle","com/stencyl/graphics/G.hx",483,0x0bf8b3aa)
HX_LOCAL_STACK_FRAME(_hx_pos_6550bfc6d7343f4a_498_beginFillPolygon,"com.stencyl.graphics.G","beginFillPolygon",0x6d446e29,"com.stencyl.graphics.G.beginFillPolygon","com/stencyl/graphics/G.hx",498,0x0bf8b3aa)
HX_LOCAL_STACK_FRAME(_hx_pos_6550bfc6d7343f4a_508_endDrawingPolygon,"com.stencyl.graphics.G","endDrawingPolygon",0x2ab3effc,"com.stencyl.graphics.G.endDrawingPolygon","com/stencyl/graphics/G.hx",508,0x0bf8b3aa)
HX_LOCAL_STACK_FRAME(_hx_pos_6550bfc6d7343f4a_526_beginDrawPolygon,"com.stencyl.graphics.G","beginDrawPolygon",0x92f132c8,"com.stencyl.graphics.G.beginDrawPolygon","com/stencyl/graphics/G.hx",526,0x0bf8b3aa)
HX_LOCAL_STACK_FRAME(_hx_pos_6550bfc6d7343f4a_535_addPointToPolygon,"com.stencyl.graphics.G","addPointToPolygon",0xcc4d31d5,"com.stencyl.graphics.G.addPointToPolygon","com/stencyl/graphics/G.hx",535,0x0bf8b3aa)
HX_LOCAL_STACK_FRAME(_hx_pos_6550bfc6d7343f4a_558_drawImage,"com.stencyl.graphics.G","drawImage",0xe47d7fbc,"com.stencyl.graphics.G.drawImage","com/stencyl/graphics/G.hx",558,0x0bf8b3aa)
HX_LOCAL_STACK_FRAME(_hx_pos_6550bfc6d7343f4a_653_toARGB,"com.stencyl.graphics.G","toARGB",0x0a2d8422,"com.stencyl.graphics.G.toARGB","com/stencyl/graphics/G.hx",653,0x0bf8b3aa)
HX_LOCAL_STACK_FRAME(_hx_pos_6550bfc6d7343f4a_662_resetFont,"com.stencyl.graphics.G","resetFont",0xe8b59243,"com.stencyl.graphics.G.resetFont","com/stencyl/graphics/G.hx",662,0x0bf8b3aa)
HX_LOCAL_STACK_FRAME(_hx_pos_6550bfc6d7343f4a_66_resetStatics,"com.stencyl.graphics.G","resetStatics",0x04554811,"com.stencyl.graphics.G.resetStatics","com/stencyl/graphics/G.hx",66,0x0bf8b3aa)
HX_LOCAL_STACK_FRAME(_hx_pos_6550bfc6d7343f4a_358_visitStringCache,"com.stencyl.graphics.G","visitStringCache",0x117d6741,"com.stencyl.graphics.G.visitStringCache","com/stencyl/graphics/G.hx",358,0x0bf8b3aa)
HX_LOCAL_STACK_FRAME(_hx_pos_6550bfc6d7343f4a_62_boot,"com.stencyl.graphics.G","boot",0xe14c374d,"com.stencyl.graphics.G.boot","com/stencyl/graphics/G.hx",62,0x0bf8b3aa)
HX_LOCAL_STACK_FRAME(_hx_pos_6550bfc6d7343f4a_273_boot,"com.stencyl.graphics.G","boot",0xe14c374d,"com.stencyl.graphics.G.boot","com/stencyl/graphics/G.hx",273,0x0bf8b3aa)
HX_LOCAL_STACK_FRAME(_hx_pos_6550bfc6d7343f4a_274_boot,"com.stencyl.graphics.G","boot",0xe14c374d,"com.stencyl.graphics.G.boot","com/stencyl/graphics/G.hx",274,0x0bf8b3aa)
namespace com{
namespace stencyl{
namespace graphics{

void G_obj::__construct(){
            	HX_GC_STACKFRAME(&_hx_pos_6550bfc6d7343f4a_70_new)
HXLINE(  71)		this->drawActor = false;
HXLINE(  73)		this->x = (this->y = (int)0);
HXLINE(  74)		this->scaleX = (this->scaleY = ::com::stencyl::Engine_obj::SCALE);
HXLINE(  75)		this->alpha = (int)1;
HXLINE(  76)		this->blendMode = (int)10;
HXLINE(  78)		this->strokeSize = (int)0;
HXLINE(  80)		this->fillColor = (int)0;
HXLINE(  81)		this->strokeColor = (int)0;
HXLINE(  85)		this->rect =  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,null(),null(),null(),null());
HXLINE(  86)		this->rect2 =  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,null(),null(),null(),null());
HXLINE(  87)		this->point =  ::openfl::geom::Point_obj::__alloc( HX_CTX ,null(),null());
HXLINE(  88)		this->point2 =  ::openfl::geom::Point_obj::__alloc( HX_CTX ,null(),null());
HXLINE(  89)		this->data = ::Array_obj< Float >::fromData( _hx_array_data_44f68333_1,3);
HXLINE(  93)		this->drawPoly = false;
HXLINE(  94)		this->pointCounter = (int)0;
HXLINE(  95)		this->firstX = (int)0;
HXLINE(  96)		this->firstY = (int)0;
HXLINE(  98)		this->font = (this->defaultFont =  ::com::stencyl::models::Font_obj::__alloc( HX_CTX ,(int)-1,(int)0,HX_("",00,00,00,00),true));
HXLINE( 100)		this->mtx =  ::openfl::geom::Matrix_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null());
            	}

Dynamic G_obj::__CreateEmpty() { return new G_obj; }

void *G_obj::_hx_vtable = 0;

Dynamic G_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< G_obj > _hx_result = new G_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool G_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x2d9d8f31;
}

void G_obj::resetGraphicsSettings(){
            	HX_STACKFRAME(&_hx_pos_6550bfc6d7343f4a_123_resetGraphicsSettings)
HXLINE( 124)		this->alpha = (int)1;
HXLINE( 125)		this->strokeSize = (int)0;
HXLINE( 126)		this->fillColor = (int)0;
HXLINE( 127)		this->strokeColor = (int)0;
HXLINE( 128)		this->font = this->defaultFont;
            	}


HX_DEFINE_DYNAMIC_FUNC0(G_obj,resetGraphicsSettings,(void))

void G_obj::setFont( ::com::stencyl::models::Font newFont){
            	HX_STACKFRAME(&_hx_pos_6550bfc6d7343f4a_133_setFont)
HXDLIN( 133)		bool _hx_tmp;
HXDLIN( 133)		if (hx::IsNotNull( newFont )) {
HXDLIN( 133)			_hx_tmp = hx::IsNotEq( newFont,this->font );
            		}
            		else {
HXDLIN( 133)			_hx_tmp = false;
            		}
HXDLIN( 133)		if (_hx_tmp) {
HXLINE( 135)			this->font = newFont;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(G_obj,setFont,(void))

void G_obj::startGraphics(){
            	HX_STACKFRAME(&_hx_pos_6550bfc6d7343f4a_164_startGraphics)
HXLINE( 165)		if (this->drawActor) {
HXLINE( 167)			bool _hx_tmp;
HXDLIN( 167)			if (hx::IsNotNull( this->actor )) {
HXLINE( 167)				_hx_tmp = this->actor->isHUD;
            			}
            			else {
HXLINE( 167)				_hx_tmp = false;
            			}
HXDLIN( 167)			if (!(_hx_tmp)) {
HXLINE( 173)				 ::com::stencyl::graphics::G _hx_tmp1 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 173)				_hx_tmp1->x = (_hx_tmp1->x - ::com::stencyl::Engine_obj::cameraX);
HXLINE( 174)				 ::com::stencyl::graphics::G _hx_tmp2 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 174)				_hx_tmp2->y = (_hx_tmp2->y - ::com::stencyl::Engine_obj::cameraY);
            			}
            		}
HXLINE( 178)		if ((this->strokeSize == (int)0)) {
HXLINE( 180)			this->graphics->lineStyle(null(),null(),null(),null(),null(),null(),null(),null());
            		}
            		else {
HXLINE( 185)			this->graphics->lineStyle(this->strokeSize,this->strokeColor,this->alpha,null(),null(),null(),null(),null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(G_obj,startGraphics,(void))

void G_obj::endGraphics(){
            	HX_STACKFRAME(&_hx_pos_6550bfc6d7343f4a_190_endGraphics)
HXLINE( 191)		bool _hx_tmp;
HXDLIN( 191)		if (this->drawActor) {
HXLINE( 191)			_hx_tmp = !(this->actor->isHUD);
            		}
            		else {
HXLINE( 191)			_hx_tmp = false;
            		}
HXDLIN( 191)		if (_hx_tmp) {
HXLINE( 193)			 ::com::stencyl::graphics::G _hx_tmp1 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 193)			_hx_tmp1->x = (_hx_tmp1->x + ::com::stencyl::Engine_obj::cameraX);
HXLINE( 194)			 ::com::stencyl::graphics::G _hx_tmp2 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 194)			_hx_tmp2->y = (_hx_tmp2->y + ::com::stencyl::Engine_obj::cameraY);
            		}
HXLINE( 197)		this->graphics->lineStyle(null(),null(),null(),null(),null(),null(),null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC0(G_obj,endGraphics,(void))

void G_obj::translate(Float x,Float y){
            	HX_STACKFRAME(&_hx_pos_6550bfc6d7343f4a_201_translate)
HXLINE( 202)		 ::com::stencyl::graphics::G _hx_tmp = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 202)		_hx_tmp->x = (_hx_tmp->x + (x * this->scaleX));
HXLINE( 203)		 ::com::stencyl::graphics::G _hx_tmp1 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 203)		_hx_tmp1->y = (_hx_tmp1->y + (y * this->scaleY));
            	}


HX_DEFINE_DYNAMIC_FUNC2(G_obj,translate,(void))

void G_obj::moveTo(Float x,Float y){
            	HX_STACKFRAME(&_hx_pos_6550bfc6d7343f4a_208_moveTo)
HXDLIN( 208)		if (this->drawActor) {
HXLINE( 210)			if (hx::IsNotNull( this->actor )) {
HXLINE( 212)				 ::com::stencyl::models::Actor a = this->actor;
HXDLIN( 212)				this->drawActor = true;
HXDLIN( 212)				this->actor = a;
HXDLIN( 212)				if (a->smoothMove) {
HXLINE( 212)					Float a1 = a->drawX;
HXDLIN( 212)					Float drawX = ((a1 - ::Math_obj::floor(((Float)a->cacheWidth / (Float)(int)2))) - a->currOffset->x);
HXDLIN( 212)					Float a2 = a->drawY;
HXDLIN( 212)					Float drawY = ((a2 - ::Math_obj::floor(((Float)a->cacheHeight / (Float)(int)2))) - a->currOffset->y);
HXDLIN( 212)					if (::com::stencyl::Engine_obj::NO_PHYSICS) {
HXLINE( 212)						this->x = (drawX * this->scaleX);
HXDLIN( 212)						this->y = (drawY * this->scaleY);
            					}
            					else {
HXLINE( 212)						this->x = (drawX * this->scaleX);
HXDLIN( 212)						this->y = (drawY * this->scaleY);
            					}
            				}
            				else {
HXLINE( 212)					if (::com::stencyl::Engine_obj::NO_PHYSICS) {
HXLINE( 212)						this->x = (a->colX * this->scaleX);
HXDLIN( 212)						this->y = (a->colY * this->scaleY);
            					}
            					else {
HXLINE( 212)						this->x = (a->colX * this->scaleX);
HXDLIN( 212)						this->y = (a->colY * this->scaleY);
            					}
            				}
            			}
HXLINE( 215)			 ::com::stencyl::graphics::G _hx_tmp = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 215)			_hx_tmp->x = (_hx_tmp->x + (x * this->scaleX));
HXLINE( 216)			 ::com::stencyl::graphics::G _hx_tmp1 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 216)			_hx_tmp1->y = (_hx_tmp1->y + (y * this->scaleY));
            		}
            		else {
HXLINE( 221)			this->x = (x * this->scaleX);
HXLINE( 222)			this->y = (y * this->scaleY);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(G_obj,moveTo,(void))

void G_obj::translateToScreen(){
            	HX_STACKFRAME(&_hx_pos_6550bfc6d7343f4a_227_translateToScreen)
HXLINE( 228)		this->drawActor = false;
HXLINE( 229)		this->actor = null();
HXLINE( 231)		this->x = (int)0;
HXLINE( 232)		this->y = (int)0;
            	}


HX_DEFINE_DYNAMIC_FUNC0(G_obj,translateToScreen,(void))

void G_obj::translateToActor( ::com::stencyl::models::Actor a){
            	HX_STACKFRAME(&_hx_pos_6550bfc6d7343f4a_236_translateToActor)
HXLINE( 237)		this->drawActor = true;
HXLINE( 238)		this->actor = a;
HXLINE( 240)		if (a->smoothMove) {
HXLINE( 242)			Float a1 = a->drawX;
HXDLIN( 242)			Float drawX = ((a1 - ::Math_obj::floor(((Float)a->cacheWidth / (Float)(int)2))) - a->currOffset->x);
HXLINE( 243)			Float a2 = a->drawY;
HXDLIN( 243)			Float drawY = ((a2 - ::Math_obj::floor(((Float)a->cacheHeight / (Float)(int)2))) - a->currOffset->y);
HXLINE( 245)			if (::com::stencyl::Engine_obj::NO_PHYSICS) {
HXLINE( 247)				this->x = (drawX * this->scaleX);
HXLINE( 248)				this->y = (drawY * this->scaleY);
            			}
            			else {
HXLINE( 253)				this->x = (drawX * this->scaleX);
HXLINE( 254)				this->y = (drawY * this->scaleY);
            			}
            		}
            		else {
HXLINE( 259)			if (::com::stencyl::Engine_obj::NO_PHYSICS) {
HXLINE( 261)				this->x = (a->colX * this->scaleX);
HXLINE( 262)				this->y = (a->colY * this->scaleY);
            			}
            			else {
HXLINE( 267)				this->x = (a->colX * this->scaleX);
HXLINE( 268)				this->y = (a->colY * this->scaleY);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(G_obj,translateToActor,(void))

::String G_obj::getCacheKey(::String string, ::com::stencyl::models::Font font,Float alpha){
            	HX_STACKFRAME(&_hx_pos_6550bfc6d7343f4a_278_getCacheKey)
HXDLIN( 278)		return ((((((((string + HX_(":",3a,00,00,00)) + font->ID) + HX_(":",3a,00,00,00)) + alpha) + HX_(":",3a,00,00,00)) + font->letterSpacing) + HX_(":",3a,00,00,00)) + ::com::stencyl::Engine_obj::SCALE);
            	}


HX_DEFINE_DYNAMIC_FUNC3(G_obj,getCacheKey,return )

void G_obj::drawString(::String s,Float x,Float y){
            	HX_GC_STACKFRAME(&_hx_pos_6550bfc6d7343f4a_282_drawString)
HXLINE( 283)		if (hx::IsNull( this->font )) {
HXLINE( 285)			this->font = this->defaultFont;
HXDLIN( 285)			if ((this->font->fontScale != ::com::stencyl::Engine_obj::SCALE)) {
HXLINE( 285)				this->font->fontScale = ::com::stencyl::Engine_obj::SCALE;
            			}
            		}
HXLINE( 288)		Float drawX;
HXLINE( 289)		Float drawY;
HXLINE( 291)		if (this->drawActor) {
HXLINE( 293)			bool _hx_tmp;
HXDLIN( 293)			if (hx::IsNotNull( this->actor )) {
HXLINE( 293)				_hx_tmp = this->actor->isHUD;
            			}
            			else {
HXLINE( 293)				_hx_tmp = false;
            			}
HXDLIN( 293)			if (_hx_tmp) {
HXLINE( 295)				Float drawX1 = this->x;
HXDLIN( 295)				drawX = (drawX1 + (x * this->scaleX));
HXLINE( 296)				Float drawY1 = this->y;
HXDLIN( 296)				drawY = (drawY1 + (y * this->scaleY));
            			}
            			else {
HXLINE( 301)				Float drawX2 = this->x;
HXDLIN( 301)				drawX = ((drawX2 + (x * this->scaleX)) - ::com::stencyl::Engine_obj::cameraX);
HXLINE( 302)				Float drawY2 = this->y;
HXDLIN( 302)				drawY = ((drawY2 + (y * this->scaleY)) - ::com::stencyl::Engine_obj::cameraY);
            			}
            		}
            		else {
HXLINE( 308)			Float drawX3 = this->x;
HXDLIN( 308)			drawX = (drawX3 + (x * this->scaleX));
HXLINE( 309)			Float drawY3 = this->y;
HXDLIN( 309)			drawY = (drawY3 + (y * this->scaleY));
            		}
HXLINE( 312)		this->mtx->identity();
HXLINE( 313)		this->mtx->translate(drawX,drawY);
HXLINE( 315)		 ::openfl::display::BitmapData toDraw = null();
HXLINE( 317)		 ::com::stencyl::models::Font font = this->font;
HXDLIN( 317)		::String cacheKey = ((((((((s + HX_(":",3a,00,00,00)) + font->ID) + HX_(":",3a,00,00,00)) + this->alpha) + HX_(":",3a,00,00,00)) + font->letterSpacing) + HX_(":",3a,00,00,00)) + ::com::stencyl::Engine_obj::SCALE);
HXLINE( 318)		if (::com::stencyl::graphics::G_obj::drawnStringCache->exists(cacheKey)) {
HXLINE( 320)			 ::com::stencyl::graphics::_G::TemporaryImage temp = ::com::stencyl::graphics::G_obj::drawnStringCache->get(cacheKey).StaticCast<  ::com::stencyl::graphics::_G::TemporaryImage >();
HXLINE( 321)			temp->lifetime = (int)5;
HXLINE( 322)			toDraw = temp->img;
            		}
            		else {
HXLINE( 326)			int w = this->font->font->getTextWidth(s,this->font->letterSpacing,this->font->fontScale);
HXLINE( 327)			int h = this->font->font->getFontHeight();
HXDLIN( 327)			int h1 = ::Std_obj::_hx_int((h * this->font->fontScale));
HXLINE( 329)			bool _hx_tmp1;
HXDLIN( 329)			if ((w > (int)0)) {
HXLINE( 329)				_hx_tmp1 = (h1 > (int)0);
            			}
            			else {
HXLINE( 329)				_hx_tmp1 = false;
            			}
HXDLIN( 329)			if (_hx_tmp1) {
HXLINE( 331)				toDraw =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,w,h1,true,(int)0);
HXLINE( 336)				this->font->font->renderToImg(toDraw,s,(int)0,this->alpha,(int)0,(int)0,this->font->letterSpacing,this->font->fontScale,(int)0,false);
HXLINE( 339)				 ::com::stencyl::graphics::_G::TemporaryImage temp1 =  ::com::stencyl::graphics::_G::TemporaryImage_obj::__alloc( HX_CTX );
HXLINE( 340)				temp1->img = toDraw;
HXLINE( 341)				temp1->lifetime = (int)5;
HXLINE( 343)				::com::stencyl::graphics::G_obj::drawnStringCache->set(cacheKey,temp1);
HXLINE( 344)				::com::stencyl::graphics::G_obj::drawnStringCacheKeys->push(cacheKey);
            			}
            		}
HXLINE( 349)		if (hx::IsNotNull( toDraw )) {
HXLINE( 351)			this->graphics->beginBitmapFill(toDraw,this->mtx,false,::com::stencyl::Config_obj::antialias);
HXLINE( 352)			this->graphics->drawRect(drawX,drawY,toDraw->width,toDraw->height);
HXLINE( 353)			this->graphics->endFill();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(G_obj,drawString,(void))

void G_obj::drawLine(Float x1,Float y1,Float x2,Float y2){
            	HX_STACKFRAME(&_hx_pos_6550bfc6d7343f4a_377_drawLine)
HXLINE( 378)		x1 = (x1 * this->scaleX);
HXLINE( 379)		y1 = (y1 * this->scaleY);
HXLINE( 380)		x2 = (x2 * this->scaleX);
HXLINE( 381)		y2 = (y2 * this->scaleY);
HXLINE( 383)		{
HXLINE( 383)			if (this->drawActor) {
HXLINE( 383)				bool _hx_tmp;
HXDLIN( 383)				if (hx::IsNotNull( this->actor )) {
HXLINE( 383)					_hx_tmp = this->actor->isHUD;
            				}
            				else {
HXLINE( 383)					_hx_tmp = false;
            				}
HXDLIN( 383)				if (!(_hx_tmp)) {
HXLINE( 383)					 ::com::stencyl::graphics::G _hx_tmp1 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 383)					_hx_tmp1->x = (_hx_tmp1->x - ::com::stencyl::Engine_obj::cameraX);
HXDLIN( 383)					 ::com::stencyl::graphics::G _hx_tmp2 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 383)					_hx_tmp2->y = (_hx_tmp2->y - ::com::stencyl::Engine_obj::cameraY);
            				}
            			}
HXDLIN( 383)			if ((this->strokeSize == (int)0)) {
HXLINE( 383)				this->graphics->lineStyle(null(),null(),null(),null(),null(),null(),null(),null());
            			}
            			else {
HXLINE( 383)				this->graphics->lineStyle(this->strokeSize,this->strokeColor,this->alpha,null(),null(),null(),null(),null());
            			}
            		}
HXLINE( 385)		 ::openfl::display::Graphics _hx_tmp3 = this->graphics;
HXDLIN( 385)		Float _hx_tmp4 = (this->x + x1);
HXDLIN( 385)		_hx_tmp3->moveTo(_hx_tmp4,(this->y + y1));
HXLINE( 386)		 ::openfl::display::Graphics _hx_tmp5 = this->graphics;
HXDLIN( 386)		Float _hx_tmp6 = (this->x + x2);
HXDLIN( 386)		_hx_tmp5->lineTo(_hx_tmp6,(this->y + y2));
HXLINE( 388)		{
HXLINE( 388)			bool _hx_tmp7;
HXDLIN( 388)			if (this->drawActor) {
HXLINE( 388)				_hx_tmp7 = !(this->actor->isHUD);
            			}
            			else {
HXLINE( 388)				_hx_tmp7 = false;
            			}
HXDLIN( 388)			if (_hx_tmp7) {
HXLINE( 388)				 ::com::stencyl::graphics::G _hx_tmp8 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 388)				_hx_tmp8->x = (_hx_tmp8->x + ::com::stencyl::Engine_obj::cameraX);
HXDLIN( 388)				 ::com::stencyl::graphics::G _hx_tmp9 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 388)				_hx_tmp9->y = (_hx_tmp9->y + ::com::stencyl::Engine_obj::cameraY);
            			}
HXDLIN( 388)			this->graphics->lineStyle(null(),null(),null(),null(),null(),null(),null(),null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(G_obj,drawLine,(void))

void G_obj::fillPixel(Float x,Float y){
            	HX_STACKFRAME(&_hx_pos_6550bfc6d7343f4a_392_fillPixel)
HXLINE( 393)		{
HXLINE( 393)			if (this->drawActor) {
HXLINE( 393)				bool _hx_tmp;
HXDLIN( 393)				if (hx::IsNotNull( this->actor )) {
HXLINE( 393)					_hx_tmp = this->actor->isHUD;
            				}
            				else {
HXLINE( 393)					_hx_tmp = false;
            				}
HXDLIN( 393)				if (!(_hx_tmp)) {
HXLINE( 393)					 ::com::stencyl::graphics::G _hx_tmp1 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 393)					_hx_tmp1->x = (_hx_tmp1->x - ::com::stencyl::Engine_obj::cameraX);
HXDLIN( 393)					 ::com::stencyl::graphics::G _hx_tmp2 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 393)					_hx_tmp2->y = (_hx_tmp2->y - ::com::stencyl::Engine_obj::cameraY);
            				}
            			}
HXDLIN( 393)			if ((this->strokeSize == (int)0)) {
HXLINE( 393)				this->graphics->lineStyle(null(),null(),null(),null(),null(),null(),null(),null());
            			}
            			else {
HXLINE( 393)				this->graphics->lineStyle(this->strokeSize,this->strokeColor,this->alpha,null(),null(),null(),null(),null());
            			}
            		}
HXLINE( 395)		this->graphics->lineStyle(null(),null(),null(),null(),null(),null(),null(),null());
HXLINE( 396)		this->graphics->beginFill(this->fillColor,this->alpha);
HXLINE( 397)		 ::openfl::display::Graphics _hx_tmp3 = this->graphics;
HXLINE( 399)		Float _hx_tmp4 = this->x;
HXDLIN( 399)		Float _hx_tmp5 = (_hx_tmp4 + ::Std_obj::_hx_int((x * ::com::stencyl::Engine_obj::SCALE)));
HXLINE( 400)		Float _hx_tmp6 = this->y;
HXDLIN( 400)		Float _hx_tmp7 = (_hx_tmp6 + ::Std_obj::_hx_int((y * ::com::stencyl::Engine_obj::SCALE)));
HXLINE( 401)		int _hx_tmp8 = ::Std_obj::_hx_int(::com::stencyl::Engine_obj::SCALE);
HXLINE( 397)		_hx_tmp3->drawRect(_hx_tmp5,_hx_tmp7,_hx_tmp8,::Std_obj::_hx_int(::com::stencyl::Engine_obj::SCALE));
HXLINE( 404)		this->graphics->endFill();
HXLINE( 406)		{
HXLINE( 406)			bool _hx_tmp9;
HXDLIN( 406)			if (this->drawActor) {
HXLINE( 406)				_hx_tmp9 = !(this->actor->isHUD);
            			}
            			else {
HXLINE( 406)				_hx_tmp9 = false;
            			}
HXDLIN( 406)			if (_hx_tmp9) {
HXLINE( 406)				 ::com::stencyl::graphics::G _hx_tmp10 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 406)				_hx_tmp10->x = (_hx_tmp10->x + ::com::stencyl::Engine_obj::cameraX);
HXDLIN( 406)				 ::com::stencyl::graphics::G _hx_tmp11 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 406)				_hx_tmp11->y = (_hx_tmp11->y + ::com::stencyl::Engine_obj::cameraY);
            			}
HXDLIN( 406)			this->graphics->lineStyle(null(),null(),null(),null(),null(),null(),null(),null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(G_obj,fillPixel,(void))

void G_obj::drawRect(Float x,Float y,Float w,Float h){
            	HX_STACKFRAME(&_hx_pos_6550bfc6d7343f4a_410_drawRect)
HXLINE( 411)		x = (x * this->scaleX);
HXLINE( 412)		y = (y * this->scaleY);
HXLINE( 413)		w = (w * this->scaleX);
HXLINE( 414)		h = (h * this->scaleY);
HXLINE( 416)		{
HXLINE( 416)			if (this->drawActor) {
HXLINE( 416)				bool _hx_tmp;
HXDLIN( 416)				if (hx::IsNotNull( this->actor )) {
HXLINE( 416)					_hx_tmp = this->actor->isHUD;
            				}
            				else {
HXLINE( 416)					_hx_tmp = false;
            				}
HXDLIN( 416)				if (!(_hx_tmp)) {
HXLINE( 416)					 ::com::stencyl::graphics::G _hx_tmp1 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 416)					_hx_tmp1->x = (_hx_tmp1->x - ::com::stencyl::Engine_obj::cameraX);
HXDLIN( 416)					 ::com::stencyl::graphics::G _hx_tmp2 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 416)					_hx_tmp2->y = (_hx_tmp2->y - ::com::stencyl::Engine_obj::cameraY);
            				}
            			}
HXDLIN( 416)			if ((this->strokeSize == (int)0)) {
HXLINE( 416)				this->graphics->lineStyle(null(),null(),null(),null(),null(),null(),null(),null());
            			}
            			else {
HXLINE( 416)				this->graphics->lineStyle(this->strokeSize,this->strokeColor,this->alpha,null(),null(),null(),null(),null());
            			}
            		}
HXLINE( 418)		 ::openfl::display::Graphics _hx_tmp3 = this->graphics;
HXDLIN( 418)		Float _hx_tmp4 = (this->x + x);
HXDLIN( 418)		_hx_tmp3->drawRect(_hx_tmp4,(this->y + y),w,h);
HXLINE( 420)		{
HXLINE( 420)			bool _hx_tmp5;
HXDLIN( 420)			if (this->drawActor) {
HXLINE( 420)				_hx_tmp5 = !(this->actor->isHUD);
            			}
            			else {
HXLINE( 420)				_hx_tmp5 = false;
            			}
HXDLIN( 420)			if (_hx_tmp5) {
HXLINE( 420)				 ::com::stencyl::graphics::G _hx_tmp6 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 420)				_hx_tmp6->x = (_hx_tmp6->x + ::com::stencyl::Engine_obj::cameraX);
HXDLIN( 420)				 ::com::stencyl::graphics::G _hx_tmp7 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 420)				_hx_tmp7->y = (_hx_tmp7->y + ::com::stencyl::Engine_obj::cameraY);
            			}
HXDLIN( 420)			this->graphics->lineStyle(null(),null(),null(),null(),null(),null(),null(),null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(G_obj,drawRect,(void))

void G_obj::fillRect(Float x,Float y,Float w,Float h){
            	HX_STACKFRAME(&_hx_pos_6550bfc6d7343f4a_424_fillRect)
HXLINE( 425)		x = (x * this->scaleX);
HXLINE( 426)		y = (y * this->scaleY);
HXLINE( 427)		w = (w * this->scaleX);
HXLINE( 428)		h = (h * this->scaleY);
HXLINE( 430)		{
HXLINE( 430)			if (this->drawActor) {
HXLINE( 430)				bool _hx_tmp;
HXDLIN( 430)				if (hx::IsNotNull( this->actor )) {
HXLINE( 430)					_hx_tmp = this->actor->isHUD;
            				}
            				else {
HXLINE( 430)					_hx_tmp = false;
            				}
HXDLIN( 430)				if (!(_hx_tmp)) {
HXLINE( 430)					 ::com::stencyl::graphics::G _hx_tmp1 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 430)					_hx_tmp1->x = (_hx_tmp1->x - ::com::stencyl::Engine_obj::cameraX);
HXDLIN( 430)					 ::com::stencyl::graphics::G _hx_tmp2 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 430)					_hx_tmp2->y = (_hx_tmp2->y - ::com::stencyl::Engine_obj::cameraY);
            				}
            			}
HXDLIN( 430)			if ((this->strokeSize == (int)0)) {
HXLINE( 430)				this->graphics->lineStyle(null(),null(),null(),null(),null(),null(),null(),null());
            			}
            			else {
HXLINE( 430)				this->graphics->lineStyle(this->strokeSize,this->strokeColor,this->alpha,null(),null(),null(),null(),null());
            			}
            		}
HXLINE( 432)		this->graphics->beginFill(this->fillColor,this->alpha);
HXLINE( 433)		 ::openfl::display::Graphics _hx_tmp3 = this->graphics;
HXDLIN( 433)		Float _hx_tmp4 = (this->x + x);
HXDLIN( 433)		_hx_tmp3->drawRect(_hx_tmp4,(this->y + y),w,h);
HXLINE( 434)		this->graphics->endFill();
HXLINE( 436)		{
HXLINE( 436)			bool _hx_tmp5;
HXDLIN( 436)			if (this->drawActor) {
HXLINE( 436)				_hx_tmp5 = !(this->actor->isHUD);
            			}
            			else {
HXLINE( 436)				_hx_tmp5 = false;
            			}
HXDLIN( 436)			if (_hx_tmp5) {
HXLINE( 436)				 ::com::stencyl::graphics::G _hx_tmp6 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 436)				_hx_tmp6->x = (_hx_tmp6->x + ::com::stencyl::Engine_obj::cameraX);
HXDLIN( 436)				 ::com::stencyl::graphics::G _hx_tmp7 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 436)				_hx_tmp7->y = (_hx_tmp7->y + ::com::stencyl::Engine_obj::cameraY);
            			}
HXDLIN( 436)			this->graphics->lineStyle(null(),null(),null(),null(),null(),null(),null(),null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(G_obj,fillRect,(void))

void G_obj::drawRoundRect(Float x,Float y,Float w,Float h,Float arc){
            	HX_STACKFRAME(&_hx_pos_6550bfc6d7343f4a_440_drawRoundRect)
HXLINE( 441)		x = (x * this->scaleX);
HXLINE( 442)		y = (y * this->scaleY);
HXLINE( 443)		w = (w * this->scaleX);
HXLINE( 444)		h = (h * this->scaleY);
HXLINE( 446)		{
HXLINE( 446)			if (this->drawActor) {
HXLINE( 446)				bool _hx_tmp;
HXDLIN( 446)				if (hx::IsNotNull( this->actor )) {
HXLINE( 446)					_hx_tmp = this->actor->isHUD;
            				}
            				else {
HXLINE( 446)					_hx_tmp = false;
            				}
HXDLIN( 446)				if (!(_hx_tmp)) {
HXLINE( 446)					 ::com::stencyl::graphics::G _hx_tmp1 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 446)					_hx_tmp1->x = (_hx_tmp1->x - ::com::stencyl::Engine_obj::cameraX);
HXDLIN( 446)					 ::com::stencyl::graphics::G _hx_tmp2 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 446)					_hx_tmp2->y = (_hx_tmp2->y - ::com::stencyl::Engine_obj::cameraY);
            				}
            			}
HXDLIN( 446)			if ((this->strokeSize == (int)0)) {
HXLINE( 446)				this->graphics->lineStyle(null(),null(),null(),null(),null(),null(),null(),null());
            			}
            			else {
HXLINE( 446)				this->graphics->lineStyle(this->strokeSize,this->strokeColor,this->alpha,null(),null(),null(),null(),null());
            			}
            		}
HXLINE( 448)		 ::openfl::display::Graphics _hx_tmp3 = this->graphics;
HXDLIN( 448)		Float _hx_tmp4 = (this->x + x);
HXDLIN( 448)		_hx_tmp3->drawRoundRect(_hx_tmp4,(this->y + y),w,h,arc,arc);
HXLINE( 450)		{
HXLINE( 450)			bool _hx_tmp5;
HXDLIN( 450)			if (this->drawActor) {
HXLINE( 450)				_hx_tmp5 = !(this->actor->isHUD);
            			}
            			else {
HXLINE( 450)				_hx_tmp5 = false;
            			}
HXDLIN( 450)			if (_hx_tmp5) {
HXLINE( 450)				 ::com::stencyl::graphics::G _hx_tmp6 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 450)				_hx_tmp6->x = (_hx_tmp6->x + ::com::stencyl::Engine_obj::cameraX);
HXDLIN( 450)				 ::com::stencyl::graphics::G _hx_tmp7 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 450)				_hx_tmp7->y = (_hx_tmp7->y + ::com::stencyl::Engine_obj::cameraY);
            			}
HXDLIN( 450)			this->graphics->lineStyle(null(),null(),null(),null(),null(),null(),null(),null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC5(G_obj,drawRoundRect,(void))

void G_obj::fillRoundRect(Float x,Float y,Float w,Float h,Float arc){
            	HX_STACKFRAME(&_hx_pos_6550bfc6d7343f4a_454_fillRoundRect)
HXLINE( 455)		x = (x * this->scaleX);
HXLINE( 456)		y = (y * this->scaleY);
HXLINE( 457)		w = (w * this->scaleX);
HXLINE( 458)		h = (h * this->scaleY);
HXLINE( 460)		{
HXLINE( 460)			if (this->drawActor) {
HXLINE( 460)				bool _hx_tmp;
HXDLIN( 460)				if (hx::IsNotNull( this->actor )) {
HXLINE( 460)					_hx_tmp = this->actor->isHUD;
            				}
            				else {
HXLINE( 460)					_hx_tmp = false;
            				}
HXDLIN( 460)				if (!(_hx_tmp)) {
HXLINE( 460)					 ::com::stencyl::graphics::G _hx_tmp1 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 460)					_hx_tmp1->x = (_hx_tmp1->x - ::com::stencyl::Engine_obj::cameraX);
HXDLIN( 460)					 ::com::stencyl::graphics::G _hx_tmp2 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 460)					_hx_tmp2->y = (_hx_tmp2->y - ::com::stencyl::Engine_obj::cameraY);
            				}
            			}
HXDLIN( 460)			if ((this->strokeSize == (int)0)) {
HXLINE( 460)				this->graphics->lineStyle(null(),null(),null(),null(),null(),null(),null(),null());
            			}
            			else {
HXLINE( 460)				this->graphics->lineStyle(this->strokeSize,this->strokeColor,this->alpha,null(),null(),null(),null(),null());
            			}
            		}
HXLINE( 462)		this->graphics->beginFill(this->fillColor,this->alpha);
HXLINE( 463)		 ::openfl::display::Graphics _hx_tmp3 = this->graphics;
HXDLIN( 463)		Float _hx_tmp4 = (this->x + x);
HXDLIN( 463)		_hx_tmp3->drawRoundRect(_hx_tmp4,(this->y + y),w,h,arc,arc);
HXLINE( 464)		this->graphics->endFill();
HXLINE( 466)		{
HXLINE( 466)			bool _hx_tmp5;
HXDLIN( 466)			if (this->drawActor) {
HXLINE( 466)				_hx_tmp5 = !(this->actor->isHUD);
            			}
            			else {
HXLINE( 466)				_hx_tmp5 = false;
            			}
HXDLIN( 466)			if (_hx_tmp5) {
HXLINE( 466)				 ::com::stencyl::graphics::G _hx_tmp6 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 466)				_hx_tmp6->x = (_hx_tmp6->x + ::com::stencyl::Engine_obj::cameraX);
HXDLIN( 466)				 ::com::stencyl::graphics::G _hx_tmp7 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 466)				_hx_tmp7->y = (_hx_tmp7->y + ::com::stencyl::Engine_obj::cameraY);
            			}
HXDLIN( 466)			this->graphics->lineStyle(null(),null(),null(),null(),null(),null(),null(),null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC5(G_obj,fillRoundRect,(void))

void G_obj::drawCircle(Float x,Float y,Float r){
            	HX_STACKFRAME(&_hx_pos_6550bfc6d7343f4a_470_drawCircle)
HXLINE( 471)		x = (x * this->scaleX);
HXLINE( 472)		y = (y * this->scaleY);
HXLINE( 473)		r = (r * this->scaleX);
HXLINE( 475)		{
HXLINE( 475)			if (this->drawActor) {
HXLINE( 475)				bool _hx_tmp;
HXDLIN( 475)				if (hx::IsNotNull( this->actor )) {
HXLINE( 475)					_hx_tmp = this->actor->isHUD;
            				}
            				else {
HXLINE( 475)					_hx_tmp = false;
            				}
HXDLIN( 475)				if (!(_hx_tmp)) {
HXLINE( 475)					 ::com::stencyl::graphics::G _hx_tmp1 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 475)					_hx_tmp1->x = (_hx_tmp1->x - ::com::stencyl::Engine_obj::cameraX);
HXDLIN( 475)					 ::com::stencyl::graphics::G _hx_tmp2 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 475)					_hx_tmp2->y = (_hx_tmp2->y - ::com::stencyl::Engine_obj::cameraY);
            				}
            			}
HXDLIN( 475)			if ((this->strokeSize == (int)0)) {
HXLINE( 475)				this->graphics->lineStyle(null(),null(),null(),null(),null(),null(),null(),null());
            			}
            			else {
HXLINE( 475)				this->graphics->lineStyle(this->strokeSize,this->strokeColor,this->alpha,null(),null(),null(),null(),null());
            			}
            		}
HXLINE( 477)		 ::openfl::display::Graphics _hx_tmp3 = this->graphics;
HXDLIN( 477)		Float _hx_tmp4 = (this->x + x);
HXDLIN( 477)		_hx_tmp3->drawCircle(_hx_tmp4,(this->y + y),r);
HXLINE( 479)		{
HXLINE( 479)			bool _hx_tmp5;
HXDLIN( 479)			if (this->drawActor) {
HXLINE( 479)				_hx_tmp5 = !(this->actor->isHUD);
            			}
            			else {
HXLINE( 479)				_hx_tmp5 = false;
            			}
HXDLIN( 479)			if (_hx_tmp5) {
HXLINE( 479)				 ::com::stencyl::graphics::G _hx_tmp6 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 479)				_hx_tmp6->x = (_hx_tmp6->x + ::com::stencyl::Engine_obj::cameraX);
HXDLIN( 479)				 ::com::stencyl::graphics::G _hx_tmp7 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 479)				_hx_tmp7->y = (_hx_tmp7->y + ::com::stencyl::Engine_obj::cameraY);
            			}
HXDLIN( 479)			this->graphics->lineStyle(null(),null(),null(),null(),null(),null(),null(),null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(G_obj,drawCircle,(void))

void G_obj::fillCircle(Float x,Float y,Float r){
            	HX_STACKFRAME(&_hx_pos_6550bfc6d7343f4a_483_fillCircle)
HXLINE( 484)		x = (x * this->scaleX);
HXLINE( 485)		y = (y * this->scaleY);
HXLINE( 486)		r = (r * this->scaleX);
HXLINE( 488)		{
HXLINE( 488)			if (this->drawActor) {
HXLINE( 488)				bool _hx_tmp;
HXDLIN( 488)				if (hx::IsNotNull( this->actor )) {
HXLINE( 488)					_hx_tmp = this->actor->isHUD;
            				}
            				else {
HXLINE( 488)					_hx_tmp = false;
            				}
HXDLIN( 488)				if (!(_hx_tmp)) {
HXLINE( 488)					 ::com::stencyl::graphics::G _hx_tmp1 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 488)					_hx_tmp1->x = (_hx_tmp1->x - ::com::stencyl::Engine_obj::cameraX);
HXDLIN( 488)					 ::com::stencyl::graphics::G _hx_tmp2 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 488)					_hx_tmp2->y = (_hx_tmp2->y - ::com::stencyl::Engine_obj::cameraY);
            				}
            			}
HXDLIN( 488)			if ((this->strokeSize == (int)0)) {
HXLINE( 488)				this->graphics->lineStyle(null(),null(),null(),null(),null(),null(),null(),null());
            			}
            			else {
HXLINE( 488)				this->graphics->lineStyle(this->strokeSize,this->strokeColor,this->alpha,null(),null(),null(),null(),null());
            			}
            		}
HXLINE( 490)		this->graphics->beginFill(this->fillColor,this->alpha);
HXLINE( 491)		 ::openfl::display::Graphics _hx_tmp3 = this->graphics;
HXDLIN( 491)		Float _hx_tmp4 = (this->x + x);
HXDLIN( 491)		_hx_tmp3->drawCircle(_hx_tmp4,(this->y + y),r);
HXLINE( 492)		this->graphics->endFill();
HXLINE( 494)		{
HXLINE( 494)			bool _hx_tmp5;
HXDLIN( 494)			if (this->drawActor) {
HXLINE( 494)				_hx_tmp5 = !(this->actor->isHUD);
            			}
            			else {
HXLINE( 494)				_hx_tmp5 = false;
            			}
HXDLIN( 494)			if (_hx_tmp5) {
HXLINE( 494)				 ::com::stencyl::graphics::G _hx_tmp6 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 494)				_hx_tmp6->x = (_hx_tmp6->x + ::com::stencyl::Engine_obj::cameraX);
HXDLIN( 494)				 ::com::stencyl::graphics::G _hx_tmp7 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 494)				_hx_tmp7->y = (_hx_tmp7->y + ::com::stencyl::Engine_obj::cameraY);
            			}
HXDLIN( 494)			this->graphics->lineStyle(null(),null(),null(),null(),null(),null(),null(),null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(G_obj,fillCircle,(void))

void G_obj::beginFillPolygon(){
            	HX_STACKFRAME(&_hx_pos_6550bfc6d7343f4a_498_beginFillPolygon)
HXLINE( 499)		this->drawPoly = false;
HXLINE( 501)		{
HXLINE( 501)			if (this->drawActor) {
HXLINE( 501)				bool _hx_tmp;
HXDLIN( 501)				if (hx::IsNotNull( this->actor )) {
HXLINE( 501)					_hx_tmp = this->actor->isHUD;
            				}
            				else {
HXLINE( 501)					_hx_tmp = false;
            				}
HXDLIN( 501)				if (!(_hx_tmp)) {
HXLINE( 501)					 ::com::stencyl::graphics::G _hx_tmp1 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 501)					_hx_tmp1->x = (_hx_tmp1->x - ::com::stencyl::Engine_obj::cameraX);
HXDLIN( 501)					 ::com::stencyl::graphics::G _hx_tmp2 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 501)					_hx_tmp2->y = (_hx_tmp2->y - ::com::stencyl::Engine_obj::cameraY);
            				}
            			}
HXDLIN( 501)			if ((this->strokeSize == (int)0)) {
HXLINE( 501)				this->graphics->lineStyle(null(),null(),null(),null(),null(),null(),null(),null());
            			}
            			else {
HXLINE( 501)				this->graphics->lineStyle(this->strokeSize,this->strokeColor,this->alpha,null(),null(),null(),null(),null());
            			}
            		}
HXLINE( 502)		this->graphics->moveTo(this->x,this->y);
HXLINE( 503)		this->pointCounter = (int)0;
            	}


HX_DEFINE_DYNAMIC_FUNC0(G_obj,beginFillPolygon,(void))

void G_obj::endDrawingPolygon(){
            	HX_STACKFRAME(&_hx_pos_6550bfc6d7343f4a_508_endDrawingPolygon)
HXDLIN( 508)		if ((this->pointCounter >= (int)2)) {
HXLINE( 510)			if (this->drawPoly) {
HXLINE( 512)				 ::openfl::display::Graphics _hx_tmp = this->graphics;
HXDLIN( 512)				Float _hx_tmp1 = (this->x + this->firstX);
HXDLIN( 512)				_hx_tmp->lineTo(_hx_tmp1,(this->y + this->firstY));
            			}
            			else {
HXLINE( 517)				 ::openfl::display::Graphics _hx_tmp2 = this->graphics;
HXDLIN( 517)				Float _hx_tmp3 = (this->x + this->firstX);
HXDLIN( 517)				_hx_tmp2->lineTo(_hx_tmp3,(this->y + this->firstY));
HXLINE( 518)				this->graphics->endFill();
            			}
HXLINE( 521)			{
HXLINE( 521)				bool _hx_tmp4;
HXDLIN( 521)				if (this->drawActor) {
HXLINE( 521)					_hx_tmp4 = !(this->actor->isHUD);
            				}
            				else {
HXLINE( 521)					_hx_tmp4 = false;
            				}
HXDLIN( 521)				if (_hx_tmp4) {
HXLINE( 521)					 ::com::stencyl::graphics::G _hx_tmp5 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 521)					_hx_tmp5->x = (_hx_tmp5->x + ::com::stencyl::Engine_obj::cameraX);
HXDLIN( 521)					 ::com::stencyl::graphics::G _hx_tmp6 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 521)					_hx_tmp6->y = (_hx_tmp6->y + ::com::stencyl::Engine_obj::cameraY);
            				}
HXDLIN( 521)				this->graphics->lineStyle(null(),null(),null(),null(),null(),null(),null(),null());
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(G_obj,endDrawingPolygon,(void))

void G_obj::beginDrawPolygon(){
            	HX_STACKFRAME(&_hx_pos_6550bfc6d7343f4a_526_beginDrawPolygon)
HXLINE( 527)		this->drawPoly = true;
HXLINE( 529)		{
HXLINE( 529)			if (this->drawActor) {
HXLINE( 529)				bool _hx_tmp;
HXDLIN( 529)				if (hx::IsNotNull( this->actor )) {
HXLINE( 529)					_hx_tmp = this->actor->isHUD;
            				}
            				else {
HXLINE( 529)					_hx_tmp = false;
            				}
HXDLIN( 529)				if (!(_hx_tmp)) {
HXLINE( 529)					 ::com::stencyl::graphics::G _hx_tmp1 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 529)					_hx_tmp1->x = (_hx_tmp1->x - ::com::stencyl::Engine_obj::cameraX);
HXDLIN( 529)					 ::com::stencyl::graphics::G _hx_tmp2 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 529)					_hx_tmp2->y = (_hx_tmp2->y - ::com::stencyl::Engine_obj::cameraY);
            				}
            			}
HXDLIN( 529)			if ((this->strokeSize == (int)0)) {
HXLINE( 529)				this->graphics->lineStyle(null(),null(),null(),null(),null(),null(),null(),null());
            			}
            			else {
HXLINE( 529)				this->graphics->lineStyle(this->strokeSize,this->strokeColor,this->alpha,null(),null(),null(),null(),null());
            			}
            		}
HXLINE( 530)		this->graphics->moveTo(this->x,this->y);
HXLINE( 531)		this->pointCounter = (int)0;
            	}


HX_DEFINE_DYNAMIC_FUNC0(G_obj,beginDrawPolygon,(void))

void G_obj::addPointToPolygon(Float x,Float y){
            	HX_STACKFRAME(&_hx_pos_6550bfc6d7343f4a_535_addPointToPolygon)
HXLINE( 536)		x = (x * this->scaleX);
HXLINE( 537)		y = (y * this->scaleY);
HXLINE( 539)		if ((this->pointCounter == (int)0)) {
HXLINE( 541)			this->firstX = x;
HXLINE( 542)			this->firstY = y;
HXLINE( 544)			 ::openfl::display::Graphics _hx_tmp = this->graphics;
HXDLIN( 544)			Float _hx_tmp1 = (this->x + x);
HXDLIN( 544)			_hx_tmp->moveTo(_hx_tmp1,(this->y + y));
HXLINE( 546)			if (!(this->drawPoly)) {
HXLINE( 548)				this->graphics->beginFill(this->fillColor,this->alpha);
            			}
            		}
HXLINE( 552)		this->pointCounter++;
HXLINE( 554)		 ::openfl::display::Graphics _hx_tmp2 = this->graphics;
HXDLIN( 554)		Float _hx_tmp3 = (this->x + x);
HXDLIN( 554)		_hx_tmp2->lineTo(_hx_tmp3,(this->y + y));
            	}


HX_DEFINE_DYNAMIC_FUNC2(G_obj,addPointToPolygon,(void))

void G_obj::drawImage( ::openfl::display::BitmapData img,Float x,Float y,hx::Null< Float >  __o_angle, ::openfl::geom::Matrix matrix){
Float angle = __o_angle.Default(0);
            	HX_GC_STACKFRAME(&_hx_pos_6550bfc6d7343f4a_558_drawImage)
HXLINE( 559)		x = (x * this->scaleX);
HXLINE( 560)		y = (y * this->scaleY);
HXLINE( 562)		this->rect->x = (int)0;
HXLINE( 563)		this->rect->y = (int)0;
HXLINE( 564)		this->rect->width = img->width;
HXLINE( 565)		this->rect->height = img->height;
HXLINE( 568)		if (this->drawActor) {
HXLINE( 570)			bool _hx_tmp;
HXDLIN( 570)			if (hx::IsNotNull( this->actor )) {
HXLINE( 570)				_hx_tmp = this->actor->isHUD;
            			}
            			else {
HXLINE( 570)				_hx_tmp = false;
            			}
HXDLIN( 570)			if (_hx_tmp) {
HXLINE( 572)				this->point->x = (this->x + x);
HXLINE( 573)				this->point->y = (this->y + y);
            			}
            			else {
HXLINE( 578)				this->point->x = ((this->x + x) - ::com::stencyl::Engine_obj::cameraX);
HXLINE( 579)				this->point->y = ((this->y + y) - ::com::stencyl::Engine_obj::cameraY);
            			}
            		}
            		else {
HXLINE( 585)			this->point->x = (this->x + x);
HXLINE( 586)			this->point->y = (this->y + y);
            		}
HXLINE( 589)		 ::openfl::display::BitmapData newImg = null();
HXLINE( 590)		int imgSize = (int)0;
HXLINE( 591)		this->mtx->identity();
HXLINE( 592)		this->mtx->rotate(angle);
HXLINE( 593)		this->mtx->translate(this->point->x,this->point->y);
HXLINE( 595)		if ((angle == (int)0)) {
HXLINE( 597)			if ((this->alpha == (int)1)) {
HXLINE( 599)				this->graphics->beginBitmapFill(img,this->mtx,null(),null());
            			}
            			else {
HXLINE( 603)				this->point2->x = (int)0;
HXLINE( 604)				this->point2->y = (int)0;
HXLINE( 605)				this->rect2->width = img->width;
HXLINE( 606)				this->rect2->height = img->height;
HXLINE( 609)				int img1 = img->width;
HXDLIN( 609)				int img2 = img->height;
HXDLIN( 609)				 ::openfl::display::BitmapData temp =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,img1,img2,true,this->toARGB((int)0,::Std_obj::_hx_int((this->alpha * (int)255))));
HXLINE( 610)				 ::openfl::display::BitmapData temp2 =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,img->width,img->height,true,(int)0);
HXLINE( 612)				temp2->copyPixels(img,this->rect2,this->point2,temp,null(),true);
HXLINE( 613)				img = temp2;
HXLINE( 615)				this->graphics->beginBitmapFill(img,this->mtx,null(),null());
            			}
HXLINE( 618)			this->graphics->drawRect(this->point->x,this->point->y,img->width,img->height);
            		}
            		else {
HXLINE( 622)			if ((this->alpha != (int)1)) {
HXLINE( 624)				this->point2->x = (int)0;
HXLINE( 625)				this->point2->y = (int)0;
HXLINE( 626)				this->rect2->width = img->width;
HXLINE( 627)				this->rect2->height = img->height;
HXLINE( 630)				int img3 = img->width;
HXDLIN( 630)				int img4 = img->height;
HXDLIN( 630)				 ::openfl::display::BitmapData temp1 =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,img3,img4,true,this->toARGB((int)0,::Std_obj::_hx_int((this->alpha * (int)255))));
HXLINE( 631)				 ::openfl::display::BitmapData temp21 =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,img->width,img->height,true,(int)0);
HXLINE( 633)				temp21->copyPixels(img,this->rect2,this->point2,temp1,null(),true);
HXLINE( 634)				img = temp21;
            			}
HXLINE( 637)			int newImg1 = (img->width + (int)2);
HXDLIN( 637)			newImg =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,newImg1,(img->height + (int)2),true,(int)0);
HXLINE( 638)			Float imgSize1 = ::Math_obj::pow(newImg->width,(int)2);
HXDLIN( 638)			imgSize = ::Std_obj::_hx_int(::Math_obj::sqrt((imgSize1 + ::Math_obj::pow(newImg->height,(int)2))));
HXLINE( 639)			 ::openfl::geom::Rectangle srcRect =  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,(int)0,(int)0,img->width,img->height);
HXLINE( 640)			 ::openfl::geom::Point destPt =  ::openfl::geom::Point_obj::__alloc( HX_CTX ,(int)1,(int)1);
HXLINE( 641)			newImg->copyPixels(img,srcRect,destPt,null(),null(),null());
HXLINE( 643)			this->graphics->beginBitmapFill(newImg,this->mtx,false,::com::stencyl::Config_obj::antialias);
HXLINE( 644)			Float rectX = ((Float)(imgSize - img->width) / (Float)(int)2);
HXLINE( 645)			Float rectY = ((Float)(imgSize - img->height) / (Float)(int)2);
HXLINE( 646)			 ::openfl::display::Graphics _hx_tmp1 = this->graphics;
HXDLIN( 646)			Float _hx_tmp2 = (this->x - rectX);
HXDLIN( 646)			_hx_tmp1->drawRect(_hx_tmp2,(this->y - rectY),imgSize,imgSize);
            		}
HXLINE( 649)		this->graphics->endFill();
            	}


HX_DEFINE_DYNAMIC_FUNC5(G_obj,drawImage,(void))

int G_obj::toARGB(int rgb,int newAlpha){
            	HX_STACKFRAME(&_hx_pos_6550bfc6d7343f4a_653_toARGB)
HXLINE( 654)		int argb = (int)0;
HXLINE( 655)		argb = rgb;
HXLINE( 656)		argb = (argb + ((int)newAlpha << (int)(int)24));
HXLINE( 658)		return argb;
            	}


HX_DEFINE_DYNAMIC_FUNC2(G_obj,toARGB,return )

void G_obj::resetFont(){
            	HX_STACKFRAME(&_hx_pos_6550bfc6d7343f4a_662_resetFont)
HXLINE( 663)		this->font = this->defaultFont;
HXLINE( 665)		if ((this->font->fontScale != ::com::stencyl::Engine_obj::SCALE)) {
HXLINE( 667)			this->font->fontScale = ::com::stencyl::Engine_obj::SCALE;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(G_obj,resetFont,(void))

 ::haxe::ds::IntMap G_obj::fontCache;

void G_obj::resetStatics(){
            	HX_STACKFRAME(&_hx_pos_6550bfc6d7343f4a_66_resetStatics)
HXDLIN(  66)		::com::stencyl::graphics::G_obj::fontCache = null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(G_obj,resetStatics,(void))

 ::haxe::ds::StringMap G_obj::drawnStringCache;

::Array< ::String > G_obj::drawnStringCacheKeys;

void G_obj::visitStringCache(){
            	HX_STACKFRAME(&_hx_pos_6550bfc6d7343f4a_358_visitStringCache)
HXLINE( 359)		int i = ::com::stencyl::graphics::G_obj::drawnStringCacheKeys->length;
HXLINE( 361)		while(true){
HXLINE( 361)			i = (i - (int)1);
HXDLIN( 361)			if (!(((i + (int)1) > (int)0))) {
HXLINE( 361)				goto _hx_goto_28;
            			}
HXLINE( 363)			 ::com::stencyl::graphics::_G::TemporaryImage temp = ::com::stencyl::graphics::G_obj::drawnStringCache->get(::com::stencyl::graphics::G_obj::drawnStringCacheKeys->__get(i)).StaticCast<  ::com::stencyl::graphics::_G::TemporaryImage >();
HXLINE( 364)			--temp->lifetime;
HXLINE( 365)			if ((temp->lifetime == (int)0)) {
HXLINE( 367)				temp->img->dispose();
HXLINE( 368)				::com::stencyl::graphics::G_obj::drawnStringCache->remove(::com::stencyl::graphics::G_obj::drawnStringCacheKeys->__get(i));
HXLINE( 369)				::Array< ::String > _hx_tmp = ::com::stencyl::graphics::G_obj::drawnStringCacheKeys;
HXDLIN( 369)				::Array< ::String > _hx_tmp1 = ::com::stencyl::graphics::G_obj::drawnStringCacheKeys;
HXDLIN( 369)				_hx_tmp[i] = _hx_tmp1->__get((::com::stencyl::graphics::G_obj::drawnStringCacheKeys->length - (int)1));
HXLINE( 370)				::com::stencyl::graphics::G_obj::drawnStringCacheKeys->pop();
            			}
            		}
            		_hx_goto_28:;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(G_obj,visitStringCache,(void))


hx::ObjectPtr< G_obj > G_obj::__new() {
	hx::ObjectPtr< G_obj > __this = new G_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< G_obj > G_obj::__alloc(hx::Ctx *_hx_ctx) {
	G_obj *__this = (G_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(G_obj), true, "com.stencyl.graphics.G"));
	*(void **)__this = G_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

G_obj::G_obj()
{
}

void G_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(G);
	HX_MARK_MEMBER_NAME(defaultFont,"defaultFont");
	HX_MARK_MEMBER_NAME(graphics,"graphics");
	HX_MARK_MEMBER_NAME(x,"x");
	HX_MARK_MEMBER_NAME(y,"y");
	HX_MARK_MEMBER_NAME(scaleX,"scaleX");
	HX_MARK_MEMBER_NAME(scaleY,"scaleY");
	HX_MARK_MEMBER_NAME(alpha,"alpha");
	HX_MARK_MEMBER_NAME(blendMode,"blendMode");
	HX_MARK_MEMBER_NAME(strokeSize,"strokeSize");
	HX_MARK_MEMBER_NAME(fillColor,"fillColor");
	HX_MARK_MEMBER_NAME(strokeColor,"strokeColor");
	HX_MARK_MEMBER_NAME(font,"font");
	HX_MARK_MEMBER_NAME(fontData,"fontData");
	HX_MARK_MEMBER_NAME(mtx,"mtx");
	HX_MARK_MEMBER_NAME(rect,"rect");
	HX_MARK_MEMBER_NAME(rect2,"rect2");
	HX_MARK_MEMBER_NAME(point,"point");
	HX_MARK_MEMBER_NAME(point2,"point2");
	HX_MARK_MEMBER_NAME(data,"data");
	HX_MARK_MEMBER_NAME(drawPoly,"drawPoly");
	HX_MARK_MEMBER_NAME(pointCounter,"pointCounter");
	HX_MARK_MEMBER_NAME(firstX,"firstX");
	HX_MARK_MEMBER_NAME(firstY,"firstY");
	HX_MARK_MEMBER_NAME(drawActor,"drawActor");
	HX_MARK_MEMBER_NAME(actor,"actor");
	HX_MARK_END_CLASS();
}

void G_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(defaultFont,"defaultFont");
	HX_VISIT_MEMBER_NAME(graphics,"graphics");
	HX_VISIT_MEMBER_NAME(x,"x");
	HX_VISIT_MEMBER_NAME(y,"y");
	HX_VISIT_MEMBER_NAME(scaleX,"scaleX");
	HX_VISIT_MEMBER_NAME(scaleY,"scaleY");
	HX_VISIT_MEMBER_NAME(alpha,"alpha");
	HX_VISIT_MEMBER_NAME(blendMode,"blendMode");
	HX_VISIT_MEMBER_NAME(strokeSize,"strokeSize");
	HX_VISIT_MEMBER_NAME(fillColor,"fillColor");
	HX_VISIT_MEMBER_NAME(strokeColor,"strokeColor");
	HX_VISIT_MEMBER_NAME(font,"font");
	HX_VISIT_MEMBER_NAME(fontData,"fontData");
	HX_VISIT_MEMBER_NAME(mtx,"mtx");
	HX_VISIT_MEMBER_NAME(rect,"rect");
	HX_VISIT_MEMBER_NAME(rect2,"rect2");
	HX_VISIT_MEMBER_NAME(point,"point");
	HX_VISIT_MEMBER_NAME(point2,"point2");
	HX_VISIT_MEMBER_NAME(data,"data");
	HX_VISIT_MEMBER_NAME(drawPoly,"drawPoly");
	HX_VISIT_MEMBER_NAME(pointCounter,"pointCounter");
	HX_VISIT_MEMBER_NAME(firstX,"firstX");
	HX_VISIT_MEMBER_NAME(firstY,"firstY");
	HX_VISIT_MEMBER_NAME(drawActor,"drawActor");
	HX_VISIT_MEMBER_NAME(actor,"actor");
}

hx::Val G_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"x") ) { return hx::Val( x ); }
		if (HX_FIELD_EQ(inName,"y") ) { return hx::Val( y ); }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"mtx") ) { return hx::Val( mtx ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"font") ) { return hx::Val( font ); }
		if (HX_FIELD_EQ(inName,"rect") ) { return hx::Val( rect ); }
		if (HX_FIELD_EQ(inName,"data") ) { return hx::Val( data ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"alpha") ) { return hx::Val( alpha ); }
		if (HX_FIELD_EQ(inName,"rect2") ) { return hx::Val( rect2 ); }
		if (HX_FIELD_EQ(inName,"point") ) { return hx::Val( point ); }
		if (HX_FIELD_EQ(inName,"actor") ) { return hx::Val( actor ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"scaleX") ) { return hx::Val( scaleX ); }
		if (HX_FIELD_EQ(inName,"scaleY") ) { return hx::Val( scaleY ); }
		if (HX_FIELD_EQ(inName,"point2") ) { return hx::Val( point2 ); }
		if (HX_FIELD_EQ(inName,"firstX") ) { return hx::Val( firstX ); }
		if (HX_FIELD_EQ(inName,"firstY") ) { return hx::Val( firstY ); }
		if (HX_FIELD_EQ(inName,"moveTo") ) { return hx::Val( moveTo_dyn() ); }
		if (HX_FIELD_EQ(inName,"toARGB") ) { return hx::Val( toARGB_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"setFont") ) { return hx::Val( setFont_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"graphics") ) { return hx::Val( graphics ); }
		if (HX_FIELD_EQ(inName,"fontData") ) { return hx::Val( fontData ); }
		if (HX_FIELD_EQ(inName,"drawPoly") ) { return hx::Val( drawPoly ); }
		if (HX_FIELD_EQ(inName,"drawLine") ) { return hx::Val( drawLine_dyn() ); }
		if (HX_FIELD_EQ(inName,"drawRect") ) { return hx::Val( drawRect_dyn() ); }
		if (HX_FIELD_EQ(inName,"fillRect") ) { return hx::Val( fillRect_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"blendMode") ) { return hx::Val( blendMode ); }
		if (HX_FIELD_EQ(inName,"fillColor") ) { return hx::Val( fillColor ); }
		if (HX_FIELD_EQ(inName,"drawActor") ) { return hx::Val( drawActor ); }
		if (HX_FIELD_EQ(inName,"translate") ) { return hx::Val( translate_dyn() ); }
		if (HX_FIELD_EQ(inName,"fillPixel") ) { return hx::Val( fillPixel_dyn() ); }
		if (HX_FIELD_EQ(inName,"drawImage") ) { return hx::Val( drawImage_dyn() ); }
		if (HX_FIELD_EQ(inName,"resetFont") ) { return hx::Val( resetFont_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"strokeSize") ) { return hx::Val( strokeSize ); }
		if (HX_FIELD_EQ(inName,"drawString") ) { return hx::Val( drawString_dyn() ); }
		if (HX_FIELD_EQ(inName,"drawCircle") ) { return hx::Val( drawCircle_dyn() ); }
		if (HX_FIELD_EQ(inName,"fillCircle") ) { return hx::Val( fillCircle_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"defaultFont") ) { return hx::Val( defaultFont ); }
		if (HX_FIELD_EQ(inName,"strokeColor") ) { return hx::Val( strokeColor ); }
		if (HX_FIELD_EQ(inName,"endGraphics") ) { return hx::Val( endGraphics_dyn() ); }
		if (HX_FIELD_EQ(inName,"getCacheKey") ) { return hx::Val( getCacheKey_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"pointCounter") ) { return hx::Val( pointCounter ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"startGraphics") ) { return hx::Val( startGraphics_dyn() ); }
		if (HX_FIELD_EQ(inName,"drawRoundRect") ) { return hx::Val( drawRoundRect_dyn() ); }
		if (HX_FIELD_EQ(inName,"fillRoundRect") ) { return hx::Val( fillRoundRect_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"translateToActor") ) { return hx::Val( translateToActor_dyn() ); }
		if (HX_FIELD_EQ(inName,"beginFillPolygon") ) { return hx::Val( beginFillPolygon_dyn() ); }
		if (HX_FIELD_EQ(inName,"beginDrawPolygon") ) { return hx::Val( beginDrawPolygon_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"translateToScreen") ) { return hx::Val( translateToScreen_dyn() ); }
		if (HX_FIELD_EQ(inName,"endDrawingPolygon") ) { return hx::Val( endDrawingPolygon_dyn() ); }
		if (HX_FIELD_EQ(inName,"addPointToPolygon") ) { return hx::Val( addPointToPolygon_dyn() ); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"resetGraphicsSettings") ) { return hx::Val( resetGraphicsSettings_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool G_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 9:
		if (HX_FIELD_EQ(inName,"fontCache") ) { outValue = ( fontCache ); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"resetStatics") ) { outValue = resetStatics_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"drawnStringCache") ) { outValue = ( drawnStringCache ); return true; }
		if (HX_FIELD_EQ(inName,"visitStringCache") ) { outValue = visitStringCache_dyn(); return true; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"drawnStringCacheKeys") ) { outValue = ( drawnStringCacheKeys ); return true; }
	}
	return false;
}

hx::Val G_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"x") ) { x=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y") ) { y=inValue.Cast< Float >(); return inValue; }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"mtx") ) { mtx=inValue.Cast<  ::openfl::geom::Matrix >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"font") ) { font=inValue.Cast<  ::com::stencyl::models::Font >(); return inValue; }
		if (HX_FIELD_EQ(inName,"rect") ) { rect=inValue.Cast<  ::openfl::geom::Rectangle >(); return inValue; }
		if (HX_FIELD_EQ(inName,"data") ) { data=inValue.Cast< ::Array< Float > >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"alpha") ) { alpha=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"rect2") ) { rect2=inValue.Cast<  ::openfl::geom::Rectangle >(); return inValue; }
		if (HX_FIELD_EQ(inName,"point") ) { point=inValue.Cast<  ::openfl::geom::Point >(); return inValue; }
		if (HX_FIELD_EQ(inName,"actor") ) { actor=inValue.Cast<  ::com::stencyl::models::Actor >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"scaleX") ) { scaleX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"scaleY") ) { scaleY=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"point2") ) { point2=inValue.Cast<  ::openfl::geom::Point >(); return inValue; }
		if (HX_FIELD_EQ(inName,"firstX") ) { firstX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"firstY") ) { firstY=inValue.Cast< Float >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"graphics") ) { graphics=inValue.Cast<  ::openfl::display::Graphics >(); return inValue; }
		if (HX_FIELD_EQ(inName,"fontData") ) { fontData=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"drawPoly") ) { drawPoly=inValue.Cast< bool >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"blendMode") ) { blendMode=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"fillColor") ) { fillColor=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"drawActor") ) { drawActor=inValue.Cast< bool >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"strokeSize") ) { strokeSize=inValue.Cast< int >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"defaultFont") ) { defaultFont=inValue.Cast<  ::com::stencyl::models::Font >(); return inValue; }
		if (HX_FIELD_EQ(inName,"strokeColor") ) { strokeColor=inValue.Cast< int >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"pointCounter") ) { pointCounter=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool G_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 9:
		if (HX_FIELD_EQ(inName,"fontCache") ) { fontCache=ioValue.Cast<  ::haxe::ds::IntMap >(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"drawnStringCache") ) { drawnStringCache=ioValue.Cast<  ::haxe::ds::StringMap >(); return true; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"drawnStringCacheKeys") ) { drawnStringCacheKeys=ioValue.Cast< ::Array< ::String > >(); return true; }
	}
	return false;
}

void G_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("defaultFont","\x30","\x57","\x7f","\x15"));
	outFields->push(HX_HCSTRING("graphics","\xcb","\xf8","\x67","\x12"));
	outFields->push(HX_HCSTRING("x","\x78","\x00","\x00","\x00"));
	outFields->push(HX_HCSTRING("y","\x79","\x00","\x00","\x00"));
	outFields->push(HX_HCSTRING("scaleX","\x8e","\xea","\x25","\x3c"));
	outFields->push(HX_HCSTRING("scaleY","\x8f","\xea","\x25","\x3c"));
	outFields->push(HX_HCSTRING("alpha","\x5e","\xa7","\x96","\x21"));
	outFields->push(HX_HCSTRING("blendMode","\x54","\xe4","\x37","\x0c"));
	outFields->push(HX_HCSTRING("strokeSize","\x99","\xbc","\xf1","\x9d"));
	outFields->push(HX_HCSTRING("fillColor","\xe0","\x97","\x03","\x19"));
	outFields->push(HX_HCSTRING("strokeColor","\x8b","\xb2","\x16","\x63"));
	outFields->push(HX_HCSTRING("font","\xcf","\x5d","\xc0","\x43"));
	outFields->push(HX_HCSTRING("fontData","\x99","\x73","\xe1","\xc4"));
	outFields->push(HX_HCSTRING("mtx","\x31","\x1b","\x53","\x00"));
	outFields->push(HX_HCSTRING("rect","\x24","\x4d","\xa7","\x4b"));
	outFields->push(HX_HCSTRING("rect2","\x8e","\x32","\xbc","\xe6"));
	outFields->push(HX_HCSTRING("point","\x50","\xb4","\x8f","\xc6"));
	outFields->push(HX_HCSTRING("point2","\xe2","\x11","\x2e","\xf7"));
	outFields->push(HX_HCSTRING("data","\x2a","\x56","\x63","\x42"));
	outFields->push(HX_HCSTRING("drawPoly","\x70","\x28","\xc6","\x5e"));
	outFields->push(HX_HCSTRING("pointCounter","\x8c","\x4c","\xfd","\xfb"));
	outFields->push(HX_HCSTRING("firstX","\x28","\xb2","\x2b","\x89"));
	outFields->push(HX_HCSTRING("firstY","\x29","\xb2","\x2b","\x89"));
	outFields->push(HX_HCSTRING("drawActor","\x51","\x00","\xb2","\xe3"));
	outFields->push(HX_HCSTRING("actor","\xf5","\xca","\xa6","\x1b"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo G_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::com::stencyl::models::Font*/ ,(int)offsetof(G_obj,defaultFont),HX_HCSTRING("defaultFont","\x30","\x57","\x7f","\x15")},
	{hx::fsObject /*::openfl::display::Graphics*/ ,(int)offsetof(G_obj,graphics),HX_HCSTRING("graphics","\xcb","\xf8","\x67","\x12")},
	{hx::fsFloat,(int)offsetof(G_obj,x),HX_HCSTRING("x","\x78","\x00","\x00","\x00")},
	{hx::fsFloat,(int)offsetof(G_obj,y),HX_HCSTRING("y","\x79","\x00","\x00","\x00")},
	{hx::fsFloat,(int)offsetof(G_obj,scaleX),HX_HCSTRING("scaleX","\x8e","\xea","\x25","\x3c")},
	{hx::fsFloat,(int)offsetof(G_obj,scaleY),HX_HCSTRING("scaleY","\x8f","\xea","\x25","\x3c")},
	{hx::fsFloat,(int)offsetof(G_obj,alpha),HX_HCSTRING("alpha","\x5e","\xa7","\x96","\x21")},
	{hx::fsObject /*Dynamic*/ ,(int)offsetof(G_obj,blendMode),HX_HCSTRING("blendMode","\x54","\xe4","\x37","\x0c")},
	{hx::fsInt,(int)offsetof(G_obj,strokeSize),HX_HCSTRING("strokeSize","\x99","\xbc","\xf1","\x9d")},
	{hx::fsInt,(int)offsetof(G_obj,fillColor),HX_HCSTRING("fillColor","\xe0","\x97","\x03","\x19")},
	{hx::fsInt,(int)offsetof(G_obj,strokeColor),HX_HCSTRING("strokeColor","\x8b","\xb2","\x16","\x63")},
	{hx::fsObject /*::com::stencyl::models::Font*/ ,(int)offsetof(G_obj,font),HX_HCSTRING("font","\xcf","\x5d","\xc0","\x43")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(G_obj,fontData),HX_HCSTRING("fontData","\x99","\x73","\xe1","\xc4")},
	{hx::fsObject /*::openfl::geom::Matrix*/ ,(int)offsetof(G_obj,mtx),HX_HCSTRING("mtx","\x31","\x1b","\x53","\x00")},
	{hx::fsObject /*::openfl::geom::Rectangle*/ ,(int)offsetof(G_obj,rect),HX_HCSTRING("rect","\x24","\x4d","\xa7","\x4b")},
	{hx::fsObject /*::openfl::geom::Rectangle*/ ,(int)offsetof(G_obj,rect2),HX_HCSTRING("rect2","\x8e","\x32","\xbc","\xe6")},
	{hx::fsObject /*::openfl::geom::Point*/ ,(int)offsetof(G_obj,point),HX_HCSTRING("point","\x50","\xb4","\x8f","\xc6")},
	{hx::fsObject /*::openfl::geom::Point*/ ,(int)offsetof(G_obj,point2),HX_HCSTRING("point2","\xe2","\x11","\x2e","\xf7")},
	{hx::fsObject /*Array< Float >*/ ,(int)offsetof(G_obj,data),HX_HCSTRING("data","\x2a","\x56","\x63","\x42")},
	{hx::fsBool,(int)offsetof(G_obj,drawPoly),HX_HCSTRING("drawPoly","\x70","\x28","\xc6","\x5e")},
	{hx::fsInt,(int)offsetof(G_obj,pointCounter),HX_HCSTRING("pointCounter","\x8c","\x4c","\xfd","\xfb")},
	{hx::fsFloat,(int)offsetof(G_obj,firstX),HX_HCSTRING("firstX","\x28","\xb2","\x2b","\x89")},
	{hx::fsFloat,(int)offsetof(G_obj,firstY),HX_HCSTRING("firstY","\x29","\xb2","\x2b","\x89")},
	{hx::fsBool,(int)offsetof(G_obj,drawActor),HX_HCSTRING("drawActor","\x51","\x00","\xb2","\xe3")},
	{hx::fsObject /*::com::stencyl::models::Actor*/ ,(int)offsetof(G_obj,actor),HX_HCSTRING("actor","\xf5","\xca","\xa6","\x1b")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo G_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*::haxe::ds::IntMap*/ ,(void *) &G_obj::fontCache,HX_HCSTRING("fontCache","\xf3","\x3d","\xf0","\xec")},
	{hx::fsObject /*::haxe::ds::StringMap*/ ,(void *) &G_obj::drawnStringCache,HX_HCSTRING("drawnStringCache","\xe7","\x1f","\x8f","\xc7")},
	{hx::fsObject /*Array< ::String >*/ ,(void *) &G_obj::drawnStringCacheKeys,HX_HCSTRING("drawnStringCacheKeys","\x7b","\xad","\x7a","\xda")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String G_obj_sMemberFields[] = {
	HX_HCSTRING("defaultFont","\x30","\x57","\x7f","\x15"),
	HX_HCSTRING("graphics","\xcb","\xf8","\x67","\x12"),
	HX_HCSTRING("x","\x78","\x00","\x00","\x00"),
	HX_HCSTRING("y","\x79","\x00","\x00","\x00"),
	HX_HCSTRING("scaleX","\x8e","\xea","\x25","\x3c"),
	HX_HCSTRING("scaleY","\x8f","\xea","\x25","\x3c"),
	HX_HCSTRING("alpha","\x5e","\xa7","\x96","\x21"),
	HX_HCSTRING("blendMode","\x54","\xe4","\x37","\x0c"),
	HX_HCSTRING("strokeSize","\x99","\xbc","\xf1","\x9d"),
	HX_HCSTRING("fillColor","\xe0","\x97","\x03","\x19"),
	HX_HCSTRING("strokeColor","\x8b","\xb2","\x16","\x63"),
	HX_HCSTRING("font","\xcf","\x5d","\xc0","\x43"),
	HX_HCSTRING("fontData","\x99","\x73","\xe1","\xc4"),
	HX_HCSTRING("mtx","\x31","\x1b","\x53","\x00"),
	HX_HCSTRING("rect","\x24","\x4d","\xa7","\x4b"),
	HX_HCSTRING("rect2","\x8e","\x32","\xbc","\xe6"),
	HX_HCSTRING("point","\x50","\xb4","\x8f","\xc6"),
	HX_HCSTRING("point2","\xe2","\x11","\x2e","\xf7"),
	HX_HCSTRING("data","\x2a","\x56","\x63","\x42"),
	HX_HCSTRING("drawPoly","\x70","\x28","\xc6","\x5e"),
	HX_HCSTRING("pointCounter","\x8c","\x4c","\xfd","\xfb"),
	HX_HCSTRING("firstX","\x28","\xb2","\x2b","\x89"),
	HX_HCSTRING("firstY","\x29","\xb2","\x2b","\x89"),
	HX_HCSTRING("drawActor","\x51","\x00","\xb2","\xe3"),
	HX_HCSTRING("actor","\xf5","\xca","\xa6","\x1b"),
	HX_HCSTRING("resetGraphicsSettings","\xbd","\x68","\x49","\x54"),
	HX_HCSTRING("setFont","\x91","\x9e","\x44","\x09"),
	HX_HCSTRING("startGraphics","\x4d","\x5b","\x23","\x17"),
	HX_HCSTRING("endGraphics","\xc6","\x8b","\x26","\xca"),
	HX_HCSTRING("translate","\x4e","\xd7","\x7f","\x49"),
	HX_HCSTRING("moveTo","\xec","\xd2","\xac","\xcc"),
	HX_HCSTRING("translateToScreen","\xb5","\x74","\x8a","\xad"),
	HX_HCSTRING("translateToActor","\xcc","\x0d","\x14","\xf5"),
	HX_HCSTRING("getCacheKey","\x33","\xbf","\x14","\xc0"),
	HX_HCSTRING("drawString","\xf5","\xa3","\xf3","\x52"),
	HX_HCSTRING("drawLine","\x18","\xc2","\x1c","\x5c"),
	HX_HCSTRING("fillPixel","\x03","\xed","\x4a","\x91"),
	HX_HCSTRING("drawRect","\x48","\xf7","\x10","\x60"),
	HX_HCSTRING("fillRect","\x47","\x45","\xb9","\x6c"),
	HX_HCSTRING("drawRoundRect","\xee","\xc3","\xaa","\xe2"),
	HX_HCSTRING("fillRoundRect","\x8f","\x59","\xcc","\x64"),
	HX_HCSTRING("drawCircle","\x34","\xed","\xd0","\x97"),
	HX_HCSTRING("fillCircle","\xf3","\xf8","\xa7","\x59"),
	HX_HCSTRING("beginFillPolygon","\x8e","\xfe","\x05","\x52"),
	HX_HCSTRING("endDrawingPolygon","\xf7","\xb7","\x50","\x6f"),
	HX_HCSTRING("beginDrawPolygon","\x2d","\xc3","\xb2","\x77"),
	HX_HCSTRING("addPointToPolygon","\xd0","\xf9","\xe9","\x10"),
	HX_HCSTRING("drawImage","\xb7","\x54","\x74","\x85"),
	HX_HCSTRING("toARGB","\x47","\x94","\x15","\x76"),
	HX_HCSTRING("resetFont","\x3e","\x67","\xac","\x89"),
	::String(null()) };

static void G_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(G_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(G_obj::fontCache,"fontCache");
	HX_MARK_MEMBER_NAME(G_obj::drawnStringCache,"drawnStringCache");
	HX_MARK_MEMBER_NAME(G_obj::drawnStringCacheKeys,"drawnStringCacheKeys");
};

#ifdef HXCPP_VISIT_ALLOCS
static void G_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(G_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(G_obj::fontCache,"fontCache");
	HX_VISIT_MEMBER_NAME(G_obj::drawnStringCache,"drawnStringCache");
	HX_VISIT_MEMBER_NAME(G_obj::drawnStringCacheKeys,"drawnStringCacheKeys");
};

#endif

hx::Class G_obj::__mClass;

static ::String G_obj_sStaticFields[] = {
	HX_HCSTRING("fontCache","\xf3","\x3d","\xf0","\xec"),
	HX_HCSTRING("resetStatics","\xf6","\x81","\x43","\xa8"),
	HX_HCSTRING("drawnStringCache","\xe7","\x1f","\x8f","\xc7"),
	HX_HCSTRING("drawnStringCacheKeys","\x7b","\xad","\x7a","\xda"),
	HX_HCSTRING("visitStringCache","\xa6","\xf7","\x3e","\xf6"),
	::String(null())
};

void G_obj::__register()
{
	hx::Object *dummy = new G_obj;
	G_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("com.stencyl.graphics.G","\x33","\x83","\xf6","\x44");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &G_obj::__GetStatic;
	__mClass->mSetStaticField = &G_obj::__SetStatic;
	__mClass->mMarkFunc = G_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(G_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(G_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< G_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = G_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = G_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = G_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void G_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_6550bfc6d7343f4a_62_boot)
HXDLIN(  62)		fontCache = null();
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_6550bfc6d7343f4a_273_boot)
HXDLIN( 273)		drawnStringCache =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
            	}
{
            	HX_STACKFRAME(&_hx_pos_6550bfc6d7343f4a_274_boot)
HXDLIN( 274)		drawnStringCacheKeys = ::Array_obj< ::String >::__new();
            	}
}

} // end namespace com
} // end namespace stencyl
} // end namespace graphics
