// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_com_stencyl_Config
#include <com/stencyl/Config.h>
#endif
#ifndef INCLUDED_com_stencyl_Engine
#include <com/stencyl/Engine.h>
#endif
#ifndef INCLUDED_com_stencyl_graphics_AbstractAnimation
#include <com/stencyl/graphics/AbstractAnimation.h>
#endif
#ifndef INCLUDED_com_stencyl_graphics_BitmapAnimation
#include <com/stencyl/graphics/BitmapAnimation.h>
#endif
#ifndef INCLUDED_com_stencyl_graphics_G
#include <com/stencyl/graphics/G.h>
#endif
#ifndef INCLUDED_com_stencyl_models_Actor
#include <com/stencyl/models/Actor.h>
#endif
#ifndef INCLUDED_com_stencyl_models_actor_Animation
#include <com/stencyl/models/actor/Animation.h>
#endif
#ifndef INCLUDED_com_stencyl_utils_Utils
#include <com/stencyl/utils/Utils.h>
#endif
#ifndef INCLUDED_openfl_display_Bitmap
#include <openfl/display/Bitmap.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_Graphics
#include <openfl/display/Graphics.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_filters_BitmapFilter
#include <openfl/filters/BitmapFilter.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_2df1e27009be2d1f_33_new,"com.stencyl.graphics.BitmapAnimation","new",0x12713e53,"com.stencyl.graphics.BitmapAnimation.new","com/stencyl/graphics/BitmapAnimation.hx",33,0x697c2efc)
HX_LOCAL_STACK_FRAME(_hx_pos_2df1e27009be2d1f_61_update,"com.stencyl.graphics.BitmapAnimation","update",0x91e911f6,"com.stencyl.graphics.BitmapAnimation.update","com/stencyl/graphics/BitmapAnimation.hx",61,0x697c2efc)
HX_LOCAL_STACK_FRAME(_hx_pos_2df1e27009be2d1f_111_getCurrentFrame,"com.stencyl.graphics.BitmapAnimation","getCurrentFrame",0xe53dc15d,"com.stencyl.graphics.BitmapAnimation.getCurrentFrame","com/stencyl/graphics/BitmapAnimation.hx",111,0x697c2efc)
HX_LOCAL_STACK_FRAME(_hx_pos_2df1e27009be2d1f_116_getNumFrames,"com.stencyl.graphics.BitmapAnimation","getNumFrames",0xeada52c3,"com.stencyl.graphics.BitmapAnimation.getNumFrames","com/stencyl/graphics/BitmapAnimation.hx",116,0x697c2efc)
HX_LOCAL_STACK_FRAME(_hx_pos_2df1e27009be2d1f_120_setFrame,"com.stencyl.graphics.BitmapAnimation","setFrame",0x48880258,"com.stencyl.graphics.BitmapAnimation.setFrame","com/stencyl/graphics/BitmapAnimation.hx",120,0x697c2efc)
HX_LOCAL_STACK_FRAME(_hx_pos_2df1e27009be2d1f_138_isFinished,"com.stencyl.graphics.BitmapAnimation","isFinished",0xf0ba2be9,"com.stencyl.graphics.BitmapAnimation.isFinished","com/stencyl/graphics/BitmapAnimation.hx",138,0x697c2efc)
HX_LOCAL_STACK_FRAME(_hx_pos_2df1e27009be2d1f_142_reset,"com.stencyl.graphics.BitmapAnimation","reset",0xcd935a82,"com.stencyl.graphics.BitmapAnimation.reset","com/stencyl/graphics/BitmapAnimation.hx",142,0x697c2efc)
HX_LOCAL_STACK_FRAME(_hx_pos_2df1e27009be2d1f_150_updateBitmap,"com.stencyl.graphics.BitmapAnimation","updateBitmap",0x6ecc7285,"com.stencyl.graphics.BitmapAnimation.updateBitmap","com/stencyl/graphics/BitmapAnimation.hx",150,0x697c2efc)
HX_LOCAL_STACK_FRAME(_hx_pos_2df1e27009be2d1f_171_set_filter,"com.stencyl.graphics.BitmapAnimation","set_filter",0x5a36b462,"com.stencyl.graphics.BitmapAnimation.set_filter","com/stencyl/graphics/BitmapAnimation.hx",171,0x697c2efc)
HX_LOCAL_STACK_FRAME(_hx_pos_2df1e27009be2d1f_180_applyFilters,"com.stencyl.graphics.BitmapAnimation","applyFilters",0xc6b0a99a,"com.stencyl.graphics.BitmapAnimation.applyFilters","com/stencyl/graphics/BitmapAnimation.hx",180,0x697c2efc)
HX_LOCAL_STACK_FRAME(_hx_pos_2df1e27009be2d1f_194_draw,"com.stencyl.graphics.BitmapAnimation","draw",0x0a12f2b1,"com.stencyl.graphics.BitmapAnimation.draw","com/stencyl/graphics/BitmapAnimation.hx",194,0x697c2efc)
HX_LOCAL_STACK_FRAME(_hx_pos_2df1e27009be2d1f_203_getFrameDurations,"com.stencyl.graphics.BitmapAnimation","getFrameDurations",0x7b25551b,"com.stencyl.graphics.BitmapAnimation.getFrameDurations","com/stencyl/graphics/BitmapAnimation.hx",203,0x697c2efc)
HX_LOCAL_STACK_FRAME(_hx_pos_2df1e27009be2d1f_208_setFrameDurations,"com.stencyl.graphics.BitmapAnimation","setFrameDurations",0x9e932d27,"com.stencyl.graphics.BitmapAnimation.setFrameDurations","com/stencyl/graphics/BitmapAnimation.hx",208,0x697c2efc)
HX_LOCAL_STACK_FRAME(_hx_pos_2df1e27009be2d1f_221_setFrameDuration,"com.stencyl.graphics.BitmapAnimation","setFrameDuration",0x6495e5cc,"com.stencyl.graphics.BitmapAnimation.setFrameDuration","com/stencyl/graphics/BitmapAnimation.hx",221,0x697c2efc)
HX_LOCAL_STACK_FRAME(_hx_pos_2df1e27009be2d1f_240_framesUpdated,"com.stencyl.graphics.BitmapAnimation","framesUpdated",0xdb1c96e8,"com.stencyl.graphics.BitmapAnimation.framesUpdated","com/stencyl/graphics/BitmapAnimation.hx",240,0x697c2efc)
HX_LOCAL_STACK_FRAME(_hx_pos_2df1e27009be2d1f_254_getCurrentImage,"com.stencyl.graphics.BitmapAnimation","getCurrentImage",0x9c23688b,"com.stencyl.graphics.BitmapAnimation.getCurrentImage","com/stencyl/graphics/BitmapAnimation.hx",254,0x697c2efc)
HX_LOCAL_STACK_FRAME(_hx_pos_2df1e27009be2d1f_261_activate,"com.stencyl.graphics.BitmapAnimation","activate",0x197c3ce0,"com.stencyl.graphics.BitmapAnimation.activate","com/stencyl/graphics/BitmapAnimation.hx",261,0x697c2efc)
namespace com{
namespace stencyl{
namespace graphics{

void BitmapAnimation_obj::__construct( ::com::stencyl::models::actor::Animation model){
            	HX_STACKFRAME(&_hx_pos_2df1e27009be2d1f_33_new)
HXLINE(  34)		super::__construct(model->frames->__get((int)0).StaticCast<  ::openfl::display::BitmapData >(),null(),null());
HXLINE(  36)		this->model = model;
HXLINE(  42)		this->set_x((((Float)-(model->frameWidth) / (Float)(int)2) * ::com::stencyl::Engine_obj::SCALE));
HXLINE(  43)		this->set_y((((Float)-(model->frameHeight) / (Float)(int)2) * ::com::stencyl::Engine_obj::SCALE));
HXLINE(  46)		this->timer = (int)0;
HXLINE(  47)		this->frameIndex = (int)0;
HXLINE(  49)		this->individualDurations = false;
HXLINE(  50)		this->durations = model->durations;
HXLINE(  52)		this->numFrames = this->durations->length;
HXLINE(  53)		this->smoothing = ::com::stencyl::Config_obj::antialias;
HXLINE(  55)		this->finished = (this->numFrames <= (int)1);
HXLINE(  57)		{
HXLINE(  57)			if (hx::IsNotNull( this->filter )) {
HXLINE(  57)				if (!(this->filteredFrames->__get(this->frameIndex))) {
HXLINE(  57)					::Array< ::Dynamic> _hx_tmp = this->frames;
HXDLIN(  57)					int _hx_tmp1 = this->frameIndex;
HXDLIN(  57)					 ::openfl::display::BitmapData _hx_tmp2 = this->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >();
HXDLIN(  57)					_hx_tmp[_hx_tmp1] = this->applyFilters(_hx_tmp2,this->model->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >(),this->filter);
HXDLIN(  57)					this->filteredFrames[this->frameIndex] = true;
            				}
HXDLIN(  57)				this->set_bitmapData(this->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >());
            			}
            			else {
HXLINE(  57)				this->set_bitmapData(this->model->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >());
            			}
HXDLIN(  57)			this->smoothing = ::com::stencyl::Config_obj::antialias;
            		}
            	}

Dynamic BitmapAnimation_obj::__CreateEmpty() { return new BitmapAnimation_obj; }

void *BitmapAnimation_obj::_hx_vtable = 0;

Dynamic BitmapAnimation_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< BitmapAnimation_obj > _hx_result = new BitmapAnimation_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool BitmapAnimation_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x1b123bf8) {
		if (inClassId<=(int)0x19c29573) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x19c29573;
		} else {
			return inClassId==(int)0x1b123bf8;
		}
	} else {
		return inClassId==(int)0x3b5602c1 || inClassId==(int)0x648de55f;
	}
}

static ::com::stencyl::graphics::AbstractAnimation_obj _hx_com_stencyl_graphics_BitmapAnimation__hx_com_stencyl_graphics_AbstractAnimation= {
	( void (hx::Object::*)(Float))&::com::stencyl::graphics::BitmapAnimation_obj::update,
	( int (hx::Object::*)())&::com::stencyl::graphics::BitmapAnimation_obj::getCurrentFrame,
	( int (hx::Object::*)())&::com::stencyl::graphics::BitmapAnimation_obj::getNumFrames,
	( void (hx::Object::*)(int))&::com::stencyl::graphics::BitmapAnimation_obj::setFrame,
	( bool (hx::Object::*)())&::com::stencyl::graphics::BitmapAnimation_obj::isFinished,
	( void (hx::Object::*)())&::com::stencyl::graphics::BitmapAnimation_obj::activate,
	( void (hx::Object::*)())&::com::stencyl::graphics::BitmapAnimation_obj::reset,
	( void (hx::Object::*)( ::com::stencyl::graphics::G,Float,Float,Float,Float))&::com::stencyl::graphics::BitmapAnimation_obj::draw,
	( ::Array< int > (hx::Object::*)())&::com::stencyl::graphics::BitmapAnimation_obj::getFrameDurations,
	( void (hx::Object::*)(int))&::com::stencyl::graphics::BitmapAnimation_obj::setFrameDurations,
	( void (hx::Object::*)(int,int))&::com::stencyl::graphics::BitmapAnimation_obj::setFrameDuration,
	(  ::openfl::display::BitmapData (hx::Object::*)())&::com::stencyl::graphics::BitmapAnimation_obj::getCurrentImage,
};

void *BitmapAnimation_obj::_hx_getInterface(int inHash) {
	switch(inHash) {
		case (int)0x6aec248c: return &_hx_com_stencyl_graphics_BitmapAnimation__hx_com_stencyl_graphics_AbstractAnimation;
	}
	return super::_hx_getInterface(inHash);
}

void BitmapAnimation_obj::update(Float elapsedTime){
            	HX_STACKFRAME(&_hx_pos_2df1e27009be2d1f_61_update)
HXLINE(  63)		bool _hx_tmp;
HXDLIN(  63)		if (this->model->sync) {
HXLINE(  63)			_hx_tmp = this->model->looping;
            		}
            		else {
HXLINE(  63)			_hx_tmp = false;
            		}
HXDLIN(  63)		if (!(_hx_tmp)) {
HXLINE(  65)			 ::com::stencyl::graphics::BitmapAnimation _hx_tmp1 = hx::ObjectPtr<OBJ_>(this);
HXDLIN(  65)			_hx_tmp1->timer = (_hx_tmp1->timer + elapsedTime);
HXLINE(  67)			bool _hx_tmp2;
HXDLIN(  67)			if ((this->numFrames > (int)0)) {
HXLINE(  67)				Float _hx_tmp3 = this->timer;
HXDLIN(  67)				_hx_tmp2 = (_hx_tmp3 > this->durations->__get(this->frameIndex));
            			}
            			else {
HXLINE(  67)				_hx_tmp2 = false;
            			}
HXDLIN(  67)			if (_hx_tmp2) {
HXLINE(  69)				int old = this->frameIndex;
HXLINE(  71)				 ::com::stencyl::graphics::BitmapAnimation _hx_tmp4 = hx::ObjectPtr<OBJ_>(this);
HXDLIN(  71)				_hx_tmp4->timer = (_hx_tmp4->timer - this->durations->__get(this->frameIndex));
HXLINE(  73)				this->frameIndex++;
HXLINE(  75)				if ((this->frameIndex >= this->numFrames)) {
HXLINE(  77)					if (this->model->looping) {
HXLINE(  79)						this->frameIndex = (int)0;
            					}
            					else {
HXLINE(  84)						this->finished = true;
HXLINE(  85)						this->frameIndex--;
            					}
            				}
HXLINE(  89)				if ((old != this->frameIndex)) {
HXLINE(  91)					if (hx::IsNotNull( this->filter )) {
HXLINE(  91)						if (!(this->filteredFrames->__get(this->frameIndex))) {
HXLINE(  91)							::Array< ::Dynamic> _hx_tmp5 = this->frames;
HXDLIN(  91)							int _hx_tmp6 = this->frameIndex;
HXDLIN(  91)							 ::openfl::display::BitmapData _hx_tmp7 = this->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >();
HXDLIN(  91)							_hx_tmp5[_hx_tmp6] = this->applyFilters(_hx_tmp7,this->model->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >(),this->filter);
HXDLIN(  91)							this->filteredFrames[this->frameIndex] = true;
            						}
HXDLIN(  91)						this->set_bitmapData(this->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >());
            					}
            					else {
HXLINE(  91)						this->set_bitmapData(this->model->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >());
            					}
HXDLIN(  91)					this->smoothing = ::com::stencyl::Config_obj::antialias;
            				}
            			}
HXLINE(  95)			return;
            		}
HXLINE(  98)		int old1 = this->frameIndex;
HXLINE( 100)		this->timer = this->model->sharedTimer;
HXLINE( 101)		this->frameIndex = this->model->sharedFrameIndex;
HXLINE( 103)		if ((old1 != this->frameIndex)) {
HXLINE( 105)			if (hx::IsNotNull( this->filter )) {
HXLINE( 105)				if (!(this->filteredFrames->__get(this->frameIndex))) {
HXLINE( 105)					::Array< ::Dynamic> _hx_tmp8 = this->frames;
HXDLIN( 105)					int _hx_tmp9 = this->frameIndex;
HXDLIN( 105)					 ::openfl::display::BitmapData _hx_tmp10 = this->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >();
HXDLIN( 105)					_hx_tmp8[_hx_tmp9] = this->applyFilters(_hx_tmp10,this->model->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >(),this->filter);
HXDLIN( 105)					this->filteredFrames[this->frameIndex] = true;
            				}
HXDLIN( 105)				this->set_bitmapData(this->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >());
            			}
            			else {
HXLINE( 105)				this->set_bitmapData(this->model->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >());
            			}
HXDLIN( 105)			this->smoothing = ::com::stencyl::Config_obj::antialias;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(BitmapAnimation_obj,update,(void))

int BitmapAnimation_obj::getCurrentFrame(){
            	HX_STACKFRAME(&_hx_pos_2df1e27009be2d1f_111_getCurrentFrame)
HXDLIN( 111)		return this->frameIndex;
            	}


HX_DEFINE_DYNAMIC_FUNC0(BitmapAnimation_obj,getCurrentFrame,return )

int BitmapAnimation_obj::getNumFrames(){
            	HX_STACKFRAME(&_hx_pos_2df1e27009be2d1f_116_getNumFrames)
HXDLIN( 116)		return this->numFrames;
            	}


HX_DEFINE_DYNAMIC_FUNC0(BitmapAnimation_obj,getNumFrames,return )

void BitmapAnimation_obj::setFrame(int frame){
            	HX_STACKFRAME(&_hx_pos_2df1e27009be2d1f_120_setFrame)
HXLINE( 121)		bool _hx_tmp;
HXDLIN( 121)		if ((frame >= (int)0)) {
HXLINE( 121)			_hx_tmp = (frame >= this->numFrames);
            		}
            		else {
HXLINE( 121)			_hx_tmp = true;
            		}
HXDLIN( 121)		if (_hx_tmp) {
HXLINE( 123)			frame = (int)0;
            		}
HXLINE( 126)		if ((frame != this->frameIndex)) {
HXLINE( 128)			this->frameIndex = frame;
HXLINE( 129)			{
HXLINE( 129)				if (hx::IsNotNull( this->filter )) {
HXLINE( 129)					if (!(this->filteredFrames->__get(this->frameIndex))) {
HXLINE( 129)						::Array< ::Dynamic> _hx_tmp1 = this->frames;
HXDLIN( 129)						int _hx_tmp2 = this->frameIndex;
HXDLIN( 129)						 ::openfl::display::BitmapData _hx_tmp3 = this->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >();
HXDLIN( 129)						_hx_tmp1[_hx_tmp2] = this->applyFilters(_hx_tmp3,this->model->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >(),this->filter);
HXDLIN( 129)						this->filteredFrames[this->frameIndex] = true;
            					}
HXDLIN( 129)					this->set_bitmapData(this->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >());
            				}
            				else {
HXLINE( 129)					this->set_bitmapData(this->model->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >());
            				}
HXDLIN( 129)				this->smoothing = ::com::stencyl::Config_obj::antialias;
            			}
            		}
HXLINE( 132)		this->timer = (int)0;
HXLINE( 133)		this->finished = false;
            	}


HX_DEFINE_DYNAMIC_FUNC1(BitmapAnimation_obj,setFrame,(void))

bool BitmapAnimation_obj::isFinished(){
            	HX_STACKFRAME(&_hx_pos_2df1e27009be2d1f_138_isFinished)
HXDLIN( 138)		return this->finished;
            	}


HX_DEFINE_DYNAMIC_FUNC0(BitmapAnimation_obj,isFinished,return )

void BitmapAnimation_obj::reset(){
            	HX_STACKFRAME(&_hx_pos_2df1e27009be2d1f_142_reset)
HXLINE( 143)		this->timer = (int)0;
HXLINE( 144)		this->frameIndex = (int)0;
HXLINE( 145)		this->finished = false;
HXLINE( 146)		{
HXLINE( 146)			if (hx::IsNotNull( this->filter )) {
HXLINE( 146)				if (!(this->filteredFrames->__get(this->frameIndex))) {
HXLINE( 146)					::Array< ::Dynamic> _hx_tmp = this->frames;
HXDLIN( 146)					int _hx_tmp1 = this->frameIndex;
HXDLIN( 146)					 ::openfl::display::BitmapData _hx_tmp2 = this->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >();
HXDLIN( 146)					_hx_tmp[_hx_tmp1] = this->applyFilters(_hx_tmp2,this->model->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >(),this->filter);
HXDLIN( 146)					this->filteredFrames[this->frameIndex] = true;
            				}
HXDLIN( 146)				this->set_bitmapData(this->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >());
            			}
            			else {
HXLINE( 146)				this->set_bitmapData(this->model->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >());
            			}
HXDLIN( 146)			this->smoothing = ::com::stencyl::Config_obj::antialias;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(BitmapAnimation_obj,reset,(void))

void BitmapAnimation_obj::updateBitmap(){
            	HX_STACKFRAME(&_hx_pos_2df1e27009be2d1f_150_updateBitmap)
HXLINE( 152)		if (hx::IsNotNull( this->filter )) {
HXLINE( 154)			if (!(this->filteredFrames->__get(this->frameIndex))) {
HXLINE( 156)				::Array< ::Dynamic> _hx_tmp = this->frames;
HXDLIN( 156)				int _hx_tmp1 = this->frameIndex;
HXDLIN( 156)				 ::openfl::display::BitmapData _hx_tmp2 = this->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >();
HXDLIN( 156)				_hx_tmp[_hx_tmp1] = this->applyFilters(_hx_tmp2,this->model->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >(),this->filter);
HXLINE( 157)				this->filteredFrames[this->frameIndex] = true;
            			}
HXLINE( 159)			this->set_bitmapData(this->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >());
            		}
            		else {
HXLINE( 164)			this->set_bitmapData(this->model->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >());
            		}
HXLINE( 166)		this->smoothing = ::com::stencyl::Config_obj::antialias;
            	}


HX_DEFINE_DYNAMIC_FUNC0(BitmapAnimation_obj,updateBitmap,(void))

::Array< ::Dynamic> BitmapAnimation_obj::set_filter(::Array< ::Dynamic> filter){
            	HX_STACKFRAME(&_hx_pos_2df1e27009be2d1f_171_set_filter)
HXLINE( 172)		this->filter = filter;
HXLINE( 173)		::Array< bool > _g = ::Array_obj< bool >::__new(0);
HXDLIN( 173)		{
HXLINE( 173)			int _g2 = (int)0;
HXDLIN( 173)			int _g1 = this->numFrames;
HXDLIN( 173)			while((_g2 < _g1)){
HXLINE( 173)				_g2 = (_g2 + (int)1);
HXDLIN( 173)				int i = (_g2 - (int)1);
HXDLIN( 173)				_g->push(false);
            			}
            		}
HXDLIN( 173)		this->filteredFrames = _g;
HXLINE( 174)		::Array< ::Dynamic> _g11 = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN( 174)		{
HXLINE( 174)			int _g3 = (int)0;
HXDLIN( 174)			int _g21 = this->numFrames;
HXDLIN( 174)			while((_g3 < _g21)){
HXLINE( 174)				_g3 = (_g3 + (int)1);
HXDLIN( 174)				int i1 = (_g3 - (int)1);
HXDLIN( 174)				_g11->push(null());
            			}
            		}
HXDLIN( 174)		this->frames = _g11;
HXLINE( 175)		{
HXLINE( 175)			if (hx::IsNotNull( this->filter )) {
HXLINE( 175)				if (!(this->filteredFrames->__get(this->frameIndex))) {
HXLINE( 175)					::Array< ::Dynamic> _hx_tmp = this->frames;
HXDLIN( 175)					int _hx_tmp1 = this->frameIndex;
HXDLIN( 175)					 ::openfl::display::BitmapData _hx_tmp2 = this->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >();
HXDLIN( 175)					_hx_tmp[_hx_tmp1] = this->applyFilters(_hx_tmp2,this->model->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >(),this->filter);
HXDLIN( 175)					this->filteredFrames[this->frameIndex] = true;
            				}
HXDLIN( 175)				this->set_bitmapData(this->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >());
            			}
            			else {
HXLINE( 175)				this->set_bitmapData(this->model->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >());
            			}
HXDLIN( 175)			this->smoothing = ::com::stencyl::Config_obj::antialias;
            		}
HXLINE( 176)		return filter;
            	}


HX_DEFINE_DYNAMIC_FUNC1(BitmapAnimation_obj,set_filter,return )

 ::openfl::display::BitmapData BitmapAnimation_obj::applyFilters( ::openfl::display::BitmapData destBitmapData, ::openfl::display::BitmapData sourceBitmapData,::Array< ::Dynamic> filters){
            	HX_GC_STACKFRAME(&_hx_pos_2df1e27009be2d1f_180_applyFilters)
HXLINE( 181)		if (hx::IsNull( destBitmapData )) {
HXLINE( 182)			destBitmapData =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,sourceBitmapData->width,sourceBitmapData->height,null(),null());
            		}
HXLINE( 184)		{
HXLINE( 184)			int _g = (int)0;
HXDLIN( 184)			while((_g < filters->length)){
HXLINE( 184)				 ::openfl::filters::BitmapFilter f = filters->__get(_g).StaticCast<  ::openfl::filters::BitmapFilter >();
HXDLIN( 184)				_g = (_g + (int)1);
HXLINE( 186)				sourceBitmapData = f->_hx___applyFilter(destBitmapData,sourceBitmapData,sourceBitmapData->rect,::com::stencyl::utils::Utils_obj::zero);
            			}
            		}
HXLINE( 189)		return destBitmapData;
            	}


HX_DEFINE_DYNAMIC_FUNC3(BitmapAnimation_obj,applyFilters,return )

void BitmapAnimation_obj::draw( ::com::stencyl::graphics::G g,Float x,Float y,Float angle,Float alpha){
            	HX_GC_STACKFRAME(&_hx_pos_2df1e27009be2d1f_194_draw)
HXLINE( 195)		bool _hx_tmp;
HXDLIN( 195)		if (::com::stencyl::Config_obj::disposeImages) {
HXLINE( 195)			_hx_tmp = !(this->model->checkImageReadable());
            		}
            		else {
HXLINE( 195)			_hx_tmp = false;
            		}
HXDLIN( 195)		if (_hx_tmp) {
HXLINE( 196)			return;
            		}
HXLINE( 198)		{
HXLINE( 198)			 ::openfl::display::BitmapData img = this->get_bitmapData();
HXDLIN( 198)			Float x1 = x;
HXDLIN( 198)			Float y1 = y;
HXDLIN( 198)			x1 = (x1 * g->scaleX);
HXDLIN( 198)			y1 = (y1 * g->scaleY);
HXDLIN( 198)			g->rect->x = (int)0;
HXDLIN( 198)			g->rect->y = (int)0;
HXDLIN( 198)			g->rect->width = img->width;
HXDLIN( 198)			g->rect->height = img->height;
HXDLIN( 198)			if (g->drawActor) {
HXLINE( 198)				bool _hx_tmp1;
HXDLIN( 198)				if (hx::IsNotNull( g->actor )) {
HXLINE( 198)					_hx_tmp1 = g->actor->isHUD;
            				}
            				else {
HXLINE( 198)					_hx_tmp1 = false;
            				}
HXDLIN( 198)				if (_hx_tmp1) {
HXLINE( 198)					g->point->x = (g->x + x1);
HXDLIN( 198)					g->point->y = (g->y + y1);
            				}
            				else {
HXLINE( 198)					g->point->x = ((g->x + x1) - ::com::stencyl::Engine_obj::cameraX);
HXDLIN( 198)					g->point->y = ((g->y + y1) - ::com::stencyl::Engine_obj::cameraY);
            				}
            			}
            			else {
HXLINE( 198)				g->point->x = (g->x + x1);
HXDLIN( 198)				g->point->y = (g->y + y1);
            			}
HXDLIN( 198)			 ::openfl::display::BitmapData newImg = null();
HXDLIN( 198)			int imgSize = (int)0;
HXDLIN( 198)			g->mtx->identity();
HXDLIN( 198)			g->mtx->rotate(angle);
HXDLIN( 198)			g->mtx->translate(g->point->x,g->point->y);
HXDLIN( 198)			if ((angle == (int)0)) {
HXLINE( 198)				if ((g->alpha == (int)1)) {
HXLINE( 198)					g->graphics->beginBitmapFill(img,g->mtx,null(),null());
            				}
            				else {
HXLINE( 198)					g->point2->x = (int)0;
HXDLIN( 198)					g->point2->y = (int)0;
HXDLIN( 198)					g->rect2->width = img->width;
HXDLIN( 198)					g->rect2->height = img->height;
HXDLIN( 198)					int img1 = img->width;
HXDLIN( 198)					int img2 = img->height;
HXDLIN( 198)					 ::openfl::display::BitmapData temp =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,img1,img2,true,g->toARGB((int)0,::Std_obj::_hx_int((g->alpha * (int)255))));
HXDLIN( 198)					 ::openfl::display::BitmapData temp2 =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,img->width,img->height,true,(int)0);
HXDLIN( 198)					temp2->copyPixels(img,g->rect2,g->point2,temp,null(),true);
HXDLIN( 198)					img = temp2;
HXDLIN( 198)					g->graphics->beginBitmapFill(img,g->mtx,null(),null());
            				}
HXDLIN( 198)				g->graphics->drawRect(g->point->x,g->point->y,img->width,img->height);
            			}
            			else {
HXLINE( 198)				if ((g->alpha != (int)1)) {
HXLINE( 198)					g->point2->x = (int)0;
HXDLIN( 198)					g->point2->y = (int)0;
HXDLIN( 198)					g->rect2->width = img->width;
HXDLIN( 198)					g->rect2->height = img->height;
HXDLIN( 198)					int img3 = img->width;
HXDLIN( 198)					int img4 = img->height;
HXDLIN( 198)					 ::openfl::display::BitmapData temp1 =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,img3,img4,true,g->toARGB((int)0,::Std_obj::_hx_int((g->alpha * (int)255))));
HXDLIN( 198)					 ::openfl::display::BitmapData temp21 =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,img->width,img->height,true,(int)0);
HXDLIN( 198)					temp21->copyPixels(img,g->rect2,g->point2,temp1,null(),true);
HXDLIN( 198)					img = temp21;
            				}
HXDLIN( 198)				int newImg1 = (img->width + (int)2);
HXDLIN( 198)				newImg =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,newImg1,(img->height + (int)2),true,(int)0);
HXDLIN( 198)				Float imgSize1 = ::Math_obj::pow(newImg->width,(int)2);
HXDLIN( 198)				imgSize = ::Std_obj::_hx_int(::Math_obj::sqrt((imgSize1 + ::Math_obj::pow(newImg->height,(int)2))));
HXDLIN( 198)				 ::openfl::geom::Rectangle srcRect =  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,(int)0,(int)0,img->width,img->height);
HXDLIN( 198)				 ::openfl::geom::Point destPt =  ::openfl::geom::Point_obj::__alloc( HX_CTX ,(int)1,(int)1);
HXDLIN( 198)				newImg->copyPixels(img,srcRect,destPt,null(),null(),null());
HXDLIN( 198)				g->graphics->beginBitmapFill(newImg,g->mtx,false,::com::stencyl::Config_obj::antialias);
HXDLIN( 198)				Float rectX = ((Float)(imgSize - img->width) / (Float)(int)2);
HXDLIN( 198)				Float rectY = ((Float)(imgSize - img->height) / (Float)(int)2);
HXDLIN( 198)				 ::openfl::display::Graphics g1 = g->graphics;
HXDLIN( 198)				Float _hx_tmp2 = (g->x - rectX);
HXDLIN( 198)				g1->drawRect(_hx_tmp2,(g->y - rectY),imgSize,imgSize);
            			}
HXDLIN( 198)			g->graphics->endFill();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC5(BitmapAnimation_obj,draw,(void))

::Array< int > BitmapAnimation_obj::getFrameDurations(){
            	HX_STACKFRAME(&_hx_pos_2df1e27009be2d1f_203_getFrameDurations)
HXDLIN( 203)		return this->durations;
            	}


HX_DEFINE_DYNAMIC_FUNC0(BitmapAnimation_obj,getFrameDurations,return )

void BitmapAnimation_obj::setFrameDurations(int time){
            	HX_STACKFRAME(&_hx_pos_2df1e27009be2d1f_208_setFrameDurations)
HXDLIN( 208)		if (hx::IsNotNull( this->durations )) {
HXLINE( 210)			::Array< int > newDurations = ::Array_obj< int >::__new();
HXLINE( 211)			{
HXLINE( 211)				int _g1 = (int)0;
HXDLIN( 211)				int _g = this->durations->length;
HXDLIN( 211)				while((_g1 < _g)){
HXLINE( 211)					_g1 = (_g1 + (int)1);
HXDLIN( 211)					int i = (_g1 - (int)1);
HXLINE( 213)					newDurations->push(time);
            				}
            			}
HXLINE( 215)			this->durations = newDurations;
HXLINE( 216)			this->individualDurations = true;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(BitmapAnimation_obj,setFrameDurations,(void))

void BitmapAnimation_obj::setFrameDuration(int frame,int time){
            	HX_STACKFRAME(&_hx_pos_2df1e27009be2d1f_221_setFrameDuration)
HXLINE( 222)		if (!(this->individualDurations)) {
HXLINE( 224)			::Array< int > newDurations = ::Array_obj< int >::__new();
HXLINE( 225)			{
HXLINE( 225)				int _g1 = (int)0;
HXDLIN( 225)				int _g = this->durations->length;
HXDLIN( 225)				while((_g1 < _g)){
HXLINE( 225)					_g1 = (_g1 + (int)1);
HXDLIN( 225)					int i = (_g1 - (int)1);
HXLINE( 227)					newDurations->push(this->durations->__get(i));
            				}
            			}
HXLINE( 229)			this->durations = newDurations;
HXLINE( 230)			this->individualDurations = true;
            		}
HXLINE( 233)		bool _hx_tmp;
HXDLIN( 233)		if ((frame >= (int)0)) {
HXLINE( 233)			_hx_tmp = (frame < this->durations->length);
            		}
            		else {
HXLINE( 233)			_hx_tmp = false;
            		}
HXDLIN( 233)		if (_hx_tmp) {
HXLINE( 235)			this->durations[frame] = time;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(BitmapAnimation_obj,setFrameDuration,(void))

void BitmapAnimation_obj::framesUpdated(){
            	HX_STACKFRAME(&_hx_pos_2df1e27009be2d1f_240_framesUpdated)
HXLINE( 246)		this->set_x((((Float)-(this->model->frameWidth) / (Float)(int)2) * ::com::stencyl::Engine_obj::SCALE));
HXLINE( 247)		this->set_y((((Float)-(this->model->frameHeight) / (Float)(int)2) * ::com::stencyl::Engine_obj::SCALE));
HXLINE( 250)		{
HXLINE( 250)			if (hx::IsNotNull( this->filter )) {
HXLINE( 250)				if (!(this->filteredFrames->__get(this->frameIndex))) {
HXLINE( 250)					::Array< ::Dynamic> _hx_tmp = this->frames;
HXDLIN( 250)					int _hx_tmp1 = this->frameIndex;
HXDLIN( 250)					 ::openfl::display::BitmapData _hx_tmp2 = this->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >();
HXDLIN( 250)					_hx_tmp[_hx_tmp1] = this->applyFilters(_hx_tmp2,this->model->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >(),this->filter);
HXDLIN( 250)					this->filteredFrames[this->frameIndex] = true;
            				}
HXDLIN( 250)				this->set_bitmapData(this->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >());
            			}
            			else {
HXLINE( 250)				this->set_bitmapData(this->model->frames->__get(this->frameIndex).StaticCast<  ::openfl::display::BitmapData >());
            			}
HXDLIN( 250)			this->smoothing = ::com::stencyl::Config_obj::antialias;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(BitmapAnimation_obj,framesUpdated,(void))

 ::openfl::display::BitmapData BitmapAnimation_obj::getCurrentImage(){
            	HX_STACKFRAME(&_hx_pos_2df1e27009be2d1f_254_getCurrentImage)
HXLINE( 255)		bool _hx_tmp;
HXDLIN( 255)		if (::com::stencyl::Config_obj::disposeImages) {
HXLINE( 255)			_hx_tmp = !(this->model->checkImageReadable());
            		}
            		else {
HXLINE( 255)			_hx_tmp = false;
            		}
HXDLIN( 255)		if (_hx_tmp) {
HXLINE( 256)			return ::com::stencyl::models::actor::Animation_obj::UNLOADED;
            		}
HXLINE( 258)		return this->get_bitmapData();
            	}


HX_DEFINE_DYNAMIC_FUNC0(BitmapAnimation_obj,getCurrentImage,return )

void BitmapAnimation_obj::activate(){
            	HX_STACKFRAME(&_hx_pos_2df1e27009be2d1f_261_activate)
            	}


HX_DEFINE_DYNAMIC_FUNC0(BitmapAnimation_obj,activate,(void))


hx::ObjectPtr< BitmapAnimation_obj > BitmapAnimation_obj::__new( ::com::stencyl::models::actor::Animation model) {
	hx::ObjectPtr< BitmapAnimation_obj > __this = new BitmapAnimation_obj();
	__this->__construct(model);
	return __this;
}

hx::ObjectPtr< BitmapAnimation_obj > BitmapAnimation_obj::__alloc(hx::Ctx *_hx_ctx, ::com::stencyl::models::actor::Animation model) {
	BitmapAnimation_obj *__this = (BitmapAnimation_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(BitmapAnimation_obj), true, "com.stencyl.graphics.BitmapAnimation"));
	*(void **)__this = BitmapAnimation_obj::_hx_vtable;
	__this->__construct(model);
	return __this;
}

BitmapAnimation_obj::BitmapAnimation_obj()
{
}

void BitmapAnimation_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(BitmapAnimation);
	HX_MARK_MEMBER_NAME(model,"model");
	HX_MARK_MEMBER_NAME(frameIndex,"frameIndex");
	HX_MARK_MEMBER_NAME(timer,"timer");
	HX_MARK_MEMBER_NAME(finished,"finished");
	HX_MARK_MEMBER_NAME(durations,"durations");
	HX_MARK_MEMBER_NAME(individualDurations,"individualDurations");
	HX_MARK_MEMBER_NAME(frames,"frames");
	HX_MARK_MEMBER_NAME(numFrames,"numFrames");
	HX_MARK_MEMBER_NAME(filter,"filter");
	HX_MARK_MEMBER_NAME(filteredFrames,"filteredFrames");
	 ::openfl::display::Bitmap_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void BitmapAnimation_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(model,"model");
	HX_VISIT_MEMBER_NAME(frameIndex,"frameIndex");
	HX_VISIT_MEMBER_NAME(timer,"timer");
	HX_VISIT_MEMBER_NAME(finished,"finished");
	HX_VISIT_MEMBER_NAME(durations,"durations");
	HX_VISIT_MEMBER_NAME(individualDurations,"individualDurations");
	HX_VISIT_MEMBER_NAME(frames,"frames");
	HX_VISIT_MEMBER_NAME(numFrames,"numFrames");
	HX_VISIT_MEMBER_NAME(filter,"filter");
	HX_VISIT_MEMBER_NAME(filteredFrames,"filteredFrames");
	 ::openfl::display::Bitmap_obj::__Visit(HX_VISIT_ARG);
}

hx::Val BitmapAnimation_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"draw") ) { return hx::Val( draw_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"model") ) { return hx::Val( model ); }
		if (HX_FIELD_EQ(inName,"timer") ) { return hx::Val( timer ); }
		if (HX_FIELD_EQ(inName,"reset") ) { return hx::Val( reset_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"frames") ) { return hx::Val( frames ); }
		if (HX_FIELD_EQ(inName,"filter") ) { return hx::Val( filter ); }
		if (HX_FIELD_EQ(inName,"update") ) { return hx::Val( update_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"finished") ) { return hx::Val( finished ); }
		if (HX_FIELD_EQ(inName,"setFrame") ) { return hx::Val( setFrame_dyn() ); }
		if (HX_FIELD_EQ(inName,"activate") ) { return hx::Val( activate_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"durations") ) { return hx::Val( durations ); }
		if (HX_FIELD_EQ(inName,"numFrames") ) { return hx::Val( numFrames ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"frameIndex") ) { return hx::Val( frameIndex ); }
		if (HX_FIELD_EQ(inName,"isFinished") ) { return hx::Val( isFinished_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_filter") ) { return hx::Val( set_filter_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"getNumFrames") ) { return hx::Val( getNumFrames_dyn() ); }
		if (HX_FIELD_EQ(inName,"updateBitmap") ) { return hx::Val( updateBitmap_dyn() ); }
		if (HX_FIELD_EQ(inName,"applyFilters") ) { return hx::Val( applyFilters_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"framesUpdated") ) { return hx::Val( framesUpdated_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"filteredFrames") ) { return hx::Val( filteredFrames ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"getCurrentFrame") ) { return hx::Val( getCurrentFrame_dyn() ); }
		if (HX_FIELD_EQ(inName,"getCurrentImage") ) { return hx::Val( getCurrentImage_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"setFrameDuration") ) { return hx::Val( setFrameDuration_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"getFrameDurations") ) { return hx::Val( getFrameDurations_dyn() ); }
		if (HX_FIELD_EQ(inName,"setFrameDurations") ) { return hx::Val( setFrameDurations_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"individualDurations") ) { return hx::Val( individualDurations ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val BitmapAnimation_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"model") ) { model=inValue.Cast<  ::com::stencyl::models::actor::Animation >(); return inValue; }
		if (HX_FIELD_EQ(inName,"timer") ) { timer=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"frames") ) { frames=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"filter") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_filter(inValue.Cast< ::Array< ::Dynamic> >()) );filter=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"finished") ) { finished=inValue.Cast< bool >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"durations") ) { durations=inValue.Cast< ::Array< int > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"numFrames") ) { numFrames=inValue.Cast< int >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"frameIndex") ) { frameIndex=inValue.Cast< int >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"filteredFrames") ) { filteredFrames=inValue.Cast< ::Array< bool > >(); return inValue; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"individualDurations") ) { individualDurations=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void BitmapAnimation_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("model","\xa9","\x23","\x58","\x0c"));
	outFields->push(HX_HCSTRING("frameIndex","\xa5","\xcf","\x3a","\xa1"));
	outFields->push(HX_HCSTRING("timer","\xc5","\xbf","\x35","\x10"));
	outFields->push(HX_HCSTRING("finished","\x72","\x93","\x0e","\x95"));
	outFields->push(HX_HCSTRING("durations","\x9f","\x5a","\xbf","\xe7"));
	outFields->push(HX_HCSTRING("individualDurations","\xc6","\x3d","\x51","\x21"));
	outFields->push(HX_HCSTRING("frames","\xa6","\xaf","\x85","\xac"));
	outFields->push(HX_HCSTRING("numFrames","\x8c","\xfa","\x86","\x5d"));
	outFields->push(HX_HCSTRING("filter","\xb8","\x1f","\x35","\x85"));
	outFields->push(HX_HCSTRING("filteredFrames","\x1d","\x25","\xd3","\xcb"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo BitmapAnimation_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::com::stencyl::models::actor::Animation*/ ,(int)offsetof(BitmapAnimation_obj,model),HX_HCSTRING("model","\xa9","\x23","\x58","\x0c")},
	{hx::fsInt,(int)offsetof(BitmapAnimation_obj,frameIndex),HX_HCSTRING("frameIndex","\xa5","\xcf","\x3a","\xa1")},
	{hx::fsFloat,(int)offsetof(BitmapAnimation_obj,timer),HX_HCSTRING("timer","\xc5","\xbf","\x35","\x10")},
	{hx::fsBool,(int)offsetof(BitmapAnimation_obj,finished),HX_HCSTRING("finished","\x72","\x93","\x0e","\x95")},
	{hx::fsObject /*Array< int >*/ ,(int)offsetof(BitmapAnimation_obj,durations),HX_HCSTRING("durations","\x9f","\x5a","\xbf","\xe7")},
	{hx::fsBool,(int)offsetof(BitmapAnimation_obj,individualDurations),HX_HCSTRING("individualDurations","\xc6","\x3d","\x51","\x21")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(BitmapAnimation_obj,frames),HX_HCSTRING("frames","\xa6","\xaf","\x85","\xac")},
	{hx::fsInt,(int)offsetof(BitmapAnimation_obj,numFrames),HX_HCSTRING("numFrames","\x8c","\xfa","\x86","\x5d")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(BitmapAnimation_obj,filter),HX_HCSTRING("filter","\xb8","\x1f","\x35","\x85")},
	{hx::fsObject /*Array< bool >*/ ,(int)offsetof(BitmapAnimation_obj,filteredFrames),HX_HCSTRING("filteredFrames","\x1d","\x25","\xd3","\xcb")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *BitmapAnimation_obj_sStaticStorageInfo = 0;
#endif

static ::String BitmapAnimation_obj_sMemberFields[] = {
	HX_HCSTRING("model","\xa9","\x23","\x58","\x0c"),
	HX_HCSTRING("frameIndex","\xa5","\xcf","\x3a","\xa1"),
	HX_HCSTRING("timer","\xc5","\xbf","\x35","\x10"),
	HX_HCSTRING("finished","\x72","\x93","\x0e","\x95"),
	HX_HCSTRING("durations","\x9f","\x5a","\xbf","\xe7"),
	HX_HCSTRING("individualDurations","\xc6","\x3d","\x51","\x21"),
	HX_HCSTRING("frames","\xa6","\xaf","\x85","\xac"),
	HX_HCSTRING("numFrames","\x8c","\xfa","\x86","\x5d"),
	HX_HCSTRING("filter","\xb8","\x1f","\x35","\x85"),
	HX_HCSTRING("filteredFrames","\x1d","\x25","\xd3","\xcb"),
	HX_HCSTRING("update","\x09","\x86","\x05","\x87"),
	HX_HCSTRING("getCurrentFrame","\xea","\xb2","\x79","\x70"),
	HX_HCSTRING("getNumFrames","\x16","\x97","\xdd","\x6c"),
	HX_HCSTRING("setFrame","\x2b","\xe1","\xb7","\x14"),
	HX_HCSTRING("isFinished","\x7c","\xa5","\xbd","\x0f"),
	HX_HCSTRING("reset","\xcf","\x49","\xc8","\xe6"),
	HX_HCSTRING("updateBitmap","\xd8","\xb6","\xcf","\xf0"),
	HX_HCSTRING("set_filter","\xf5","\x2d","\x3a","\x79"),
	HX_HCSTRING("applyFilters","\xed","\xed","\xb3","\x48"),
	HX_HCSTRING("draw","\x04","\x2c","\x70","\x42"),
	HX_HCSTRING("getFrameDurations","\xe8","\x83","\x6a","\x42"),
	HX_HCSTRING("setFrameDurations","\xf4","\x5b","\xd8","\x65"),
	HX_HCSTRING("setFrameDuration","\x9f","\x4f","\xcd","\xad"),
	HX_HCSTRING("framesUpdated","\x35","\x1b","\xf5","\x1b"),
	HX_HCSTRING("getCurrentImage","\x18","\x5a","\x5f","\x27"),
	HX_HCSTRING("activate","\xb3","\x1b","\xac","\xe5"),
	::String(null()) };

static void BitmapAnimation_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(BitmapAnimation_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void BitmapAnimation_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(BitmapAnimation_obj::__mClass,"__mClass");
};

#endif

hx::Class BitmapAnimation_obj::__mClass;

void BitmapAnimation_obj::__register()
{
	hx::Object *dummy = new BitmapAnimation_obj;
	BitmapAnimation_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("com.stencyl.graphics.BitmapAnimation","\xe1","\x18","\x21","\xa4");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = BitmapAnimation_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(BitmapAnimation_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< BitmapAnimation_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = BitmapAnimation_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = BitmapAnimation_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = BitmapAnimation_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace com
} // end namespace stencyl
} // end namespace graphics
