// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_box2D_collision_shapes_B2PolygonShape
#include <box2D/collision/shapes/B2PolygonShape.h>
#endif
#ifndef INCLUDED_box2D_collision_shapes_B2Shape
#include <box2D/collision/shapes/B2Shape.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Vec2
#include <box2D/common/math/B2Vec2.h>
#endif
#ifndef INCLUDED_com_stencyl_Data
#include <com/stencyl/Data.h>
#endif
#ifndef INCLUDED_com_stencyl_Engine
#include <com/stencyl/Engine.h>
#endif
#ifndef INCLUDED_com_stencyl_io_AttributeValues
#include <com/stencyl/io/AttributeValues.h>
#endif
#ifndef INCLUDED_com_stencyl_io_ShapeReader
#include <com/stencyl/io/ShapeReader.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_game_MbsAtlas
#include <com/stencyl/io/mbs/game/MbsAtlas.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_game_MbsCollisionGroup
#include <com/stencyl/io/mbs/game/MbsCollisionGroup.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_game_MbsCollisionPair
#include <com/stencyl/io/mbs/game/MbsCollisionPair.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_game_MbsCollisionShape
#include <com/stencyl/io/mbs/game/MbsCollisionShape.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_game_MbsGame
#include <com/stencyl/io/mbs/game/MbsGame.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_game_autotile_MbsAutotileFormat
#include <com/stencyl/io/mbs/game/autotile/MbsAutotileFormat.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_game_autotile_MbsCorners
#include <com/stencyl/io/mbs/game/autotile/MbsCorners.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_scene_MbsSceneHeader
#include <com/stencyl/io/mbs/scene/MbsSceneHeader.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_shape_MbsPoint
#include <com/stencyl/io/mbs/shape/MbsPoint.h>
#endif
#ifndef INCLUDED_com_stencyl_models_Atlas
#include <com/stencyl/models/Atlas.h>
#endif
#ifndef INCLUDED_com_stencyl_models_CollisionGroupDef
#include <com/stencyl/models/CollisionGroupDef.h>
#endif
#ifndef INCLUDED_com_stencyl_models_GameModel
#include <com/stencyl/models/GameModel.h>
#endif
#ifndef INCLUDED_com_stencyl_models_GroupDef
#include <com/stencyl/models/GroupDef.h>
#endif
#ifndef INCLUDED_com_stencyl_models_Scene
#include <com/stencyl/models/Scene.h>
#endif
#ifndef INCLUDED_com_stencyl_models_scene_AutotileFormat
#include <com/stencyl/models/scene/AutotileFormat.h>
#endif
#ifndef INCLUDED_com_stencyl_models_scene_Corners
#include <com/stencyl/models/scene/Corners.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_mbs_core_MbsObject
#include <mbs/core/MbsObject.h>
#endif
#ifndef INCLUDED_mbs_io_MbsIO
#include <mbs/io/MbsIO.h>
#endif
#ifndef INCLUDED_mbs_io_MbsIntList
#include <mbs/io/MbsIntList.h>
#endif
#ifndef INCLUDED_mbs_io_MbsList
#include <mbs/io/MbsList.h>
#endif
#ifndef INCLUDED_mbs_io_MbsListBase
#include <mbs/io/MbsListBase.h>
#endif
#ifndef INCLUDED_mbs_io_MbsReader
#include <mbs/io/MbsReader.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_30a5a0001bfa47c1_61_new,"com.stencyl.models.GameModel","new",0xa89f4df4,"com.stencyl.models.GameModel.new","com/stencyl/models/GameModel.hx",61,0xc159a9bb)
HX_LOCAL_STACK_FRAME(_hx_pos_30a5a0001bfa47c1_146_loadScenes,"com.stencyl.models.GameModel","loadScenes",0x6def9559,"com.stencyl.models.GameModel.loadScenes","com/stencyl/models/GameModel.hx",146,0xc159a9bb)
HX_LOCAL_STACK_FRAME(_hx_pos_30a5a0001bfa47c1_162_readShapes,"com.stencyl.models.GameModel","readShapes",0x909ddb14,"com.stencyl.models.GameModel.readShapes","com/stencyl/models/GameModel.hx",162,0xc159a9bb)
HX_LOCAL_STACK_FRAME(_hx_pos_30a5a0001bfa47c1_190_readAtlases,"com.stencyl.models.GameModel","readAtlases",0x24d09357,"com.stencyl.models.GameModel.readAtlases","com/stencyl/models/GameModel.hx",190,0xc159a9bb)
HX_LOCAL_STACK_FRAME(_hx_pos_30a5a0001bfa47c1_212_readAutotileFormats,"com.stencyl.models.GameModel","readAutotileFormats",0x4824db9d,"com.stencyl.models.GameModel.readAutotileFormats","com/stencyl/models/GameModel.hx",212,0xc159a9bb)
HX_LOCAL_STACK_FRAME(_hx_pos_30a5a0001bfa47c1_257_readGroups,"com.stencyl.models.GameModel","readGroups",0x8f9c2536,"com.stencyl.models.GameModel.readGroups","com/stencyl/models/GameModel.hx",257,0xc159a9bb)
HX_LOCAL_STACK_FRAME(_hx_pos_30a5a0001bfa47c1_272_readCollisionGroups,"com.stencyl.models.GameModel","readCollisionGroups",0x2dbdf544,"com.stencyl.models.GameModel.readCollisionGroups","com/stencyl/models/GameModel.hx",272,0xc159a9bb)
HX_LOCAL_STACK_FRAME(_hx_pos_30a5a0001bfa47c1_27_resetStatics,"com.stencyl.models.GameModel","resetStatics",0xa62db1e2,"com.stencyl.models.GameModel.resetStatics","com/stencyl/models/GameModel.hx",27,0xc159a9bb)
HX_LOCAL_STACK_FRAME(_hx_pos_30a5a0001bfa47c1_51_get,"com.stencyl.models.GameModel","get",0xa899fe2a,"com.stencyl.models.GameModel.get","com/stencyl/models/GameModel.hx",51,0xc159a9bb)
HX_LOCAL_STACK_FRAME(_hx_pos_30a5a0001bfa47c1_288_readGameAttributes,"com.stencyl.models.GameModel","readGameAttributes",0x66a3764b,"com.stencyl.models.GameModel.readGameAttributes","com/stencyl/models/GameModel.hx",288,0xc159a9bb)
HX_LOCAL_STACK_FRAME(_hx_pos_30a5a0001bfa47c1_43_boot,"com.stencyl.models.GameModel","boot",0xdadde81e,"com.stencyl.models.GameModel.boot","com/stencyl/models/GameModel.hx",43,0xc159a9bb)
HX_LOCAL_STACK_FRAME(_hx_pos_30a5a0001bfa47c1_44_boot,"com.stencyl.models.GameModel","boot",0xdadde81e,"com.stencyl.models.GameModel.boot","com/stencyl/models/GameModel.hx",44,0xc159a9bb)
HX_LOCAL_STACK_FRAME(_hx_pos_30a5a0001bfa47c1_45_boot,"com.stencyl.models.GameModel","boot",0xdadde81e,"com.stencyl.models.GameModel.boot","com/stencyl/models/GameModel.hx",45,0xc159a9bb)
HX_LOCAL_STACK_FRAME(_hx_pos_30a5a0001bfa47c1_46_boot,"com.stencyl.models.GameModel","boot",0xdadde81e,"com.stencyl.models.GameModel.boot","com/stencyl/models/GameModel.hx",46,0xc159a9bb)
HX_LOCAL_STACK_FRAME(_hx_pos_30a5a0001bfa47c1_47_boot,"com.stencyl.models.GameModel","boot",0xdadde81e,"com.stencyl.models.GameModel.boot","com/stencyl/models/GameModel.hx",47,0xc159a9bb)
HX_LOCAL_STACK_FRAME(_hx_pos_30a5a0001bfa47c1_48_boot,"com.stencyl.models.GameModel","boot",0xdadde81e,"com.stencyl.models.GameModel.boot","com/stencyl/models/GameModel.hx",48,0xc159a9bb)
namespace com{
namespace stencyl{
namespace models{

void GameModel_obj::__construct(){
            	HX_GC_STACKFRAME(&_hx_pos_30a5a0001bfa47c1_61_new)
HXLINE(  62)		 ::com::stencyl::io::mbs::game::MbsGame mg = ( ( ::com::stencyl::io::mbs::game::MbsGame)(::com::stencyl::Data_obj::get()->gameMbs->getRoot()) );
HXLINE(  64)		this->shapes = this->readShapes(mg);
HXLINE(  65)		this->atlases = this->readAtlases(mg);
HXLINE(  66)		this->autotileFormats = this->readAutotileFormats(mg);
HXLINE(  68)		this->groups = this->readGroups(mg);
HXLINE(  69)		::Array< ::Dynamic> _hx_tmp = this->groups;
HXDLIN(  69)		_hx_tmp->push( ::com::stencyl::models::GroupDef_obj::__alloc( HX_CTX ,(int)-2,HX_("Regions",df,3c,ed,47)));
HXLINE(  70)		::Array< ::Dynamic> _hx_tmp1 = this->groups;
HXDLIN(  70)		_hx_tmp1->push( ::com::stencyl::models::GroupDef_obj::__alloc( HX_CTX ,(int)0,HX_("Players",d2,31,66,57)));
HXLINE(  71)		::Array< ::Dynamic> _hx_tmp2 = this->groups;
HXDLIN(  71)		_hx_tmp2->push( ::com::stencyl::models::GroupDef_obj::__alloc( HX_CTX ,(int)1,HX_("Terrain",95,d3,68,f6)));
HXLINE(  72)		::Array< ::Dynamic> _hx_tmp3 = this->groups;
HXDLIN(  72)		_hx_tmp3->push( ::com::stencyl::models::GroupDef_obj::__alloc( HX_CTX ,(int)2,HX_("Doodads",b0,44,2e,99)));
HXLINE(  73)		::Array< ::Dynamic> _hx_tmp4 = this->groups;
HXDLIN(  73)		_hx_tmp4->push( ::com::stencyl::models::GroupDef_obj::__alloc( HX_CTX ,(int)3,HX_("Actors",fe,3f,df,4a)));
HXLINE(  77)		this->groupsCollidesWith =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXLINE(  79)		this->collisionGroups = this->readCollisionGroups(mg);
HXLINE(  81)		::com::stencyl::models::GameModel_obj::collisionMap = ::Array_obj< ::Dynamic>::__new();
HXLINE(  83)		int groupCount = (int)0;
HXLINE(  85)		{
HXLINE(  85)			int _g = (int)0;
HXDLIN(  85)			::Array< ::Dynamic> _g1 = this->groups;
HXDLIN(  85)			while((_g < _g1->length)){
HXLINE(  85)				 ::com::stencyl::models::GroupDef g = _g1->__get(_g).StaticCast<  ::com::stencyl::models::GroupDef >();
HXDLIN(  85)				_g = (_g + (int)1);
HXLINE(  87)				groupCount = ::Std_obj::_hx_int(::Math_obj::max(::Std_obj::_hx_int(g->ID),groupCount));
            			}
            		}
HXLINE(  90)		groupCount = (groupCount + (int)1);
HXLINE(  92)		{
HXLINE(  92)			int _g11 = (int)0;
HXDLIN(  92)			int _g2 = groupCount;
HXDLIN(  92)			while((_g11 < _g2)){
HXLINE(  92)				_g11 = (_g11 + (int)1);
HXDLIN(  92)				int i = (_g11 - (int)1);
HXLINE(  94)				::Array< ::Dynamic> _hx_tmp5 = ::com::stencyl::models::GameModel_obj::collisionMap;
HXDLIN(  94)				_hx_tmp5->push(::Array_obj< bool >::__new());
HXLINE(  96)				{
HXLINE(  96)					int _g3 = (int)0;
HXDLIN(  96)					int _g21 = groupCount;
HXDLIN(  96)					while((_g3 < _g21)){
HXLINE(  96)						_g3 = (_g3 + (int)1);
HXDLIN(  96)						int j = (_g3 - (int)1);
HXLINE(  98)						::com::stencyl::models::GameModel_obj::collisionMap->__get(i).StaticCast< ::Array< bool > >()->push(false);
            					}
            				}
            			}
            		}
HXLINE( 102)		if (::com::stencyl::Engine_obj::NO_PHYSICS) {
HXLINE( 104)			int _g4 = (int)0;
HXDLIN( 104)			::Array< ::Dynamic> _g12 = this->groups;
HXDLIN( 104)			while((_g4 < _g12->length)){
HXLINE( 104)				 ::com::stencyl::models::GroupDef g1 = _g12->__get(_g4).StaticCast<  ::com::stencyl::models::GroupDef >();
HXDLIN( 104)				_g4 = (_g4 + (int)1);
HXLINE( 106)				::Array< ::Dynamic> _hx_tmp6 = this->collisionGroups;
HXDLIN( 106)				_hx_tmp6->push( ::com::stencyl::models::CollisionGroupDef_obj::__alloc( HX_CTX ,g1->ID,(int)-2));
            			}
            		}
HXLINE( 110)		{
HXLINE( 110)			int _g5 = (int)0;
HXDLIN( 110)			::Array< ::Dynamic> _g13 = this->collisionGroups;
HXDLIN( 110)			while((_g5 < _g13->length)){
HXLINE( 110)				 ::com::stencyl::models::CollisionGroupDef cg = _g13->__get(_g5).StaticCast<  ::com::stencyl::models::CollisionGroupDef >();
HXDLIN( 110)				_g5 = (_g5 + (int)1);
HXLINE( 112)				int g11 = cg->group1;
HXLINE( 113)				int g2 = cg->group2;
HXLINE( 115)				if (!(this->groupsCollidesWith->exists(g11))) {
HXLINE( 117)					::Dynamic this1 = this->groupsCollidesWith;
HXDLIN( 117)					( ( ::haxe::ds::IntMap)(this1) )->set(g11,::Array_obj< int >::__new());
            				}
HXLINE( 120)				if (!(this->groupsCollidesWith->exists(g2))) {
HXLINE( 122)					::Dynamic this2 = this->groupsCollidesWith;
HXDLIN( 122)					( ( ::haxe::ds::IntMap)(this2) )->set(g2,::Array_obj< int >::__new());
            				}
HXLINE( 125)				bool _hx_tmp7;
HXDLIN( 125)				if (!(!(::com::stencyl::Engine_obj::NO_PHYSICS))) {
HXLINE( 125)					if ((g11 >= (int)0)) {
HXLINE( 125)						_hx_tmp7 = (g2 >= (int)0);
            					}
            					else {
HXLINE( 125)						_hx_tmp7 = false;
            					}
            				}
            				else {
HXLINE( 125)					_hx_tmp7 = true;
            				}
HXDLIN( 125)				if (_hx_tmp7) {
HXLINE( 127)					::com::stencyl::models::GameModel_obj::collisionMap->__get(g11).StaticCast< ::Array< bool > >()[g2] = true;
HXLINE( 128)					::com::stencyl::models::GameModel_obj::collisionMap->__get(g2).StaticCast< ::Array< bool > >()[g11] = true;
            				}
HXLINE( 131)				( (::Array< int >)(this->groupsCollidesWith->get(g11)) )->push(g2);
HXLINE( 132)				( (::Array< int >)(this->groupsCollidesWith->get(g2)) )->push(g11);
            			}
            		}
HXLINE( 140)		this->gameAttributes = ::com::stencyl::models::GameModel_obj::readGameAttributes(mg);
HXLINE( 142)		::com::stencyl::Data_obj::get()->gameMbs = null();
            	}

Dynamic GameModel_obj::__CreateEmpty() { return new GameModel_obj; }

void *GameModel_obj::_hx_vtable = 0;

Dynamic GameModel_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< GameModel_obj > _hx_result = new GameModel_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool GameModel_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x20f00262;
}

void GameModel_obj::loadScenes(){
            	HX_GC_STACKFRAME(&_hx_pos_30a5a0001bfa47c1_146_loadScenes)
HXLINE( 147)		this->scenes =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXLINE( 149)		 ::mbs::io::MbsList list = ( ( ::mbs::io::MbsList)(::com::stencyl::Data_obj::get()->sceneListMbs->getRoot()) );
HXLINE( 150)		{
HXLINE( 150)			int _g1 = (int)0;
HXDLIN( 150)			int _g = list->length();
HXDLIN( 150)			while((_g1 < _g)){
HXLINE( 150)				_g1 = (_g1 + (int)1);
HXDLIN( 150)				int i = (_g1 - (int)1);
HXLINE( 152)				 ::com::stencyl::io::mbs::scene::MbsSceneHeader header = list->getNextObject().StaticCast<  ::com::stencyl::io::mbs::scene::MbsSceneHeader >();
HXLINE( 153)				int sceneID = header->getId();
HXLINE( 155)				{
HXLINE( 155)					::Dynamic this1 = this->scenes;
HXDLIN( 155)					( ( ::haxe::ds::IntMap)(this1) )->set(sceneID, ::com::stencyl::models::Scene_obj::__alloc( HX_CTX ,sceneID,header->getName()));
            				}
            			}
            		}
HXLINE( 158)		::com::stencyl::Data_obj::get()->sceneListMbs = null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(GameModel_obj,loadScenes,(void))

 ::haxe::ds::IntMap GameModel_obj::readShapes( ::com::stencyl::io::mbs::game::MbsGame mg){
            	HX_GC_STACKFRAME(&_hx_pos_30a5a0001bfa47c1_162_readShapes)
HXLINE( 163)		 ::haxe::ds::IntMap map =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXLINE( 165)		 ::mbs::io::MbsList list = mg->getShapes();
HXLINE( 167)		{
HXLINE( 167)			int _g1 = (int)0;
HXDLIN( 167)			int _g = list->length();
HXDLIN( 167)			while((_g1 < _g)){
HXLINE( 167)				_g1 = (_g1 + (int)1);
HXDLIN( 167)				int i = (_g1 - (int)1);
HXLINE( 169)				 ::com::stencyl::io::mbs::game::MbsCollisionShape colShape = list->getNextObject().StaticCast<  ::com::stencyl::io::mbs::game::MbsCollisionShape >();
HXLINE( 170)				 ::mbs::io::MbsList ptList = colShape->getPoints();
HXLINE( 172)				::Array< ::Dynamic> vertices = ::Array_obj< ::Dynamic>::__new();
HXLINE( 174)				{
HXLINE( 174)					int _g2 = (int)0;
HXDLIN( 174)					::Array< ::Dynamic> _g3 = ::com::stencyl::io::ShapeReader_obj::readPoints(ptList);
HXDLIN( 174)					while((_g2 < _g3->length)){
HXLINE( 174)						 ::openfl::geom::Point pt = ( ( ::openfl::geom::Point)(_hx_array_unsafe_get(_g3,_g2)) );
HXDLIN( 174)						_g2 = (_g2 + (int)1);
HXLINE( 176)						Float _hx_tmp = (pt->x * ((Float)3.1));
HXDLIN( 176)						vertices->push( ::box2D::common::math::B2Vec2_obj::__alloc( HX_CTX ,_hx_tmp,(pt->y * ((Float)3.1))));
            					}
            				}
HXLINE( 179)				::com::stencyl::io::ShapeReader_obj::EnsureCorrectVertexDirection(vertices);
HXLINE( 181)				 ::box2D::collision::shapes::B2PolygonShape p =  ::box2D::collision::shapes::B2PolygonShape_obj::__alloc( HX_CTX );
HXLINE( 182)				p->setAsArray(vertices,vertices->length);
HXLINE( 183)				map->set(colShape->getId(),p);
            			}
            		}
HXLINE( 186)		return map;
            	}


HX_DEFINE_DYNAMIC_FUNC1(GameModel_obj,readShapes,return )

 ::haxe::ds::IntMap GameModel_obj::readAtlases( ::com::stencyl::io::mbs::game::MbsGame mg){
            	HX_GC_STACKFRAME(&_hx_pos_30a5a0001bfa47c1_190_readAtlases)
HXLINE( 191)		 ::haxe::ds::IntMap map =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXLINE( 193)		 ::mbs::io::MbsList list = mg->getAtlases();
HXLINE( 195)		{
HXLINE( 195)			int _g1 = (int)0;
HXDLIN( 195)			int _g = list->length();
HXDLIN( 195)			while((_g1 < _g)){
HXLINE( 195)				_g1 = (_g1 + (int)1);
HXDLIN( 195)				int i = (_g1 - (int)1);
HXLINE( 197)				 ::com::stencyl::io::mbs::game::MbsAtlas atlas = list->getNextObject().StaticCast<  ::com::stencyl::io::mbs::game::MbsAtlas >();
HXLINE( 198)				int ID = atlas->getId();
HXLINE( 199)				::String name = atlas->getName();
HXLINE( 200)				bool allScenes = atlas->getAllScenes();
HXLINE( 202)				 ::mbs::io::MbsIntList memList = atlas->getMembers();
HXLINE( 203)				::Array< int > _g2 = ::Array_obj< int >::__new(0);
HXDLIN( 203)				{
HXLINE( 203)					int _g4 = (int)0;
HXDLIN( 203)					int _g3 = memList->length();
HXDLIN( 203)					while((_g4 < _g3)){
HXLINE( 203)						_g4 = (_g4 + (int)1);
HXDLIN( 203)						int j = (_g4 - (int)1);
HXDLIN( 203)						_g2->push(memList->readInt());
            					}
            				}
HXDLIN( 203)				::Array< int > members = _g2;
HXLINE( 205)				map->set(ID, ::com::stencyl::models::Atlas_obj::__alloc( HX_CTX ,ID,name,allScenes,members));
            			}
            		}
HXLINE( 208)		return map;
            	}


HX_DEFINE_DYNAMIC_FUNC1(GameModel_obj,readAtlases,return )

 ::haxe::ds::IntMap GameModel_obj::readAutotileFormats( ::com::stencyl::io::mbs::game::MbsGame mg){
            	HX_GC_STACKFRAME(&_hx_pos_30a5a0001bfa47c1_212_readAutotileFormats)
HXLINE( 213)		 ::haxe::ds::IntMap map =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXLINE( 215)		 ::mbs::io::MbsList list = mg->getAutotileFormats();
HXLINE( 217)		{
HXLINE( 217)			int _g1 = (int)0;
HXDLIN( 217)			int _g = list->length();
HXDLIN( 217)			while((_g1 < _g)){
HXLINE( 217)				_g1 = (_g1 + (int)1);
HXDLIN( 217)				int i = (_g1 - (int)1);
HXLINE( 219)				 ::com::stencyl::io::mbs::game::autotile::MbsAutotileFormat atf = list->getNextObject().StaticCast<  ::com::stencyl::io::mbs::game::autotile::MbsAutotileFormat >();
HXLINE( 220)				::String name = atf->getName();
HXLINE( 221)				int id = atf->getId();
HXLINE( 222)				int across = atf->getAcross();
HXLINE( 223)				int down = atf->getDown();
HXLINE( 225)				::Array< ::Dynamic> allCorners = ::Array_obj< ::Dynamic>::__new();
HXLINE( 226)				::Array< ::Dynamic> cornersMap = ::Array_obj< ::Dynamic>::__new();
HXLINE( 228)				 ::mbs::io::MbsList cornersList = atf->getCorners();
HXLINE( 230)				{
HXLINE( 230)					int _g3 = (int)0;
HXDLIN( 230)					int _g2 = cornersList->length();
HXDLIN( 230)					while((_g3 < _g2)){
HXLINE( 230)						_g3 = (_g3 + (int)1);
HXDLIN( 230)						int cornersIndex = (_g3 - (int)1);
HXLINE( 232)						 ::com::stencyl::io::mbs::game::autotile::MbsCorners mbsCorners = cornersList->getNextObject().StaticCast<  ::com::stencyl::io::mbs::game::autotile::MbsCorners >();
HXLINE( 236)						 ::com::stencyl::io::mbs::shape::MbsPoint r = mbsCorners->getTopLeft();
HXDLIN( 236)						Float _hx_tmp = r->getX();
HXDLIN( 236)						 ::openfl::geom::Point _hx_tmp1 =  ::openfl::geom::Point_obj::__alloc( HX_CTX ,_hx_tmp,r->getY());
HXLINE( 237)						 ::com::stencyl::io::mbs::shape::MbsPoint r1 = mbsCorners->getTopRight();
HXDLIN( 237)						Float _hx_tmp2 = r1->getX();
HXDLIN( 237)						 ::openfl::geom::Point _hx_tmp3 =  ::openfl::geom::Point_obj::__alloc( HX_CTX ,_hx_tmp2,r1->getY());
HXLINE( 238)						 ::com::stencyl::io::mbs::shape::MbsPoint r2 = mbsCorners->getBottomLeft();
HXDLIN( 238)						Float _hx_tmp4 = r2->getX();
HXDLIN( 238)						 ::openfl::geom::Point _hx_tmp5 =  ::openfl::geom::Point_obj::__alloc( HX_CTX ,_hx_tmp4,r2->getY());
HXLINE( 239)						 ::com::stencyl::io::mbs::shape::MbsPoint r3 = mbsCorners->getBottomRight();
HXDLIN( 239)						Float _hx_tmp6 = r3->getX();
HXLINE( 234)						cornersMap->push( ::com::stencyl::models::scene::Corners_obj::__alloc( HX_CTX ,_hx_tmp1,_hx_tmp3,_hx_tmp5, ::openfl::geom::Point_obj::__alloc( HX_CTX ,_hx_tmp6,r3->getY())));
            					}
            				}
HXLINE( 243)				 ::mbs::io::MbsIntList mbsFlags = atf->getFlags();
HXLINE( 245)				{
HXLINE( 245)					int _g31 = (int)0;
HXDLIN( 245)					int _g21 = mbsFlags->length();
HXDLIN( 245)					while((_g31 < _g21)){
HXLINE( 245)						_g31 = (_g31 + (int)1);
HXDLIN( 245)						int fi = (_g31 - (int)1);
HXLINE( 247)						allCorners[fi] = cornersMap->__get(mbsFlags->readInt()).StaticCast<  ::com::stencyl::models::scene::Corners >();
            					}
            				}
HXLINE( 250)				map->set(id, ::com::stencyl::models::scene::AutotileFormat_obj::__alloc( HX_CTX ,name,id,across,down,allCorners));
            			}
            		}
HXLINE( 253)		return map;
            	}


HX_DEFINE_DYNAMIC_FUNC1(GameModel_obj,readAutotileFormats,return )

::Array< ::Dynamic> GameModel_obj::readGroups( ::com::stencyl::io::mbs::game::MbsGame mg){
            	HX_GC_STACKFRAME(&_hx_pos_30a5a0001bfa47c1_257_readGroups)
HXLINE( 258)		::Array< ::Dynamic> map = ::Array_obj< ::Dynamic>::__new();
HXLINE( 260)		 ::mbs::io::MbsList list = mg->getGroups();
HXLINE( 262)		{
HXLINE( 262)			int _g1 = (int)0;
HXDLIN( 262)			int _g = list->length();
HXDLIN( 262)			while((_g1 < _g)){
HXLINE( 262)				_g1 = (_g1 + (int)1);
HXDLIN( 262)				int i = (_g1 - (int)1);
HXLINE( 264)				 ::com::stencyl::io::mbs::game::MbsCollisionGroup group = list->getNextObject().StaticCast<  ::com::stencyl::io::mbs::game::MbsCollisionGroup >();
HXLINE( 265)				int _hx_tmp = group->getId();
HXDLIN( 265)				map->push( ::com::stencyl::models::GroupDef_obj::__alloc( HX_CTX ,_hx_tmp,group->getName()));
            			}
            		}
HXLINE( 268)		return map;
            	}


HX_DEFINE_DYNAMIC_FUNC1(GameModel_obj,readGroups,return )

::Array< ::Dynamic> GameModel_obj::readCollisionGroups( ::com::stencyl::io::mbs::game::MbsGame mg){
            	HX_GC_STACKFRAME(&_hx_pos_30a5a0001bfa47c1_272_readCollisionGroups)
HXLINE( 273)		::Array< ::Dynamic> map = ::Array_obj< ::Dynamic>::__new();
HXLINE( 275)		 ::mbs::io::MbsList list = mg->getCgroups();
HXLINE( 277)		{
HXLINE( 277)			int _g1 = (int)0;
HXDLIN( 277)			int _g = list->length();
HXDLIN( 277)			while((_g1 < _g)){
HXLINE( 277)				_g1 = (_g1 + (int)1);
HXDLIN( 277)				int i = (_g1 - (int)1);
HXLINE( 279)				 ::com::stencyl::io::mbs::game::MbsCollisionPair cpair = list->getNextObject().StaticCast<  ::com::stencyl::io::mbs::game::MbsCollisionPair >();
HXLINE( 280)				int _hx_tmp = cpair->getGroup1();
HXDLIN( 280)				map->push( ::com::stencyl::models::CollisionGroupDef_obj::__alloc( HX_CTX ,_hx_tmp,cpair->getGroup2()));
            			}
            		}
HXLINE( 283)		return map;
            	}


HX_DEFINE_DYNAMIC_FUNC1(GameModel_obj,readCollisionGroups,return )

 ::com::stencyl::models::GameModel GameModel_obj::instance;

void GameModel_obj::resetStatics(){
            	HX_STACKFRAME(&_hx_pos_30a5a0001bfa47c1_27_resetStatics)
HXLINE(  28)		::com::stencyl::models::GameModel_obj::instance = null();
HXLINE(  29)		::com::stencyl::models::GameModel_obj::collisionMap = null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(GameModel_obj,resetStatics,(void))

::Array< ::Dynamic> GameModel_obj::collisionMap;

int GameModel_obj::INHERIT_ID;

int GameModel_obj::REGION_ID;

int GameModel_obj::PLAYER_ID;

int GameModel_obj::TERRAIN_ID;

int GameModel_obj::DOODAD_ID;

int GameModel_obj::ACTOR_ID;

 ::com::stencyl::models::GameModel GameModel_obj::get(){
            	HX_GC_STACKFRAME(&_hx_pos_30a5a0001bfa47c1_51_get)
HXLINE(  52)		if (hx::IsNull( ::com::stencyl::models::GameModel_obj::instance )) {
HXLINE(  54)			::com::stencyl::models::GameModel_obj::instance =  ::com::stencyl::models::GameModel_obj::__alloc( HX_CTX );
            		}
HXLINE(  57)		return ::com::stencyl::models::GameModel_obj::instance;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(GameModel_obj,get,return )

 ::haxe::ds::StringMap GameModel_obj::readGameAttributes( ::com::stencyl::io::mbs::game::MbsGame mg){
            	HX_STACKFRAME(&_hx_pos_30a5a0001bfa47c1_288_readGameAttributes)
HXDLIN( 288)		return ::com::stencyl::io::AttributeValues_obj::readMap(mg->getGameAttributes());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(GameModel_obj,readGameAttributes,return )


hx::ObjectPtr< GameModel_obj > GameModel_obj::__new() {
	hx::ObjectPtr< GameModel_obj > __this = new GameModel_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< GameModel_obj > GameModel_obj::__alloc(hx::Ctx *_hx_ctx) {
	GameModel_obj *__this = (GameModel_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(GameModel_obj), true, "com.stencyl.models.GameModel"));
	*(void **)__this = GameModel_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

GameModel_obj::GameModel_obj()
{
}

void GameModel_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(GameModel);
	HX_MARK_MEMBER_NAME(groups,"groups");
	HX_MARK_MEMBER_NAME(groupsCollidesWith,"groupsCollidesWith");
	HX_MARK_MEMBER_NAME(collisionGroups,"collisionGroups");
	HX_MARK_MEMBER_NAME(gameAttributes,"gameAttributes");
	HX_MARK_MEMBER_NAME(shapes,"shapes");
	HX_MARK_MEMBER_NAME(atlases,"atlases");
	HX_MARK_MEMBER_NAME(scenes,"scenes");
	HX_MARK_MEMBER_NAME(autotileFormats,"autotileFormats");
	HX_MARK_END_CLASS();
}

void GameModel_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(groups,"groups");
	HX_VISIT_MEMBER_NAME(groupsCollidesWith,"groupsCollidesWith");
	HX_VISIT_MEMBER_NAME(collisionGroups,"collisionGroups");
	HX_VISIT_MEMBER_NAME(gameAttributes,"gameAttributes");
	HX_VISIT_MEMBER_NAME(shapes,"shapes");
	HX_VISIT_MEMBER_NAME(atlases,"atlases");
	HX_VISIT_MEMBER_NAME(scenes,"scenes");
	HX_VISIT_MEMBER_NAME(autotileFormats,"autotileFormats");
}

hx::Val GameModel_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"groups") ) { return hx::Val( groups ); }
		if (HX_FIELD_EQ(inName,"shapes") ) { return hx::Val( shapes ); }
		if (HX_FIELD_EQ(inName,"scenes") ) { return hx::Val( scenes ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"atlases") ) { return hx::Val( atlases ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"loadScenes") ) { return hx::Val( loadScenes_dyn() ); }
		if (HX_FIELD_EQ(inName,"readShapes") ) { return hx::Val( readShapes_dyn() ); }
		if (HX_FIELD_EQ(inName,"readGroups") ) { return hx::Val( readGroups_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"readAtlases") ) { return hx::Val( readAtlases_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"gameAttributes") ) { return hx::Val( gameAttributes ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"collisionGroups") ) { return hx::Val( collisionGroups ); }
		if (HX_FIELD_EQ(inName,"autotileFormats") ) { return hx::Val( autotileFormats ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"groupsCollidesWith") ) { return hx::Val( groupsCollidesWith ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"readAutotileFormats") ) { return hx::Val( readAutotileFormats_dyn() ); }
		if (HX_FIELD_EQ(inName,"readCollisionGroups") ) { return hx::Val( readCollisionGroups_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool GameModel_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"get") ) { outValue = get_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"instance") ) { outValue = ( instance ); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"resetStatics") ) { outValue = resetStatics_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"collisionMap") ) { outValue = ( collisionMap ); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"readGameAttributes") ) { outValue = readGameAttributes_dyn(); return true; }
	}
	return false;
}

hx::Val GameModel_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"groups") ) { groups=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"shapes") ) { shapes=inValue.Cast<  ::haxe::ds::IntMap >(); return inValue; }
		if (HX_FIELD_EQ(inName,"scenes") ) { scenes=inValue.Cast<  ::haxe::ds::IntMap >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"atlases") ) { atlases=inValue.Cast<  ::haxe::ds::IntMap >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"gameAttributes") ) { gameAttributes=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"collisionGroups") ) { collisionGroups=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"autotileFormats") ) { autotileFormats=inValue.Cast<  ::haxe::ds::IntMap >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"groupsCollidesWith") ) { groupsCollidesWith=inValue.Cast<  ::haxe::ds::IntMap >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool GameModel_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"instance") ) { instance=ioValue.Cast<  ::com::stencyl::models::GameModel >(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"collisionMap") ) { collisionMap=ioValue.Cast< ::Array< ::Dynamic> >(); return true; }
	}
	return false;
}

void GameModel_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("groups","\x54","\x24","\x28","\x1c"));
	outFields->push(HX_HCSTRING("groupsCollidesWith","\x4f","\x5e","\xc9","\x66"));
	outFields->push(HX_HCSTRING("collisionGroups","\x66","\x22","\xf4","\xed"));
	outFields->push(HX_HCSTRING("gameAttributes","\x69","\xc3","\x10","\x26"));
	outFields->push(HX_HCSTRING("shapes","\x32","\xda","\x29","\x1d"));
	outFields->push(HX_HCSTRING("atlases","\x79","\xce","\xc3","\x92"));
	outFields->push(HX_HCSTRING("scenes","\xa7","\x49","\xcc","\x3e"));
	outFields->push(HX_HCSTRING("autotileFormats","\xbf","\x08","\x5b","\x08"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo GameModel_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(GameModel_obj,groups),HX_HCSTRING("groups","\x54","\x24","\x28","\x1c")},
	{hx::fsObject /*::haxe::ds::IntMap*/ ,(int)offsetof(GameModel_obj,groupsCollidesWith),HX_HCSTRING("groupsCollidesWith","\x4f","\x5e","\xc9","\x66")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(GameModel_obj,collisionGroups),HX_HCSTRING("collisionGroups","\x66","\x22","\xf4","\xed")},
	{hx::fsObject /*::haxe::ds::StringMap*/ ,(int)offsetof(GameModel_obj,gameAttributes),HX_HCSTRING("gameAttributes","\x69","\xc3","\x10","\x26")},
	{hx::fsObject /*::haxe::ds::IntMap*/ ,(int)offsetof(GameModel_obj,shapes),HX_HCSTRING("shapes","\x32","\xda","\x29","\x1d")},
	{hx::fsObject /*::haxe::ds::IntMap*/ ,(int)offsetof(GameModel_obj,atlases),HX_HCSTRING("atlases","\x79","\xce","\xc3","\x92")},
	{hx::fsObject /*::haxe::ds::IntMap*/ ,(int)offsetof(GameModel_obj,scenes),HX_HCSTRING("scenes","\xa7","\x49","\xcc","\x3e")},
	{hx::fsObject /*::haxe::ds::IntMap*/ ,(int)offsetof(GameModel_obj,autotileFormats),HX_HCSTRING("autotileFormats","\xbf","\x08","\x5b","\x08")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo GameModel_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*::com::stencyl::models::GameModel*/ ,(void *) &GameModel_obj::instance,HX_HCSTRING("instance","\x95","\x1f","\xe1","\x59")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(void *) &GameModel_obj::collisionMap,HX_HCSTRING("collisionMap","\x4a","\x6d","\x73","\xbc")},
	{hx::fsInt,(void *) &GameModel_obj::INHERIT_ID,HX_HCSTRING("INHERIT_ID","\xff","\x78","\x95","\x6f")},
	{hx::fsInt,(void *) &GameModel_obj::REGION_ID,HX_HCSTRING("REGION_ID","\x86","\x79","\xec","\x64")},
	{hx::fsInt,(void *) &GameModel_obj::PLAYER_ID,HX_HCSTRING("PLAYER_ID","\x39","\xd1","\x42","\xfc")},
	{hx::fsInt,(void *) &GameModel_obj::TERRAIN_ID,HX_HCSTRING("TERRAIN_ID","\x85","\x01","\xd3","\xd0")},
	{hx::fsInt,(void *) &GameModel_obj::DOODAD_ID,HX_HCSTRING("DOODAD_ID","\x97","\xd7","\x5b","\x4e")},
	{hx::fsInt,(void *) &GameModel_obj::ACTOR_ID,HX_HCSTRING("ACTOR_ID","\x45","\x06","\x0b","\xb1")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String GameModel_obj_sMemberFields[] = {
	HX_HCSTRING("groups","\x54","\x24","\x28","\x1c"),
	HX_HCSTRING("groupsCollidesWith","\x4f","\x5e","\xc9","\x66"),
	HX_HCSTRING("collisionGroups","\x66","\x22","\xf4","\xed"),
	HX_HCSTRING("gameAttributes","\x69","\xc3","\x10","\x26"),
	HX_HCSTRING("shapes","\x32","\xda","\x29","\x1d"),
	HX_HCSTRING("atlases","\x79","\xce","\xc3","\x92"),
	HX_HCSTRING("scenes","\xa7","\x49","\xcc","\x3e"),
	HX_HCSTRING("autotileFormats","\xbf","\x08","\x5b","\x08"),
	HX_HCSTRING("loadScenes","\x6d","\x78","\xf7","\xf3"),
	HX_HCSTRING("readShapes","\x28","\xbe","\xa5","\x16"),
	HX_HCSTRING("readAtlases","\xc3","\x61","\xaf","\xe5"),
	HX_HCSTRING("readAutotileFormats","\x09","\xf6","\x59","\x57"),
	HX_HCSTRING("readGroups","\x4a","\x08","\xa4","\x15"),
	HX_HCSTRING("readCollisionGroups","\xb0","\x0f","\xf3","\x3c"),
	::String(null()) };

static void GameModel_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(GameModel_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(GameModel_obj::instance,"instance");
	HX_MARK_MEMBER_NAME(GameModel_obj::collisionMap,"collisionMap");
	HX_MARK_MEMBER_NAME(GameModel_obj::INHERIT_ID,"INHERIT_ID");
	HX_MARK_MEMBER_NAME(GameModel_obj::REGION_ID,"REGION_ID");
	HX_MARK_MEMBER_NAME(GameModel_obj::PLAYER_ID,"PLAYER_ID");
	HX_MARK_MEMBER_NAME(GameModel_obj::TERRAIN_ID,"TERRAIN_ID");
	HX_MARK_MEMBER_NAME(GameModel_obj::DOODAD_ID,"DOODAD_ID");
	HX_MARK_MEMBER_NAME(GameModel_obj::ACTOR_ID,"ACTOR_ID");
};

#ifdef HXCPP_VISIT_ALLOCS
static void GameModel_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(GameModel_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(GameModel_obj::instance,"instance");
	HX_VISIT_MEMBER_NAME(GameModel_obj::collisionMap,"collisionMap");
	HX_VISIT_MEMBER_NAME(GameModel_obj::INHERIT_ID,"INHERIT_ID");
	HX_VISIT_MEMBER_NAME(GameModel_obj::REGION_ID,"REGION_ID");
	HX_VISIT_MEMBER_NAME(GameModel_obj::PLAYER_ID,"PLAYER_ID");
	HX_VISIT_MEMBER_NAME(GameModel_obj::TERRAIN_ID,"TERRAIN_ID");
	HX_VISIT_MEMBER_NAME(GameModel_obj::DOODAD_ID,"DOODAD_ID");
	HX_VISIT_MEMBER_NAME(GameModel_obj::ACTOR_ID,"ACTOR_ID");
};

#endif

hx::Class GameModel_obj::__mClass;

static ::String GameModel_obj_sStaticFields[] = {
	HX_HCSTRING("instance","\x95","\x1f","\xe1","\x59"),
	HX_HCSTRING("resetStatics","\xf6","\x81","\x43","\xa8"),
	HX_HCSTRING("collisionMap","\x4a","\x6d","\x73","\xbc"),
	HX_HCSTRING("INHERIT_ID","\xff","\x78","\x95","\x6f"),
	HX_HCSTRING("REGION_ID","\x86","\x79","\xec","\x64"),
	HX_HCSTRING("PLAYER_ID","\x39","\xd1","\x42","\xfc"),
	HX_HCSTRING("TERRAIN_ID","\x85","\x01","\xd3","\xd0"),
	HX_HCSTRING("DOODAD_ID","\x97","\xd7","\x5b","\x4e"),
	HX_HCSTRING("ACTOR_ID","\x45","\x06","\x0b","\xb1"),
	HX_HCSTRING("get","\x96","\x80","\x4e","\x00"),
	HX_HCSTRING("readGameAttributes","\x5f","\x8d","\xa2","\x56"),
	::String(null())
};

void GameModel_obj::__register()
{
	hx::Object *dummy = new GameModel_obj;
	GameModel_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("com.stencyl.models.GameModel","\x02","\x84","\x84","\xec");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &GameModel_obj::__GetStatic;
	__mClass->mSetStaticField = &GameModel_obj::__SetStatic;
	__mClass->mMarkFunc = GameModel_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(GameModel_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(GameModel_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< GameModel_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = GameModel_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = GameModel_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = GameModel_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void GameModel_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_30a5a0001bfa47c1_43_boot)
HXDLIN(  43)		INHERIT_ID = (int)-1000;
            	}
{
            	HX_STACKFRAME(&_hx_pos_30a5a0001bfa47c1_44_boot)
HXDLIN(  44)		REGION_ID = (int)-2;
            	}
{
            	HX_STACKFRAME(&_hx_pos_30a5a0001bfa47c1_45_boot)
HXDLIN(  45)		PLAYER_ID = (int)0;
            	}
{
            	HX_STACKFRAME(&_hx_pos_30a5a0001bfa47c1_46_boot)
HXDLIN(  46)		TERRAIN_ID = (int)1;
            	}
{
            	HX_STACKFRAME(&_hx_pos_30a5a0001bfa47c1_47_boot)
HXDLIN(  47)		DOODAD_ID = (int)2;
            	}
{
            	HX_STACKFRAME(&_hx_pos_30a5a0001bfa47c1_48_boot)
HXDLIN(  48)		ACTOR_ID = (int)3;
            	}
}

} // end namespace com
} // end namespace stencyl
} // end namespace models
