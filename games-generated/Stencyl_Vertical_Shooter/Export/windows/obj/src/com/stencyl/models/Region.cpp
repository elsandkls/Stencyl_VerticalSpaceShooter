// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_box2D_collision_B2AABB
#include <box2D/collision/B2AABB.h>
#endif
#ifndef INCLUDED_box2D_collision_shapes_B2CircleShape
#include <box2D/collision/shapes/B2CircleShape.h>
#endif
#ifndef INCLUDED_box2D_collision_shapes_B2PolygonShape
#include <box2D/collision/shapes/B2PolygonShape.h>
#endif
#ifndef INCLUDED_box2D_collision_shapes_B2Shape
#include <box2D/collision/shapes/B2Shape.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Mat22
#include <box2D/common/math/B2Mat22.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Transform
#include <box2D/common/math/B2Transform.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Vec2
#include <box2D/common/math/B2Vec2.h>
#endif
#ifndef INCLUDED_box2D_dynamics_B2Body
#include <box2D/dynamics/B2Body.h>
#endif
#ifndef INCLUDED_box2D_dynamics_B2BodyDef
#include <box2D/dynamics/B2BodyDef.h>
#endif
#ifndef INCLUDED_box2D_dynamics_B2Fixture
#include <box2D/dynamics/B2Fixture.h>
#endif
#ifndef INCLUDED_box2D_dynamics_B2FixtureDef
#include <box2D/dynamics/B2FixtureDef.h>
#endif
#ifndef INCLUDED_com_stencyl_Engine
#include <com/stencyl/Engine.h>
#endif
#ifndef INCLUDED_com_stencyl_Input
#include <com/stencyl/Input.h>
#endif
#ifndef INCLUDED_com_stencyl_models_Actor
#include <com/stencyl/models/Actor.h>
#endif
#ifndef INCLUDED_com_stencyl_models_Region
#include <com/stencyl/models/Region.h>
#endif
#ifndef INCLUDED_com_stencyl_models_Resource
#include <com/stencyl/models/Resource.h>
#endif
#ifndef INCLUDED_com_stencyl_models_actor_ActorType
#include <com/stencyl/models/actor/ActorType.h>
#endif
#ifndef INCLUDED_com_stencyl_models_actor_Sprite
#include <com/stencyl/models/actor/Sprite.h>
#endif
#ifndef INCLUDED_com_stencyl_models_collision_Mask
#include <com/stencyl/models/collision/Mask.h>
#endif
#ifndef INCLUDED_com_stencyl_utils_Utils
#include <com/stencyl/utils/Utils.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_3db67d5c52bef819_45_new,"com.stencyl.models.Region","new",0xc69fefdb,"com.stencyl.models.Region.new","com/stencyl/models/Region.hx",45,0x60ad88d6)
HX_LOCAL_STACK_FRAME(_hx_pos_3db67d5c52bef819_148_containsActor,"com.stencyl.models.Region","containsActor",0xdf293791,"com.stencyl.models.Region.containsActor","com/stencyl/models/Region.hx",148,0x60ad88d6)
HX_LOCAL_STACK_FRAME(_hx_pos_3db67d5c52bef819_161_getContainedActors,"com.stencyl.models.Region","getContainedActors",0xa5b74060,"com.stencyl.models.Region.getContainedActors","com/stencyl/models/Region.hx",161,0x60ad88d6)
HX_LOCAL_STACK_FRAME(_hx_pos_3db67d5c52bef819_165_addActor,"com.stencyl.models.Region","addActor",0xb94cd3b9,"com.stencyl.models.Region.addActor","com/stencyl/models/Region.hx",165,0x60ad88d6)
HX_LOCAL_STACK_FRAME(_hx_pos_3db67d5c52bef819_190_removeActor,"com.stencyl.models.Region","removeActor",0xa1db3a8c,"com.stencyl.models.Region.removeActor","com/stencyl/models/Region.hx",190,0x60ad88d6)
HX_LOCAL_STACK_FRAME(_hx_pos_3db67d5c52bef819_209_follow,"com.stencyl.models.Region","follow",0xf9b510d6,"com.stencyl.models.Region.follow","com/stencyl/models/Region.hx",209,0x60ad88d6)
HX_LOCAL_STACK_FRAME(_hx_pos_3db67d5c52bef819_221_resetSize,"com.stencyl.models.Region","resetSize",0x2dbd17eb,"com.stencyl.models.Region.resetSize","com/stencyl/models/Region.hx",221,0x60ad88d6)
HX_LOCAL_STACK_FRAME(_hx_pos_3db67d5c52bef819_226_setRegionDiameter,"com.stencyl.models.Region","setRegionDiameter",0xedeaa7de,"com.stencyl.models.Region.setRegionDiameter","com/stencyl/models/Region.hx",226,0x60ad88d6)
HX_LOCAL_STACK_FRAME(_hx_pos_3db67d5c52bef819_230_setRegionSize,"com.stencyl.models.Region","setRegionSize",0x737dbd52,"com.stencyl.models.Region.setRegionSize","com/stencyl/models/Region.hx",230,0x60ad88d6)
HX_LOCAL_STACK_FRAME(_hx_pos_3db67d5c52bef819_280_setLocation,"com.stencyl.models.Region","setLocation",0x9da7ca72,"com.stencyl.models.Region.setLocation","com/stencyl/models/Region.hx",280,0x60ad88d6)
HX_LOCAL_STACK_FRAME(_hx_pos_3db67d5c52bef819_287_getWidth,"com.stencyl.models.Region","getWidth",0x4e82a835,"com.stencyl.models.Region.getWidth","com/stencyl/models/Region.hx",287,0x60ad88d6)
HX_LOCAL_STACK_FRAME(_hx_pos_3db67d5c52bef819_292_getHeight,"com.stencyl.models.Region","getHeight",0x1a1ffed8,"com.stencyl.models.Region.getHeight","com/stencyl/models/Region.hx",292,0x60ad88d6)
HX_LOCAL_STACK_FRAME(_hx_pos_3db67d5c52bef819_296_isMouseOver,"com.stencyl.models.Region","isMouseOver",0x5c8e934a,"com.stencyl.models.Region.isMouseOver","com/stencyl/models/Region.hx",296,0x60ad88d6)
HX_LOCAL_STACK_FRAME(_hx_pos_3db67d5c52bef819_313_innerUpdate,"com.stencyl.models.Region","innerUpdate",0x780512ba,"com.stencyl.models.Region.innerUpdate","com/stencyl/models/Region.hx",313,0x60ad88d6)
HX_LOCAL_STACK_FRAME(_hx_pos_3db67d5c52bef819_20_boot,"com.stencyl.models.Region","boot",0xfd6af057,"com.stencyl.models.Region.boot","com/stencyl/models/Region.hx",20,0x60ad88d6)
namespace com{
namespace stencyl{
namespace models{

void Region_obj::__construct( ::com::stencyl::Engine game,Float x,Float y,::Array< ::Dynamic> shapes, ::openfl::geom::Rectangle simpleBounds){
            	HX_GC_STACKFRAME(&_hx_pos_3db67d5c52bef819_45_new)
HXLINE(  46)		Float _hx_tmp;
HXDLIN(  46)		if (::com::stencyl::Engine_obj::NO_PHYSICS) {
HXLINE(  46)			_hx_tmp = simpleBounds->width;
            		}
            		else {
HXLINE(  46)			_hx_tmp = (int)1;
            		}
HXDLIN(  46)		Float _hx_tmp1;
HXDLIN(  46)		if (::com::stencyl::Engine_obj::NO_PHYSICS) {
HXLINE(  46)			_hx_tmp1 = simpleBounds->height;
            		}
            		else {
HXLINE(  46)			_hx_tmp1 = (int)1;
            		}
HXLINE(  49)		 ::Dynamic _hx_tmp2;
HXDLIN(  49)		if (::com::stencyl::Engine_obj::NO_PHYSICS) {
HXLINE(  49)			_hx_tmp2 = null();
            		}
            		else {
HXLINE(  49)			_hx_tmp2 = shapes->__get((int)0).StaticCast<  ::box2D::collision::shapes::B2Shape >();
            		}
HXLINE(  46)		super::__construct(game,(int)-1,(int)-2,x,y,(int)-1,_hx_tmp,_hx_tmp1,null(),null(),null(),null(),false,false,false,false,_hx_tmp2,::com::stencyl::Engine_obj::NO_PHYSICS,null(),null());
HXLINE(  53)		this->alwaysSimulate = true;
HXLINE(  54)		this->isRegion = true;
HXLINE(  55)		this->isTerrainRegion = false;
HXLINE(  56)		this->solid = false;
HXLINE(  58)		this->set_name(HX_("Region",14,35,21,35));
HXLINE(  60)		this->simpleBounds = simpleBounds;
HXLINE(  61)		this->copy = shapes->__get((int)0).StaticCast<  ::box2D::collision::shapes::B2Shape >();
HXLINE(  63)		this->containedActors =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXLINE(  64)		this->whenActorEntersListeners = ::cpp::VirtualArray_obj::__new();
HXLINE(  65)		this->whenActorExitsListeners = ::cpp::VirtualArray_obj::__new();
HXLINE(  67)		this->justAdded = ::cpp::VirtualArray_obj::__new();
HXLINE(  68)		this->justRemoved = ::cpp::VirtualArray_obj::__new();
HXLINE(  70)		if (!(::com::stencyl::Engine_obj::NO_PHYSICS)) {
HXLINE(  72)			this->body->setSleepingAllowed(true);
HXLINE(  73)			this->body->setAwake(false);
HXLINE(  74)			this->body->setIgnoreGravity(true);
            		}
HXLINE(  77)		Float lowerXBound = (int)0;
HXLINE(  78)		Float upperXBound = (int)0;
HXLINE(  79)		Float lowerYBound = (int)0;
HXLINE(  80)		Float upperYBound = (int)0;
HXLINE(  82)		if (::com::stencyl::Engine_obj::NO_PHYSICS) {
HXLINE(  84)			upperXBound = simpleBounds->width;
HXLINE(  85)			upperYBound = simpleBounds->height;
HXLINE(  87)			this->cacheWidth = (this->originalWidth = (this->regionWidth = ::Math_obj::round(::Math_obj::abs((lowerXBound - upperXBound)))));
HXLINE(  88)			this->cacheHeight = (this->originalHeight = (this->regionHeight = ::Math_obj::round(::Math_obj::abs((lowerYBound - upperYBound)))));
HXLINE(  90)			this->currOffset->x = -(((Float)this->cacheWidth / (Float)(int)2));
HXLINE(  91)			this->currOffset->y = -(((Float)this->cacheHeight / (Float)(int)2));
HXLINE(  92)			this->resetReal(x,y);
            		}
            		else {
HXLINE(  97)			if (::Std_obj::is(shapes->__get((int)0).StaticCast<  ::box2D::collision::shapes::B2Shape >(),hx::ClassOf< ::box2D::collision::shapes::B2PolygonShape >())) {
HXLINE(  99)				this->isCircle = false;
HXLINE( 100)				 ::box2D::common::math::B2Transform trans =  ::box2D::common::math::B2Transform_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 101)				trans->setIdentity();
HXLINE( 103)				 ::box2D::collision::B2AABB aabb =  ::box2D::collision::B2AABB_obj::__alloc( HX_CTX );
HXLINE( 105)				hx::TCast<  ::box2D::collision::shapes::B2PolygonShape >::cast(shapes->__get((int)0).StaticCast<  ::box2D::collision::shapes::B2Shape >())->computeAABB(aabb,trans);
HXLINE( 107)				lowerXBound = aabb->lowerBound->x;
HXLINE( 108)				upperXBound = aabb->upperBound->x;
HXLINE( 109)				lowerYBound = aabb->lowerBound->y;
HXLINE( 110)				upperYBound = aabb->upperBound->y;
HXLINE( 112)				{
HXLINE( 112)					int _g1 = (int)0;
HXDLIN( 112)					int _g = shapes->length;
HXDLIN( 112)					while((_g1 < _g)){
HXLINE( 112)						_g1 = (_g1 + (int)1);
HXDLIN( 112)						int i = (_g1 - (int)1);
HXLINE( 114)						 ::box2D::dynamics::B2FixtureDef fixture =  ::box2D::dynamics::B2FixtureDef_obj::__alloc( HX_CTX );
HXLINE( 115)						fixture->isSensor = true;
HXLINE( 116)						fixture->userData = hx::ObjectPtr<OBJ_>(this);
HXLINE( 117)						fixture->shape = shapes->__get(i).StaticCast<  ::box2D::collision::shapes::B2Shape >();
HXLINE( 118)						fixture->friction = ((Float)1.0);
HXLINE( 119)						fixture->density = ((Float)0.1);
HXLINE( 120)						fixture->restitution = (int)0;
HXLINE( 121)						fixture->groupID = (int)-1000;
HXLINE( 123)						this->body->createFixture(fixture);
HXLINE( 125)						hx::TCast<  ::box2D::collision::shapes::B2PolygonShape >::cast(shapes->__get(i).StaticCast<  ::box2D::collision::shapes::B2Shape >())->computeAABB(aabb,trans);
HXLINE( 126)						lowerXBound = ::Math_obj::min(lowerXBound,aabb->lowerBound->x);
HXLINE( 127)						upperXBound = ::Math_obj::max(upperXBound,aabb->upperBound->x);
HXLINE( 128)						lowerYBound = ::Math_obj::min(lowerYBound,aabb->lowerBound->y);
HXLINE( 129)						upperYBound = ::Math_obj::max(upperYBound,aabb->upperBound->y);
            					}
            				}
HXLINE( 132)				this->cacheWidth = (this->originalWidth = (this->regionWidth = ::Math_obj::round(::com::stencyl::Engine_obj::toPixelUnits(::Math_obj::abs((lowerXBound - upperXBound))))));
HXLINE( 133)				this->cacheHeight = (this->originalHeight = (this->regionHeight = ::Math_obj::round(::com::stencyl::Engine_obj::toPixelUnits(::Math_obj::abs((lowerYBound - upperYBound))))));
            			}
            			else {
HXLINE( 136)				if (::Std_obj::is(shapes->__get((int)0).StaticCast<  ::box2D::collision::shapes::B2Shape >(),hx::ClassOf< ::box2D::collision::shapes::B2CircleShape >())) {
HXLINE( 138)					this->isCircle = true;
HXLINE( 140)					this->cacheWidth = (this->originalWidth = (this->regionWidth = ::com::stencyl::Engine_obj::toPixelUnits((shapes->__get((int)0).StaticCast<  ::box2D::collision::shapes::B2Shape >()->m_radius * (int)2))));
HXLINE( 141)					this->cacheHeight = (this->originalHeight = (this->regionHeight = ::com::stencyl::Engine_obj::toPixelUnits((shapes->__get((int)0).StaticCast<  ::box2D::collision::shapes::B2Shape >()->m_radius * (int)2))));
            				}
            			}
            		}
            	}

Dynamic Region_obj::__CreateEmpty() { return new Region_obj; }

void *Region_obj::_hx_vtable = 0;

Dynamic Region_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Region_obj > _hx_result = new Region_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4]);
	return _hx_result;
}

bool Region_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x1b123bf8) {
		if (inClassId<=(int)0x17120186) {
			if (inClassId<=(int)0x0ddfced7) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x0ddfced7;
			} else {
				return inClassId==(int)0x17120186;
			}
		} else {
			return inClassId==(int)0x19c29573 || inClassId==(int)0x1b123bf8;
		}
	} else {
		if (inClassId<=(int)0x4fb21980) {
			return inClassId==(int)0x3f2b00af || inClassId==(int)0x4fb21980;
		} else {
			return inClassId==(int)0x56662c09;
		}
	}
}

bool Region_obj::containsActor( ::com::stencyl::models::Actor actor){
            	HX_STACKFRAME(&_hx_pos_3db67d5c52bef819_148_containsActor)
HXDLIN( 148)		if (hx::IsNotNull( actor )) {
HXLINE( 150)			return this->containedActors->exists(actor->ID);
            		}
            		else {
HXLINE( 155)			return false;
            		}
HXLINE( 148)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Region_obj,containsActor,return )

 ::haxe::ds::IntMap Region_obj::getContainedActors(){
            	HX_STACKFRAME(&_hx_pos_3db67d5c52bef819_161_getContainedActors)
HXDLIN( 161)		return this->containedActors;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Region_obj,getContainedActors,return )

void Region_obj::addActor( ::com::stencyl::models::Actor actor){
            	HX_STACKFRAME(&_hx_pos_3db67d5c52bef819_165_addActor)
HXLINE( 166)		if (hx::IsNull( actor )) {
HXLINE( 168)			return;
            		}
HXLINE( 171)		bool _hx_tmp;
HXDLIN( 171)		if ((actor->ID != (int)-1)) {
HXLINE( 171)			_hx_tmp = !(this->containedActors->exists(actor->ID));
            		}
            		else {
HXLINE( 171)			_hx_tmp = false;
            		}
HXDLIN( 171)		if (_hx_tmp) {
HXLINE( 173)			this->containedActors->set(actor->ID,actor->ID);
HXLINE( 175)			int index = ::com::stencyl::utils::Utils_obj::indexOf(this->justRemoved,actor);
HXLINE( 177)			if ((index == (int)-1)) {
HXLINE( 179)				this->justAdded->push(actor);
            			}
            			else {
HXLINE( 184)				this->justRemoved->splice(index,(int)1);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Region_obj,addActor,(void))

void Region_obj::removeActor( ::com::stencyl::models::Actor actor){
            	HX_STACKFRAME(&_hx_pos_3db67d5c52bef819_190_removeActor)
HXLINE( 191)		if (hx::IsNull( actor )) {
HXLINE( 193)			return;
            		}
HXLINE( 196)		if ((actor->ID != (int)-1)) {
HXLINE( 198)			int index = ::com::stencyl::utils::Utils_obj::indexOf(this->justRemoved,actor);
HXLINE( 200)			if ((index == (int)-1)) {
HXLINE( 202)				this->containedActors->remove(actor->ID);
HXLINE( 203)				this->justRemoved->push(actor);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Region_obj,removeActor,(void))

void Region_obj::follow( ::com::stencyl::models::Actor actor){
            	HX_STACKFRAME(&_hx_pos_3db67d5c52bef819_209_follow)
HXLINE( 210)		Float actor1 = actor->realX;
HXDLIN( 210)		Float x = (actor1 + ((Float)actor->cacheWidth / (Float)(int)2));
HXLINE( 211)		Float actor2 = actor->realY;
HXDLIN( 211)		Float y = (actor2 + ((Float)actor->cacheHeight / (Float)(int)2));
HXLINE( 213)		this->setX(x,null(),null());
HXLINE( 214)		this->setY(y,null(),null());
            	}


void Region_obj::resetSize(){
            	HX_STACKFRAME(&_hx_pos_3db67d5c52bef819_221_resetSize)
HXDLIN( 221)		this->setRegionSize(this->originalWidth,this->originalHeight);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Region_obj,resetSize,(void))

void Region_obj::setRegionDiameter(Float diameter){
            	HX_STACKFRAME(&_hx_pos_3db67d5c52bef819_226_setRegionDiameter)
HXDLIN( 226)		this->setRegionSize(diameter,diameter);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Region_obj,setRegionDiameter,(void))

void Region_obj::setRegionSize(Float width,Float height){
            	HX_GC_STACKFRAME(&_hx_pos_3db67d5c52bef819_230_setRegionSize)
HXLINE( 231)		Float oldWidth = this->regionWidth;
HXLINE( 232)		Float oldHeight = this->regionHeight;
HXLINE( 234)		width = ::com::stencyl::Engine_obj::toPhysicalUnits(width);
HXLINE( 235)		height = ::com::stencyl::Engine_obj::toPhysicalUnits(height);
HXLINE( 237)		 ::box2D::collision::shapes::B2Shape shape;
HXLINE( 239)		if (this->isCircle) {
HXLINE( 241)			 ::box2D::collision::shapes::B2CircleShape s =  ::box2D::collision::shapes::B2CircleShape_obj::__alloc( HX_CTX ,null());
HXLINE( 242)			s->m_radius = ((Float)width / (Float)(int)2);
HXLINE( 243)			shape = s;
            		}
            		else {
HXLINE( 248)			 ::box2D::collision::shapes::B2PolygonShape s2 =  ::box2D::collision::shapes::B2PolygonShape_obj::__alloc( HX_CTX );
HXLINE( 249)			s2->setAsBox(((Float)width / (Float)(int)2),((Float)height / (Float)(int)2));
HXLINE( 250)			shape = s2;
            		}
HXLINE( 253)		 ::box2D::dynamics::B2FixtureDef fixture =  ::box2D::dynamics::B2FixtureDef_obj::__alloc( HX_CTX );
HXLINE( 254)		fixture->isSensor = true;
HXLINE( 255)		fixture->userData = hx::ObjectPtr<OBJ_>(this);
HXLINE( 256)		fixture->shape = shape;
HXLINE( 257)		fixture->groupID = (int)-1000;
HXLINE( 259)		bool _hx_tmp;
HXDLIN( 259)		if (hx::IsNotNull( this->body )) {
HXLINE( 259)			_hx_tmp = hx::IsNotNull( this->body->getFixtureList() );
            		}
            		else {
HXLINE( 259)			_hx_tmp = false;
            		}
HXDLIN( 259)		if (_hx_tmp) {
HXLINE( 261)			while((this->body->m_fixtureCount > (int)0)){
HXLINE( 263)				 ::box2D::dynamics::B2Body _hx_tmp1 = this->body;
HXDLIN( 263)				_hx_tmp1->DestroyFixture(this->body->getFixtureList());
            			}
HXLINE( 266)			this->body->createFixture(fixture);
HXLINE( 268)			this->cacheWidth = (this->regionWidth = ::com::stencyl::Engine_obj::toPixelUnits(width));
HXLINE( 269)			this->cacheHeight = (this->regionHeight = ::com::stencyl::Engine_obj::toPixelUnits(height));
            		}
HXLINE( 272)		Float dw = (this->regionWidth - oldWidth);
HXLINE( 273)		Float dh = (this->regionHeight - oldHeight);
HXLINE( 276)		Float _hx_tmp2 = this->getX(null());
HXDLIN( 276)		Float _hx_tmp3 = (_hx_tmp2 + ((Float)dw / (Float)(int)2));
HXDLIN( 276)		Float _hx_tmp4 = this->getY(null());
HXDLIN( 276)		this->setLocation(_hx_tmp3,(_hx_tmp4 + ((Float)dh / (Float)(int)2)));
            	}


HX_DEFINE_DYNAMIC_FUNC2(Region_obj,setRegionSize,(void))

void Region_obj::setLocation(Float x,Float y){
            	HX_STACKFRAME(&_hx_pos_3db67d5c52bef819_280_setLocation)
HXLINE( 281)		this->setX((x + ((Float)this->regionWidth / (Float)(int)2)),null(),null());
HXLINE( 282)		this->setY((y + ((Float)this->regionHeight / (Float)(int)2)),null(),null());
            	}


Float Region_obj::getWidth(){
            	HX_STACKFRAME(&_hx_pos_3db67d5c52bef819_287_getWidth)
HXDLIN( 287)		return this->regionWidth;
            	}


Float Region_obj::getHeight(){
            	HX_STACKFRAME(&_hx_pos_3db67d5c52bef819_292_getHeight)
HXDLIN( 292)		return this->regionHeight;
            	}


bool Region_obj::isMouseOver(){
            	HX_STACKFRAME(&_hx_pos_3db67d5c52bef819_296_isMouseOver)
HXLINE( 297)		Float mx = ((Float)(::com::stencyl::Input_obj::mouseX + ::com::stencyl::Engine_obj::cameraX) / (Float)::com::stencyl::Engine_obj::SCALE);
HXLINE( 298)		Float my = ((Float)(::com::stencyl::Input_obj::mouseY + ::com::stencyl::Engine_obj::cameraY) / (Float)::com::stencyl::Engine_obj::SCALE);
HXLINE( 300)		Float xPos = this->getX(null());
HXLINE( 301)		Float yPos = this->getY(null());
HXLINE( 306)		bool _hx_tmp;
HXDLIN( 306)		bool _hx_tmp1;
HXDLIN( 306)		if ((mx >= xPos)) {
HXLINE( 306)			_hx_tmp1 = (my >= yPos);
            		}
            		else {
HXLINE( 306)			_hx_tmp1 = false;
            		}
HXDLIN( 306)		if (_hx_tmp1) {
HXLINE( 306)			_hx_tmp = (mx < (xPos + this->regionWidth));
            		}
            		else {
HXLINE( 306)			_hx_tmp = false;
            		}
HXDLIN( 306)		if (_hx_tmp) {
HXLINE( 309)			return (my < (yPos + this->regionHeight));
            		}
            		else {
HXLINE( 306)			return false;
            		}
HXDLIN( 306)		return false;
            	}


void Region_obj::innerUpdate(Float elapsedTime,bool hudCheck){
            	HX_STACKFRAME(&_hx_pos_3db67d5c52bef819_313_innerUpdate)
HXLINE( 314)		this->clearCollisionInfoList();
HXLINE( 316)		if (::com::stencyl::Engine_obj::NO_PHYSICS) {
HXLINE( 318)			 ::Dynamic id = this->containedActors->iterator();
HXDLIN( 318)			while(( (bool)(id->__Field(HX_("hasNext",6d,a5,46,18),hx::paccDynamic)()) )){
HXLINE( 318)				int id1 = ( (int)(id->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)()) );
HXLINE( 320)				 ::com::stencyl::models::Actor a = ::com::stencyl::Engine_obj::engine->getActor(id1);
HXLINE( 322)				bool _hx_tmp;
HXDLIN( 322)				bool _hx_tmp1;
HXDLIN( 322)				if (hx::IsNotNull( this->HITBOX )) {
HXLINE( 322)					_hx_tmp1 = hx::IsNotNull( a );
            				}
            				else {
HXLINE( 322)					_hx_tmp1 = false;
            				}
HXDLIN( 322)				if (_hx_tmp1) {
HXLINE( 322)					_hx_tmp = !(this->HITBOX->collide(a->HITBOX));
            				}
            				else {
HXLINE( 322)					_hx_tmp = false;
            				}
HXDLIN( 322)				if (_hx_tmp) {
HXLINE( 324)					this->removeActor(a);
            				}
            			}
            		}
HXLINE( 329)		while(true){
HXLINE( 329)			bool _hx_tmp2;
HXDLIN( 329)			if (hx::IsNotNull( this->justAdded )) {
HXLINE( 329)				_hx_tmp2 = (this->justAdded->get_length() > (int)0);
            			}
            			else {
HXLINE( 329)				_hx_tmp2 = false;
            			}
HXDLIN( 329)			if (!(_hx_tmp2)) {
HXLINE( 329)				goto _hx_goto_16;
            			}
HXLINE( 331)			 ::com::stencyl::models::Actor a1 = hx::TCast<  ::com::stencyl::models::Actor >::cast(this->justAdded->pop());
HXLINE( 332)			{
HXLINE( 332)				::cpp::VirtualArray listeners = this->whenActorEntersListeners;
HXDLIN( 332)				int r = (int)0;
HXDLIN( 332)				while((r < listeners->get_length())){
HXLINE( 332)					try {
            						HX_STACK_CATCHABLE(::String, 0);
HXLINE( 332)						 ::Dynamic f = listeners->__get(r);
HXDLIN( 332)						f(a1,listeners);
HXDLIN( 332)						if ((::com::stencyl::utils::Utils_obj::indexOf(listeners,f) == (int)-1)) {
HXLINE( 332)							r = (r - (int)1);
            						}
            					}
            					catch( ::Dynamic _hx_e){
            						if (_hx_e.IsClass< ::String >() ){
            							HX_STACK_BEGIN_CATCH
            							::String e = _hx_e;
HXLINE( 332)							::haxe::Log_obj::trace(e,hx::SourceInfo(HX_("Engine.hx",1c,a0,53,be),4228,HX_("com.stencyl.Engine",b1,81,66,b4),HX_("invokeListeners2",6b,eb,b8,23)));
            						}
            						else {
            							HX_STACK_DO_THROW(_hx_e);
            						}
            					}
HXDLIN( 332)					r = (r + (int)1);
            				}
            			}
            		}
            		_hx_goto_16:;
HXLINE( 335)		while(true){
HXLINE( 335)			bool _hx_tmp3;
HXDLIN( 335)			if (hx::IsNotNull( this->justRemoved )) {
HXLINE( 335)				_hx_tmp3 = (this->justRemoved->get_length() > (int)0);
            			}
            			else {
HXLINE( 335)				_hx_tmp3 = false;
            			}
HXDLIN( 335)			if (!(_hx_tmp3)) {
HXLINE( 335)				goto _hx_goto_18;
            			}
HXLINE( 337)			 ::com::stencyl::models::Actor a2 = hx::TCast<  ::com::stencyl::models::Actor >::cast(this->justRemoved->pop());
HXLINE( 338)			{
HXLINE( 338)				::cpp::VirtualArray listeners1 = this->whenActorExitsListeners;
HXDLIN( 338)				int r1 = (int)0;
HXDLIN( 338)				while((r1 < listeners1->get_length())){
HXLINE( 338)					try {
            						HX_STACK_CATCHABLE(::String, 0);
HXLINE( 338)						 ::Dynamic f1 = listeners1->__get(r1);
HXDLIN( 338)						f1(a2,listeners1);
HXDLIN( 338)						if ((::com::stencyl::utils::Utils_obj::indexOf(listeners1,f1) == (int)-1)) {
HXLINE( 338)							r1 = (r1 - (int)1);
            						}
            					}
            					catch( ::Dynamic _hx_e){
            						if (_hx_e.IsClass< ::String >() ){
            							HX_STACK_BEGIN_CATCH
            							::String e1 = _hx_e;
HXLINE( 338)							::haxe::Log_obj::trace(e1,hx::SourceInfo(HX_("Engine.hx",1c,a0,53,be),4228,HX_("com.stencyl.Engine",b1,81,66,b4),HX_("invokeListeners2",6b,eb,b8,23)));
            						}
            						else {
            							HX_STACK_DO_THROW(_hx_e);
            						}
            					}
HXDLIN( 338)					r1 = (r1 + (int)1);
            				}
            			}
            		}
            		_hx_goto_18:;
HXLINE( 341)		bool _hx_tmp4;
HXDLIN( 341)		if (hx::IsNotNull( this->mouseOverListeners )) {
HXLINE( 341)			_hx_tmp4 = (this->mouseOverListeners->get_length() > (int)0);
            		}
            		else {
HXLINE( 341)			_hx_tmp4 = false;
            		}
HXDLIN( 341)		if (_hx_tmp4) {
HXLINE( 344)			bool mouseOver = this->isMouseOver();
HXLINE( 346)			if (mouseOver) {
HXLINE( 348)				if ((this->mouseState <= (int)0)) {
HXLINE( 351)					this->mouseState = (int)1;
HXLINE( 352)					{
HXLINE( 352)						::cpp::VirtualArray listeners2 = this->mouseOverListeners;
HXDLIN( 352)						 ::Dynamic value = this->mouseState;
HXDLIN( 352)						int r2 = (int)0;
HXDLIN( 352)						while((r2 < listeners2->get_length())){
HXLINE( 352)							try {
            								HX_STACK_CATCHABLE(::String, 0);
HXLINE( 352)								 ::Dynamic f2 = listeners2->__get(r2);
HXDLIN( 352)								f2(value,listeners2);
HXDLIN( 352)								if ((::com::stencyl::utils::Utils_obj::indexOf(listeners2,f2) == (int)-1)) {
HXLINE( 352)									r2 = (r2 - (int)1);
            								}
            							}
            							catch( ::Dynamic _hx_e){
            								if (_hx_e.IsClass< ::String >() ){
            									HX_STACK_BEGIN_CATCH
            									::String e2 = _hx_e;
HXLINE( 352)									::haxe::Log_obj::trace(e2,hx::SourceInfo(HX_("Engine.hx",1c,a0,53,be),4228,HX_("com.stencyl.Engine",b1,81,66,b4),HX_("invokeListeners2",6b,eb,b8,23)));
            								}
            								else {
            									HX_STACK_DO_THROW(_hx_e);
            								}
            							}
HXDLIN( 352)							r2 = (r2 + (int)1);
            						}
            					}
            				}
            				else {
HXLINE( 357)					this->mouseState = (int)2;
            				}
HXLINE( 360)				if (::com::stencyl::Input_obj::mousePressed) {
HXLINE( 363)					this->mouseState = (int)3;
HXLINE( 364)					{
HXLINE( 364)						::cpp::VirtualArray listeners3 = this->mouseOverListeners;
HXDLIN( 364)						 ::Dynamic value1 = this->mouseState;
HXDLIN( 364)						int r3 = (int)0;
HXDLIN( 364)						while((r3 < listeners3->get_length())){
HXLINE( 364)							try {
            								HX_STACK_CATCHABLE(::String, 0);
HXLINE( 364)								 ::Dynamic f3 = listeners3->__get(r3);
HXDLIN( 364)								f3(value1,listeners3);
HXDLIN( 364)								if ((::com::stencyl::utils::Utils_obj::indexOf(listeners3,f3) == (int)-1)) {
HXLINE( 364)									r3 = (r3 - (int)1);
            								}
            							}
            							catch( ::Dynamic _hx_e){
            								if (_hx_e.IsClass< ::String >() ){
            									HX_STACK_BEGIN_CATCH
            									::String e3 = _hx_e;
HXLINE( 364)									::haxe::Log_obj::trace(e3,hx::SourceInfo(HX_("Engine.hx",1c,a0,53,be),4228,HX_("com.stencyl.Engine",b1,81,66,b4),HX_("invokeListeners2",6b,eb,b8,23)));
            								}
            								else {
            									HX_STACK_DO_THROW(_hx_e);
            								}
            							}
HXDLIN( 364)							r3 = (r3 + (int)1);
            						}
            					}
            				}
            				else {
HXLINE( 367)					if (::com::stencyl::Input_obj::mouseDown) {
HXLINE( 370)						this->mouseState = (int)4;
HXLINE( 371)						{
HXLINE( 371)							::cpp::VirtualArray listeners4 = this->mouseOverListeners;
HXDLIN( 371)							 ::Dynamic value2 = this->mouseState;
HXDLIN( 371)							int r4 = (int)0;
HXDLIN( 371)							while((r4 < listeners4->get_length())){
HXLINE( 371)								try {
            									HX_STACK_CATCHABLE(::String, 0);
HXLINE( 371)									 ::Dynamic f4 = listeners4->__get(r4);
HXDLIN( 371)									f4(value2,listeners4);
HXDLIN( 371)									if ((::com::stencyl::utils::Utils_obj::indexOf(listeners4,f4) == (int)-1)) {
HXLINE( 371)										r4 = (r4 - (int)1);
            									}
            								}
            								catch( ::Dynamic _hx_e){
            									if (_hx_e.IsClass< ::String >() ){
            										HX_STACK_BEGIN_CATCH
            										::String e4 = _hx_e;
HXLINE( 371)										::haxe::Log_obj::trace(e4,hx::SourceInfo(HX_("Engine.hx",1c,a0,53,be),4228,HX_("com.stencyl.Engine",b1,81,66,b4),HX_("invokeListeners2",6b,eb,b8,23)));
            									}
            									else {
            										HX_STACK_DO_THROW(_hx_e);
            									}
            								}
HXDLIN( 371)								r4 = (r4 + (int)1);
            							}
            						}
            					}
            				}
HXLINE( 374)				if (::com::stencyl::Input_obj::mouseReleased) {
HXLINE( 377)					this->mouseState = (int)5;
HXLINE( 378)					{
HXLINE( 378)						::cpp::VirtualArray listeners5 = this->mouseOverListeners;
HXDLIN( 378)						 ::Dynamic value3 = this->mouseState;
HXDLIN( 378)						int r5 = (int)0;
HXDLIN( 378)						while((r5 < listeners5->get_length())){
HXLINE( 378)							try {
            								HX_STACK_CATCHABLE(::String, 0);
HXLINE( 378)								 ::Dynamic f5 = listeners5->__get(r5);
HXDLIN( 378)								f5(value3,listeners5);
HXDLIN( 378)								if ((::com::stencyl::utils::Utils_obj::indexOf(listeners5,f5) == (int)-1)) {
HXLINE( 378)									r5 = (r5 - (int)1);
            								}
            							}
            							catch( ::Dynamic _hx_e){
            								if (_hx_e.IsClass< ::String >() ){
            									HX_STACK_BEGIN_CATCH
            									::String e5 = _hx_e;
HXLINE( 378)									::haxe::Log_obj::trace(e5,hx::SourceInfo(HX_("Engine.hx",1c,a0,53,be),4228,HX_("com.stencyl.Engine",b1,81,66,b4),HX_("invokeListeners2",6b,eb,b8,23)));
            								}
            								else {
            									HX_STACK_DO_THROW(_hx_e);
            								}
            							}
HXDLIN( 378)							r5 = (r5 + (int)1);
            						}
            					}
            				}
            			}
            			else {
HXLINE( 384)				if ((this->mouseState > (int)0)) {
HXLINE( 387)					this->mouseState = (int)-1;
HXLINE( 388)					{
HXLINE( 388)						::cpp::VirtualArray listeners6 = this->mouseOverListeners;
HXDLIN( 388)						 ::Dynamic value4 = this->mouseState;
HXDLIN( 388)						int r6 = (int)0;
HXDLIN( 388)						while((r6 < listeners6->get_length())){
HXLINE( 388)							try {
            								HX_STACK_CATCHABLE(::String, 0);
HXLINE( 388)								 ::Dynamic f6 = listeners6->__get(r6);
HXDLIN( 388)								f6(value4,listeners6);
HXDLIN( 388)								if ((::com::stencyl::utils::Utils_obj::indexOf(listeners6,f6) == (int)-1)) {
HXLINE( 388)									r6 = (r6 - (int)1);
            								}
            							}
            							catch( ::Dynamic _hx_e){
            								if (_hx_e.IsClass< ::String >() ){
            									HX_STACK_BEGIN_CATCH
            									::String e6 = _hx_e;
HXLINE( 388)									::haxe::Log_obj::trace(e6,hx::SourceInfo(HX_("Engine.hx",1c,a0,53,be),4228,HX_("com.stencyl.Engine",b1,81,66,b4),HX_("invokeListeners2",6b,eb,b8,23)));
            								}
            								else {
            									HX_STACK_DO_THROW(_hx_e);
            								}
            							}
HXDLIN( 388)							r6 = (r6 + (int)1);
            						}
            					}
            				}
            				else {
HXLINE( 391)					if ((this->mouseState == (int)-1)) {
HXLINE( 393)						this->mouseState = (int)0;
            					}
            				}
            			}
            		}
            	}


int Region_obj::UNSET_ID;


hx::ObjectPtr< Region_obj > Region_obj::__new( ::com::stencyl::Engine game,Float x,Float y,::Array< ::Dynamic> shapes, ::openfl::geom::Rectangle simpleBounds) {
	hx::ObjectPtr< Region_obj > __this = new Region_obj();
	__this->__construct(game,x,y,shapes,simpleBounds);
	return __this;
}

hx::ObjectPtr< Region_obj > Region_obj::__alloc(hx::Ctx *_hx_ctx, ::com::stencyl::Engine game,Float x,Float y,::Array< ::Dynamic> shapes, ::openfl::geom::Rectangle simpleBounds) {
	Region_obj *__this = (Region_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Region_obj), true, "com.stencyl.models.Region"));
	*(void **)__this = Region_obj::_hx_vtable;
	__this->__construct(game,x,y,shapes,simpleBounds);
	return __this;
}

Region_obj::Region_obj()
{
}

void Region_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Region);
	HX_MARK_MEMBER_NAME(isCircle,"isCircle");
	HX_MARK_MEMBER_NAME(containedActors,"containedActors");
	HX_MARK_MEMBER_NAME(copy,"copy");
	HX_MARK_MEMBER_NAME(simpleBounds,"simpleBounds");
	HX_MARK_MEMBER_NAME(regionWidth,"regionWidth");
	HX_MARK_MEMBER_NAME(regionHeight,"regionHeight");
	HX_MARK_MEMBER_NAME(originalWidth,"originalWidth");
	HX_MARK_MEMBER_NAME(originalHeight,"originalHeight");
	HX_MARK_MEMBER_NAME(whenActorEntersListeners,"whenActorEntersListeners");
	HX_MARK_MEMBER_NAME(whenActorExitsListeners,"whenActorExitsListeners");
	HX_MARK_MEMBER_NAME(justAdded,"justAdded");
	HX_MARK_MEMBER_NAME(justRemoved,"justRemoved");
	 ::com::stencyl::models::Actor_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void Region_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(isCircle,"isCircle");
	HX_VISIT_MEMBER_NAME(containedActors,"containedActors");
	HX_VISIT_MEMBER_NAME(copy,"copy");
	HX_VISIT_MEMBER_NAME(simpleBounds,"simpleBounds");
	HX_VISIT_MEMBER_NAME(regionWidth,"regionWidth");
	HX_VISIT_MEMBER_NAME(regionHeight,"regionHeight");
	HX_VISIT_MEMBER_NAME(originalWidth,"originalWidth");
	HX_VISIT_MEMBER_NAME(originalHeight,"originalHeight");
	HX_VISIT_MEMBER_NAME(whenActorEntersListeners,"whenActorEntersListeners");
	HX_VISIT_MEMBER_NAME(whenActorExitsListeners,"whenActorExitsListeners");
	HX_VISIT_MEMBER_NAME(justAdded,"justAdded");
	HX_VISIT_MEMBER_NAME(justRemoved,"justRemoved");
	 ::com::stencyl::models::Actor_obj::__Visit(HX_VISIT_ARG);
}

hx::Val Region_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"copy") ) { return hx::Val( copy ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"follow") ) { return hx::Val( follow_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"isCircle") ) { return hx::Val( isCircle ); }
		if (HX_FIELD_EQ(inName,"addActor") ) { return hx::Val( addActor_dyn() ); }
		if (HX_FIELD_EQ(inName,"getWidth") ) { return hx::Val( getWidth_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"justAdded") ) { return hx::Val( justAdded ); }
		if (HX_FIELD_EQ(inName,"resetSize") ) { return hx::Val( resetSize_dyn() ); }
		if (HX_FIELD_EQ(inName,"getHeight") ) { return hx::Val( getHeight_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"regionWidth") ) { return hx::Val( regionWidth ); }
		if (HX_FIELD_EQ(inName,"justRemoved") ) { return hx::Val( justRemoved ); }
		if (HX_FIELD_EQ(inName,"removeActor") ) { return hx::Val( removeActor_dyn() ); }
		if (HX_FIELD_EQ(inName,"setLocation") ) { return hx::Val( setLocation_dyn() ); }
		if (HX_FIELD_EQ(inName,"isMouseOver") ) { return hx::Val( isMouseOver_dyn() ); }
		if (HX_FIELD_EQ(inName,"innerUpdate") ) { return hx::Val( innerUpdate_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"simpleBounds") ) { return hx::Val( simpleBounds ); }
		if (HX_FIELD_EQ(inName,"regionHeight") ) { return hx::Val( regionHeight ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"originalWidth") ) { return hx::Val( originalWidth ); }
		if (HX_FIELD_EQ(inName,"containsActor") ) { return hx::Val( containsActor_dyn() ); }
		if (HX_FIELD_EQ(inName,"setRegionSize") ) { return hx::Val( setRegionSize_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"originalHeight") ) { return hx::Val( originalHeight ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"containedActors") ) { return hx::Val( containedActors ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"setRegionDiameter") ) { return hx::Val( setRegionDiameter_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"getContainedActors") ) { return hx::Val( getContainedActors_dyn() ); }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"whenActorExitsListeners") ) { return hx::Val( whenActorExitsListeners ); }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"whenActorEntersListeners") ) { return hx::Val( whenActorEntersListeners ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val Region_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"copy") ) { copy=inValue.Cast<  ::box2D::collision::shapes::B2Shape >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"isCircle") ) { isCircle=inValue.Cast< bool >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"justAdded") ) { justAdded=inValue.Cast< ::cpp::VirtualArray >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"regionWidth") ) { regionWidth=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"justRemoved") ) { justRemoved=inValue.Cast< ::cpp::VirtualArray >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"simpleBounds") ) { simpleBounds=inValue.Cast<  ::openfl::geom::Rectangle >(); return inValue; }
		if (HX_FIELD_EQ(inName,"regionHeight") ) { regionHeight=inValue.Cast< Float >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"originalWidth") ) { originalWidth=inValue.Cast< Float >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"originalHeight") ) { originalHeight=inValue.Cast< Float >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"containedActors") ) { containedActors=inValue.Cast<  ::haxe::ds::IntMap >(); return inValue; }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"whenActorExitsListeners") ) { whenActorExitsListeners=inValue.Cast< ::cpp::VirtualArray >(); return inValue; }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"whenActorEntersListeners") ) { whenActorEntersListeners=inValue.Cast< ::cpp::VirtualArray >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Region_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("isCircle","\x9a","\x0d","\x77","\xae"));
	outFields->push(HX_HCSTRING("containedActors","\x71","\x1d","\x9f","\x3a"));
	outFields->push(HX_HCSTRING("copy","\xb5","\xbb","\xc4","\x41"));
	outFields->push(HX_HCSTRING("simpleBounds","\x47","\x30","\x7d","\xb1"));
	outFields->push(HX_HCSTRING("regionWidth","\x72","\x70","\xdf","\xf5"));
	outFields->push(HX_HCSTRING("regionHeight","\xfb","\x6b","\xf2","\xe3"));
	outFields->push(HX_HCSTRING("originalWidth","\xf5","\xab","\x53","\x25"));
	outFields->push(HX_HCSTRING("originalHeight","\x18","\x43","\x32","\x3a"));
	outFields->push(HX_HCSTRING("whenActorEntersListeners","\x09","\x3e","\x72","\xe7"));
	outFields->push(HX_HCSTRING("whenActorExitsListeners","\x65","\x56","\xbd","\xde"));
	outFields->push(HX_HCSTRING("justAdded","\xf4","\x1a","\xff","\x3a"));
	outFields->push(HX_HCSTRING("justRemoved","\xd4","\x5a","\xc0","\xab"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Region_obj_sMemberStorageInfo[] = {
	{hx::fsBool,(int)offsetof(Region_obj,isCircle),HX_HCSTRING("isCircle","\x9a","\x0d","\x77","\xae")},
	{hx::fsObject /*::haxe::ds::IntMap*/ ,(int)offsetof(Region_obj,containedActors),HX_HCSTRING("containedActors","\x71","\x1d","\x9f","\x3a")},
	{hx::fsObject /*::box2D::collision::shapes::B2Shape*/ ,(int)offsetof(Region_obj,copy),HX_HCSTRING("copy","\xb5","\xbb","\xc4","\x41")},
	{hx::fsObject /*::openfl::geom::Rectangle*/ ,(int)offsetof(Region_obj,simpleBounds),HX_HCSTRING("simpleBounds","\x47","\x30","\x7d","\xb1")},
	{hx::fsFloat,(int)offsetof(Region_obj,regionWidth),HX_HCSTRING("regionWidth","\x72","\x70","\xdf","\xf5")},
	{hx::fsFloat,(int)offsetof(Region_obj,regionHeight),HX_HCSTRING("regionHeight","\xfb","\x6b","\xf2","\xe3")},
	{hx::fsFloat,(int)offsetof(Region_obj,originalWidth),HX_HCSTRING("originalWidth","\xf5","\xab","\x53","\x25")},
	{hx::fsFloat,(int)offsetof(Region_obj,originalHeight),HX_HCSTRING("originalHeight","\x18","\x43","\x32","\x3a")},
	{hx::fsObject /*cpp::ArrayBase*/ ,(int)offsetof(Region_obj,whenActorEntersListeners),HX_HCSTRING("whenActorEntersListeners","\x09","\x3e","\x72","\xe7")},
	{hx::fsObject /*cpp::ArrayBase*/ ,(int)offsetof(Region_obj,whenActorExitsListeners),HX_HCSTRING("whenActorExitsListeners","\x65","\x56","\xbd","\xde")},
	{hx::fsObject /*cpp::ArrayBase*/ ,(int)offsetof(Region_obj,justAdded),HX_HCSTRING("justAdded","\xf4","\x1a","\xff","\x3a")},
	{hx::fsObject /*cpp::ArrayBase*/ ,(int)offsetof(Region_obj,justRemoved),HX_HCSTRING("justRemoved","\xd4","\x5a","\xc0","\xab")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo Region_obj_sStaticStorageInfo[] = {
	{hx::fsInt,(void *) &Region_obj::UNSET_ID,HX_HCSTRING("UNSET_ID","\xd1","\x4e","\x5d","\xcb")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String Region_obj_sMemberFields[] = {
	HX_HCSTRING("isCircle","\x9a","\x0d","\x77","\xae"),
	HX_HCSTRING("containedActors","\x71","\x1d","\x9f","\x3a"),
	HX_HCSTRING("copy","\xb5","\xbb","\xc4","\x41"),
	HX_HCSTRING("simpleBounds","\x47","\x30","\x7d","\xb1"),
	HX_HCSTRING("regionWidth","\x72","\x70","\xdf","\xf5"),
	HX_HCSTRING("regionHeight","\xfb","\x6b","\xf2","\xe3"),
	HX_HCSTRING("originalWidth","\xf5","\xab","\x53","\x25"),
	HX_HCSTRING("originalHeight","\x18","\x43","\x32","\x3a"),
	HX_HCSTRING("whenActorEntersListeners","\x09","\x3e","\x72","\xe7"),
	HX_HCSTRING("whenActorExitsListeners","\x65","\x56","\xbd","\xde"),
	HX_HCSTRING("justAdded","\xf4","\x1a","\xff","\x3a"),
	HX_HCSTRING("justRemoved","\xd4","\x5a","\xc0","\xab"),
	HX_HCSTRING("containsActor","\x56","\xd0","\x02","\xe8"),
	HX_HCSTRING("getContainedActors","\x7b","\xbd","\x64","\xed"),
	HX_HCSTRING("addActor","\x14","\xf1","\x03","\x95"),
	HX_HCSTRING("removeActor","\x11","\xa8","\xda","\x19"),
	HX_HCSTRING("follow","\x71","\x91","\x96","\xf9"),
	HX_HCSTRING("resetSize","\x30","\xaa","\x3f","\x92"),
	HX_HCSTRING("setRegionDiameter","\x23","\x87","\x60","\x2d"),
	HX_HCSTRING("setRegionSize","\x17","\x56","\x57","\x7c"),
	HX_HCSTRING("setLocation","\xf7","\x37","\xa7","\x15"),
	HX_HCSTRING("getWidth","\x90","\xc5","\x39","\x2a"),
	HX_HCSTRING("getHeight","\x1d","\x91","\xa2","\x7e"),
	HX_HCSTRING("isMouseOver","\xcf","\x00","\x8e","\xd4"),
	HX_HCSTRING("innerUpdate","\x3f","\x80","\x04","\xf0"),
	::String(null()) };

static void Region_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Region_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(Region_obj::UNSET_ID,"UNSET_ID");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Region_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Region_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(Region_obj::UNSET_ID,"UNSET_ID");
};

#endif

hx::Class Region_obj::__mClass;

static ::String Region_obj_sStaticFields[] = {
	HX_HCSTRING("UNSET_ID","\xd1","\x4e","\x5d","\xcb"),
	::String(null())
};

void Region_obj::__register()
{
	hx::Object *dummy = new Region_obj;
	Region_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("com.stencyl.models.Region","\x69","\x66","\xa6","\x08");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Region_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Region_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Region_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Region_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Region_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Region_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Region_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Region_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_3db67d5c52bef819_20_boot)
HXDLIN(  20)		UNSET_ID = (int)-1;
            	}
}

} // end namespace com
} // end namespace stencyl
} // end namespace models
