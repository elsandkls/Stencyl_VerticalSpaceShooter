// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_box2D_collision_shapes_B2CircleShape
#include <box2D/collision/shapes/B2CircleShape.h>
#endif
#ifndef INCLUDED_box2D_collision_shapes_B2PolygonShape
#include <box2D/collision/shapes/B2PolygonShape.h>
#endif
#ifndef INCLUDED_box2D_collision_shapes_B2Shape
#include <box2D/collision/shapes/B2Shape.h>
#endif
#ifndef INCLUDED_box2D_common_math_B2Vec2
#include <box2D/common/math/B2Vec2.h>
#endif
#ifndef INCLUDED_box2D_dynamics_joints_B2DistanceJointDef
#include <box2D/dynamics/joints/B2DistanceJointDef.h>
#endif
#ifndef INCLUDED_box2D_dynamics_joints_B2JointDef
#include <box2D/dynamics/joints/B2JointDef.h>
#endif
#ifndef INCLUDED_box2D_dynamics_joints_B2LineJointDef
#include <box2D/dynamics/joints/B2LineJointDef.h>
#endif
#ifndef INCLUDED_box2D_dynamics_joints_B2RevoluteJointDef
#include <box2D/dynamics/joints/B2RevoluteJointDef.h>
#endif
#ifndef INCLUDED_com_stencyl_Data
#include <com/stencyl/Data.h>
#endif
#ifndef INCLUDED_com_stencyl_Engine
#include <com/stencyl/Engine.h>
#endif
#ifndef INCLUDED_com_stencyl_behavior_BehaviorInstance
#include <com/stencyl/behavior/BehaviorInstance.h>
#endif
#ifndef INCLUDED_com_stencyl_graphics_BlendModes
#include <com/stencyl/graphics/BlendModes.h>
#endif
#ifndef INCLUDED_com_stencyl_graphics_EngineScaleUpdateListener
#include <com/stencyl/graphics/EngineScaleUpdateListener.h>
#endif
#ifndef INCLUDED_com_stencyl_io_AttributeValues
#include <com/stencyl/io/AttributeValues.h>
#endif
#ifndef INCLUDED_com_stencyl_io_ShapeReader
#include <com/stencyl/io/ShapeReader.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_Typedefs
#include <com/stencyl/io/mbs/Typedefs.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_scene_MbsActorInstance
#include <com/stencyl/io/mbs/scene/MbsActorInstance.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_scene_MbsScene
#include <com/stencyl/io/mbs/scene/MbsScene.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_scene_layers_MbsColorBackground
#include <com/stencyl/io/mbs/scene/layers/MbsColorBackground.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_scene_layers_MbsGradientBackground
#include <com/stencyl/io/mbs/scene/layers/MbsGradientBackground.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_scene_layers_MbsImageBackground
#include <com/stencyl/io/mbs/scene/layers/MbsImageBackground.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_scene_layers_MbsInteractiveLayer
#include <com/stencyl/io/mbs/scene/layers/MbsInteractiveLayer.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_scene_layers_MbsLayer
#include <com/stencyl/io/mbs/scene/layers/MbsLayer.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_scene_physics_MbsHingeJoint
#include <com/stencyl/io/mbs/scene/physics/MbsHingeJoint.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_scene_physics_MbsJoint
#include <com/stencyl/io/mbs/scene/physics/MbsJoint.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_scene_physics_MbsRegion
#include <com/stencyl/io/mbs/scene/physics/MbsRegion.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_scene_physics_MbsSlidingJoint
#include <com/stencyl/io/mbs/scene/physics/MbsSlidingJoint.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_scene_physics_MbsStickJoint
#include <com/stencyl/io/mbs/scene/physics/MbsStickJoint.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_scene_physics_MbsTerrainRegion
#include <com/stencyl/io/mbs/scene/physics/MbsTerrainRegion.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_shape_MbsCircle
#include <com/stencyl/io/mbs/shape/MbsCircle.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_shape_MbsPoint
#include <com/stencyl/io/mbs/shape/MbsPoint.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_shape_MbsPolyRegion
#include <com/stencyl/io/mbs/shape/MbsPolyRegion.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_shape_MbsPolygon
#include <com/stencyl/io/mbs/shape/MbsPolygon.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_shape_MbsShape
#include <com/stencyl/io/mbs/shape/MbsShape.h>
#endif
#ifndef INCLUDED_com_stencyl_io_mbs_shape_MbsWireframe
#include <com/stencyl/io/mbs/shape/MbsWireframe.h>
#endif
#ifndef INCLUDED_com_stencyl_models_Atlas
#include <com/stencyl/models/Atlas.h>
#endif
#ifndef INCLUDED_com_stencyl_models_Background
#include <com/stencyl/models/Background.h>
#endif
#ifndef INCLUDED_com_stencyl_models_GameModel
#include <com/stencyl/models/GameModel.h>
#endif
#ifndef INCLUDED_com_stencyl_models_Resource
#include <com/stencyl/models/Resource.h>
#endif
#ifndef INCLUDED_com_stencyl_models_Scene
#include <com/stencyl/models/Scene.h>
#endif
#ifndef INCLUDED_com_stencyl_models_actor_ActorType
#include <com/stencyl/models/actor/ActorType.h>
#endif
#ifndef INCLUDED_com_stencyl_models_background_ColorBackground
#include <com/stencyl/models/background/ColorBackground.h>
#endif
#ifndef INCLUDED_com_stencyl_models_background_GradientBackground
#include <com/stencyl/models/background/GradientBackground.h>
#endif
#ifndef INCLUDED_com_stencyl_models_collision_Grid
#include <com/stencyl/models/collision/Grid.h>
#endif
#ifndef INCLUDED_com_stencyl_models_collision_Hitbox
#include <com/stencyl/models/collision/Hitbox.h>
#endif
#ifndef INCLUDED_com_stencyl_models_collision_Mask
#include <com/stencyl/models/collision/Mask.h>
#endif
#ifndef INCLUDED_com_stencyl_models_scene_ActorInstance
#include <com/stencyl/models/scene/ActorInstance.h>
#endif
#ifndef INCLUDED_com_stencyl_models_scene_Layer
#include <com/stencyl/models/scene/Layer.h>
#endif
#ifndef INCLUDED_com_stencyl_models_scene_RegionDef
#include <com/stencyl/models/scene/RegionDef.h>
#endif
#ifndef INCLUDED_com_stencyl_models_scene_TerrainDef
#include <com/stencyl/models/scene/TerrainDef.h>
#endif
#ifndef INCLUDED_com_stencyl_models_scene_Tile
#include <com/stencyl/models/scene/Tile.h>
#endif
#ifndef INCLUDED_com_stencyl_models_scene_TileLayer
#include <com/stencyl/models/scene/TileLayer.h>
#endif
#ifndef INCLUDED_com_stencyl_models_scene_Tileset
#include <com/stencyl/models/scene/Tileset.h>
#endif
#ifndef INCLUDED_com_stencyl_models_scene_Wireframe
#include <com/stencyl/models/scene/Wireframe.h>
#endif
#ifndef INCLUDED_com_stencyl_models_scene_layers_BackgroundLayer
#include <com/stencyl/models/scene/layers/BackgroundLayer.h>
#endif
#ifndef INCLUDED_com_stencyl_models_scene_layers_RegularLayer
#include <com/stencyl/models/scene/layers/RegularLayer.h>
#endif
#ifndef INCLUDED_com_stencyl_utils_Assets
#include <com/stencyl/utils/Assets.h>
#endif
#ifndef INCLUDED_com_stencyl_utils_LazyIntMap
#include <com/stencyl/utils/LazyIntMap.h>
#endif
#ifndef INCLUDED_com_stencyl_utils_PolyDecompBayazit
#include <com/stencyl/utils/PolyDecompBayazit.h>
#endif
#ifndef INCLUDED_de_polygonal_ds_Collection
#include <de/polygonal/ds/Collection.h>
#endif
#ifndef INCLUDED_de_polygonal_ds_Hashable
#include <de/polygonal/ds/Hashable.h>
#endif
#ifndef INCLUDED_de_polygonal_ds_IntHashTable
#include <de/polygonal/ds/IntHashTable.h>
#endif
#ifndef INCLUDED_de_polygonal_ds_IntIntHashTable
#include <de/polygonal/ds/IntIntHashTable.h>
#endif
#ifndef INCLUDED_de_polygonal_ds_Map
#include <de/polygonal/ds/Map.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_mbs_core_MbsField
#include <mbs/core/MbsField.h>
#endif
#ifndef INCLUDED_mbs_core_MbsObject
#include <mbs/core/MbsObject.h>
#endif
#ifndef INCLUDED_mbs_core_MbsTypedefSet
#include <mbs/core/MbsTypedefSet.h>
#endif
#ifndef INCLUDED_mbs_io_MbsDynamicList
#include <mbs/io/MbsDynamicList.h>
#endif
#ifndef INCLUDED_mbs_io_MbsIO
#include <mbs/io/MbsIO.h>
#endif
#ifndef INCLUDED_mbs_io_MbsIntList
#include <mbs/io/MbsIntList.h>
#endif
#ifndef INCLUDED_mbs_io_MbsList
#include <mbs/io/MbsList.h>
#endif
#ifndef INCLUDED_mbs_io_MbsListBase
#include <mbs/io/MbsListBase.h>
#endif
#ifndef INCLUDED_mbs_io_MbsReader
#include <mbs/io/MbsReader.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif
#ifndef INCLUDED_openfl_utils_ByteArrayData
#include <openfl/utils/ByteArrayData.h>
#endif
#ifndef INCLUDED_openfl_utils_IDataInput
#include <openfl/utils/IDataInput.h>
#endif
#ifndef INCLUDED_openfl_utils_IDataOutput
#include <openfl/utils/IDataOutput.h>
#endif
#ifndef INCLUDED_openfl_utils__ByteArray_ByteArray_Impl_
#include <openfl/utils/_ByteArray/ByteArray_Impl_.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_2735c5affeba8556_66_new,"com.stencyl.models.Scene","new",0x357381e9,"com.stencyl.models.Scene.new","com/stencyl/models/Scene.hx",66,0x85bf5fe6)
HX_LOCAL_STACK_FRAME(_hx_pos_2735c5affeba8556_106_load,"com.stencyl.models.Scene","load",0x8e53407d,"com.stencyl.models.Scene.load","com/stencyl/models/Scene.hx",106,0x85bf5fe6)
HX_LOCAL_STACK_FRAME(_hx_pos_2735c5affeba8556_156_unload,"com.stencyl.models.Scene","unload",0x471fcb16,"com.stencyl.models.Scene.unload","com/stencyl/models/Scene.hx",156,0x85bf5fe6)
HX_LOCAL_STACK_FRAME(_hx_pos_2735c5affeba8556_173_readRegions,"com.stencyl.models.Scene","readRegions",0x86718ad2,"com.stencyl.models.Scene.readRegions","com/stencyl/models/Scene.hx",173,0x85bf5fe6)
HX_LOCAL_STACK_FRAME(_hx_pos_2735c5affeba8556_186_readRegion,"com.stencyl.models.Scene","readRegion",0xb3b02681,"com.stencyl.models.Scene.readRegion","com/stencyl/models/Scene.hx",186,0x85bf5fe6)
HX_LOCAL_STACK_FRAME(_hx_pos_2735c5affeba8556_250_addPolygonRegion,"com.stencyl.models.Scene","addPolygonRegion",0xceb07904,"com.stencyl.models.Scene.addPolygonRegion","com/stencyl/models/Scene.hx",250,0x85bf5fe6)
HX_LOCAL_STACK_FRAME(_hx_pos_2735c5affeba8556_259_addPolygonTerrain,"com.stencyl.models.Scene","addPolygonTerrain",0xba3501a5,"com.stencyl.models.Scene.addPolygonTerrain","com/stencyl/models/Scene.hx",259,0x85bf5fe6)
HX_LOCAL_STACK_FRAME(_hx_pos_2735c5affeba8556_268_readTerrainRegions,"com.stencyl.models.Scene","readTerrainRegions",0x1e22dc57,"com.stencyl.models.Scene.readTerrainRegions","com/stencyl/models/Scene.hx",268,0x85bf5fe6)
HX_LOCAL_STACK_FRAME(_hx_pos_2735c5affeba8556_281_readTerrainRegion,"com.stencyl.models.Scene","readTerrainRegion",0xb5842c9c,"com.stencyl.models.Scene.readTerrainRegion","com/stencyl/models/Scene.hx",281,0x85bf5fe6)
HX_LOCAL_STACK_FRAME(_hx_pos_2735c5affeba8556_324_readJoints,"com.stencyl.models.Scene","readJoints",0x442d4d76,"com.stencyl.models.Scene.readJoints","com/stencyl/models/Scene.hx",324,0x85bf5fe6)
HX_LOCAL_STACK_FRAME(_hx_pos_2735c5affeba8556_337_readJoint,"com.stencyl.models.Scene","readJoint",0x1186845d,"com.stencyl.models.Scene.readJoint","com/stencyl/models/Scene.hx",337,0x85bf5fe6)
HX_LOCAL_STACK_FRAME(_hx_pos_2735c5affeba8556_420_readAllLayers,"com.stencyl.models.Scene","readAllLayers",0xeb916216,"com.stencyl.models.Scene.readAllLayers","com/stencyl/models/Scene.hx",420,0x85bf5fe6)
HX_LOCAL_STACK_FRAME(_hx_pos_2735c5affeba8556_472_readColorBackground,"com.stencyl.models.Scene","readColorBackground",0x1051c404,"com.stencyl.models.Scene.readColorBackground","com/stencyl/models/Scene.hx",472,0x85bf5fe6)
HX_LOCAL_STACK_FRAME(_hx_pos_2735c5affeba8556_495_readRawLayers,"com.stencyl.models.Scene","readRawLayers",0x41da8e1d,"com.stencyl.models.Scene.readRawLayers","com/stencyl/models/Scene.hx",495,0x85bf5fe6)
HX_LOCAL_STACK_FRAME(_hx_pos_2735c5affeba8556_519_readRawLayer,"com.stencyl.models.Scene","readRawLayer",0x20705596,"com.stencyl.models.Scene.readRawLayer","com/stencyl/models/Scene.hx",519,0x85bf5fe6)
HX_LOCAL_STACK_FRAME(_hx_pos_2735c5affeba8556_617_readAtlases,"com.stencyl.models.Scene","readAtlases",0x9e99444c,"com.stencyl.models.Scene.readAtlases","com/stencyl/models/Scene.hx",617,0x85bf5fe6)
HX_LOCAL_STACK_FRAME(_hx_pos_2735c5affeba8556_636_readWireframes,"com.stencyl.models.Scene","readWireframes",0x9d4fd5b8,"com.stencyl.models.Scene.readWireframes","com/stencyl/models/Scene.hx",636,0x85bf5fe6)
HX_LOCAL_STACK_FRAME(_hx_pos_2735c5affeba8556_670_readActors,"com.stencyl.models.Scene","readActors",0xc96e316b,"com.stencyl.models.Scene.readActors","com/stencyl/models/Scene.hx",670,0x85bf5fe6)
HX_LOCAL_STACK_FRAME(_hx_pos_2735c5affeba8556_687_readActorInstance,"com.stencyl.models.Scene","readActorInstance",0x722939bd,"com.stencyl.models.Scene.readActorInstance","com/stencyl/models/Scene.hx",687,0x85bf5fe6)
HX_LOCAL_STACK_FRAME(_hx_pos_2735c5affeba8556_751_getID,"com.stencyl.models.Scene","getID",0x12f677ba,"com.stencyl.models.Scene.getID","com/stencyl/models/Scene.hx",751,0x85bf5fe6)
HX_LOCAL_STACK_FRAME(_hx_pos_2735c5affeba8556_633_boot,"com.stencyl.models.Scene","boot",0x87b72a89,"com.stencyl.models.Scene.boot","com/stencyl/models/Scene.hx",633,0x85bf5fe6)
namespace com{
namespace stencyl{
namespace models{

void Scene_obj::__construct(int ID,::String name){
            	HX_STACKFRAME(&_hx_pos_2735c5affeba8556_66_new)
HXLINE( 247)		this->currH = (int)0;
HXLINE( 246)		this->currW = (int)0;
HXLINE( 101)		this->ID = ID;
HXLINE( 102)		this->name = name;
            	}

Dynamic Scene_obj::__CreateEmpty() { return new Scene_obj; }

void *Scene_obj::_hx_vtable = 0;

Dynamic Scene_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Scene_obj > _hx_result = new Scene_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool Scene_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x1c92f1f3;
}

void Scene_obj::load(){
            	HX_GC_STACKFRAME(&_hx_pos_2735c5affeba8556_106_load)
HXLINE( 107)		 ::mbs::io::MbsReader r =  ::mbs::io::MbsReader_obj::__alloc( HX_CTX ,::com::stencyl::io::mbs::Typedefs_obj::get(),false,true);
HXLINE( 108)		r->readData(::openfl::utils::_ByteArray::ByteArray_Impl__obj::toArrayBuffer(::com::stencyl::utils::Assets_obj::getBytes(((HX_("assets/data/scene-",1a,db,4b,01) + this->ID) + HX_(".mbs",10,dc,ba,1e)))));
HXLINE( 110)		 ::com::stencyl::io::mbs::scene::MbsScene scene = ( ( ::com::stencyl::io::mbs::scene::MbsScene)(r->getRoot()) );
HXLINE( 112)		int numTileLayers = scene->getDepth();
HXLINE( 114)		this->sceneWidth = scene->getWidth();
HXLINE( 115)		this->sceneHeight = scene->getHeight();
HXLINE( 117)		this->tileWidth = scene->getTileWidth();
HXLINE( 118)		this->tileHeight = scene->getTileHeight();
HXLINE( 120)		this->gravityX = scene->getGravityX();
HXLINE( 121)		this->gravityY = scene->getGravityY();
HXLINE( 123)		this->animatedTiles = ::Array_obj< ::Dynamic>::__new();
HXLINE( 125)		this->actors = this->readActors(scene->getActorInstances());
HXLINE( 126)		this->behaviorValues = ::com::stencyl::io::AttributeValues_obj::readBehaviors(scene->getSnippets());
HXLINE( 128)		int eventSnippetID = scene->getEventSnippetID();
HXLINE( 130)		if ((eventSnippetID > (int)-1)) {
HXLINE( 132)			::Dynamic this1 = this->behaviorValues;
HXDLIN( 132)			( ( ::haxe::ds::StringMap)(this1) )->set((HX_("",00,00,00,00) + eventSnippetID), ::com::stencyl::behavior::BehaviorInstance_obj::__alloc( HX_CTX ,eventSnippetID, ::haxe::ds::StringMap_obj::__alloc( HX_CTX )));
            		}
HXLINE( 135)		this->joints = this->readJoints(scene->getJoints());
HXLINE( 136)		this->regions = this->readRegions(scene->getRegions());
HXLINE( 137)		this->terrainRegions = this->readTerrainRegions(scene->getTerrainRegions());
HXLINE( 139)		this->wireframes = this->readWireframes(scene->getTerrain());
HXLINE( 141)		 ::openfl::utils::ByteArrayData bytes = ::com::stencyl::utils::Assets_obj::getBytes(((HX_("assets/data/scene-",1a,db,4b,01) + this->ID) + HX_(".scn",70,6a,bf,1e)));
HXLINE( 142)		bytes->_hx___endian = (int)0;
HXLINE( 143)		 ::de::polygonal::ds::IntHashTable rawLayers = this->readRawLayers(bytes,numTileLayers);
HXLINE( 145)		this->layers = this->readAllLayers(scene->getLayers(),rawLayers);
HXLINE( 147)		this->retainsAtlases = scene->getRetainAtlases();
HXLINE( 149)		if (!(this->retainsAtlases)) {
HXLINE( 150)			this->atlases = this->readAtlases(scene->getAtlasMembers());
            		}
            		else {
HXLINE( 152)			this->atlases = ::Array_obj< int >::__new();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Scene_obj,load,(void))

void Scene_obj::unload(){
            	HX_STACKFRAME(&_hx_pos_2735c5affeba8556_156_unload)
HXLINE( 157)		this->colorBackground = null();
HXLINE( 159)		this->actors = null();
HXLINE( 160)		this->behaviorValues = null();
HXLINE( 161)		this->layers = null();
HXLINE( 164)		this->wireframes = null();
HXLINE( 165)		this->joints = null();
HXLINE( 166)		this->regions = null();
HXLINE( 167)		this->terrainRegions = null();
HXLINE( 169)		this->animatedTiles = null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Scene_obj,unload,(void))

 ::haxe::ds::IntMap Scene_obj::readRegions( ::mbs::io::MbsList list){
            	HX_GC_STACKFRAME(&_hx_pos_2735c5affeba8556_173_readRegions)
HXLINE( 174)		 ::haxe::ds::IntMap map =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXLINE( 176)		{
HXLINE( 176)			int _g1 = (int)0;
HXDLIN( 176)			int _g = list->length();
HXDLIN( 176)			while((_g1 < _g)){
HXLINE( 176)				_g1 = (_g1 + (int)1);
HXDLIN( 176)				int i = (_g1 - (int)1);
HXLINE( 178)				 ::com::stencyl::models::scene::RegionDef r = this->readRegion(list->getNextObject().StaticCast<  ::com::stencyl::io::mbs::scene::physics::MbsRegion >());
HXLINE( 179)				map->set(r->ID,r);
            			}
            		}
HXLINE( 182)		return map;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Scene_obj,readRegions,return )

 ::com::stencyl::models::scene::RegionDef Scene_obj::readRegion( ::com::stencyl::io::mbs::scene::physics::MbsRegion r){
            	HX_GC_STACKFRAME(&_hx_pos_2735c5affeba8556_186_readRegion)
HXLINE( 187)		int elementID = r->getId();
HXLINE( 188)		::String name = r->getName();
HXLINE( 189)		 ::com::stencyl::models::scene::RegionDef region;
HXLINE( 191)		Float x = r->getX();
HXLINE( 192)		Float y = r->getY();
HXLINE( 194)		 ::box2D::collision::shapes::B2Shape shape = null();
HXLINE( 195)		::Array< ::Dynamic> ps = ::Array_obj< ::Dynamic>::__new();
HXLINE( 196)		this->shapeList = ::Array_obj< ::Dynamic>::__new();
HXLINE( 197)		::Array< ::String > decompParams;
HXLINE( 199)		 ::Dynamic shapeData = r->getShape();
HXLINE( 201)		if (::Std_obj::is(shapeData,hx::ClassOf< ::com::stencyl::io::mbs::shape::MbsPolyRegion >())) {
HXLINE( 203)			 ::com::stencyl::io::mbs::shape::MbsPolyRegion polygon = ( ( ::com::stencyl::io::mbs::shape::MbsPolyRegion)(shapeData) );
HXLINE( 204)			int w = (this->currW = polygon->getWidth());
HXLINE( 205)			int h = (this->currH = polygon->getHeight());
HXLINE( 207)			 ::mbs::io::MbsList ptList = polygon->getPoints();
HXLINE( 209)			if (::com::stencyl::Engine_obj::NO_PHYSICS) {
HXLINE( 211)				::Array< ::Dynamic> region1 = this->shapeList;
HXDLIN( 211)				region =  ::com::stencyl::models::scene::RegionDef_obj::__alloc( HX_CTX ,region1,elementID,name,x,y,(int)0, ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,(int)0,(int)0,w,h));
            			}
            			else {
HXLINE( 216)				::Array< ::Dynamic> points = ::com::stencyl::io::ShapeReader_obj::readPoints(ptList)->copy();
HXLINE( 217)				 ::com::stencyl::utils::PolyDecompBayazit decomp =  ::com::stencyl::utils::PolyDecompBayazit_obj::__alloc( HX_CTX ,points);
HXLINE( 218)				decomp->decompose(this->addPolygonRegion_dyn());
HXLINE( 219)				region =  ::com::stencyl::models::scene::RegionDef_obj::__alloc( HX_CTX ,this->shapeList,elementID,name,x,y,null(),null());
            			}
            		}
            		else {
HXLINE( 225)			 ::com::stencyl::io::mbs::shape::MbsCircle circle = ( ( ::com::stencyl::io::mbs::shape::MbsCircle)(shapeData) );
HXLINE( 226)			Float radius = circle->getRadius();
HXLINE( 228)			if (::com::stencyl::Engine_obj::NO_PHYSICS) {
HXLINE( 230)				::Array< ::Dynamic> region2 = this->shapeList;
HXDLIN( 230)				region =  ::com::stencyl::models::scene::RegionDef_obj::__alloc( HX_CTX ,region2,elementID,name,x,y,(int)0, ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,(int)0,(int)0,(radius * (int)2),(radius * (int)2)));
            			}
            			else {
HXLINE( 235)				shape =  ::box2D::collision::shapes::B2CircleShape_obj::__alloc( HX_CTX ,null());
HXLINE( 236)				shape->m_radius = ::com::stencyl::Engine_obj::toPhysicalUnits(radius);
HXLINE( 237)				this->shapeList[(int)0] = shape;
HXLINE( 238)				region =  ::com::stencyl::models::scene::RegionDef_obj::__alloc( HX_CTX ,this->shapeList,elementID,name,x,y,null(),null());
            			}
            		}
HXLINE( 242)		return region;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Scene_obj,readRegion,return )

void Scene_obj::addPolygonRegion( ::com::stencyl::utils::PolyDecompBayazit p){
            	HX_STACKFRAME(&_hx_pos_2735c5affeba8556_250_addPolygonRegion)
HXLINE( 251)		 ::Dynamic _hx_tmp = ::haxe::Log_obj::trace;
HXDLIN( 251)		::String _hx_tmp1 = (HX_("THE POLY: ",e1,1b,51,b5) + ::Std_obj::string(p->points));
HXDLIN( 251)		_hx_tmp(_hx_tmp1,hx::SourceInfo(HX_("Scene.hx",12,fd,2c,9b),251,HX_("com.stencyl.models.Scene",77,59,68,94),HX_("addPolygonRegion",2d,2c,c9,05)));
HXLINE( 252)		 ::Dynamic _hx_tmp2 = ::haxe::Log_obj::trace;
HXDLIN( 252)		_hx_tmp2(((this->currW + HX_(", ",74,26,00,00)) + this->currH),hx::SourceInfo(HX_("Scene.hx",12,fd,2c,9b),252,HX_("com.stencyl.models.Scene",77,59,68,94),HX_("addPolygonRegion",2d,2c,c9,05)));
HXLINE( 254)		 ::box2D::collision::shapes::B2PolygonShape polyShape = hx::TCast<  ::box2D::collision::shapes::B2PolygonShape >::cast(::com::stencyl::io::ShapeReader_obj::createPolygon(HX_("MbsPolyRegion",5e,5d,18,96),p->points,this->currW,this->currH));
HXLINE( 255)		this->shapeList->push(polyShape);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Scene_obj,addPolygonRegion,(void))

void Scene_obj::addPolygonTerrain( ::com::stencyl::utils::PolyDecompBayazit p){
            	HX_STACKFRAME(&_hx_pos_2735c5affeba8556_259_addPolygonTerrain)
HXLINE( 260)		 ::Dynamic _hx_tmp = ::haxe::Log_obj::trace;
HXDLIN( 260)		::String _hx_tmp1 = (HX_("THE POLY: ",e1,1b,51,b5) + ::Std_obj::string(p->points));
HXDLIN( 260)		_hx_tmp(_hx_tmp1,hx::SourceInfo(HX_("Scene.hx",12,fd,2c,9b),260,HX_("com.stencyl.models.Scene",77,59,68,94),HX_("addPolygonTerrain",5c,12,b9,b8)));
HXLINE( 261)		 ::Dynamic _hx_tmp2 = ::haxe::Log_obj::trace;
HXDLIN( 261)		_hx_tmp2(((this->currW + HX_(", ",74,26,00,00)) + this->currH),hx::SourceInfo(HX_("Scene.hx",12,fd,2c,9b),261,HX_("com.stencyl.models.Scene",77,59,68,94),HX_("addPolygonTerrain",5c,12,b9,b8)));
HXLINE( 263)		 ::box2D::collision::shapes::B2PolygonShape polyShape = hx::TCast<  ::box2D::collision::shapes::B2PolygonShape >::cast(::com::stencyl::io::ShapeReader_obj::createPolygon(HX_("MbsPolyRegion",5e,5d,18,96),p->points,this->currW,this->currH));
HXLINE( 264)		this->shapeList->push(polyShape);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Scene_obj,addPolygonTerrain,(void))

 ::haxe::ds::IntMap Scene_obj::readTerrainRegions( ::mbs::io::MbsList list){
            	HX_GC_STACKFRAME(&_hx_pos_2735c5affeba8556_268_readTerrainRegions)
HXLINE( 269)		 ::haxe::ds::IntMap map =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXLINE( 271)		{
HXLINE( 271)			int _g1 = (int)0;
HXDLIN( 271)			int _g = list->length();
HXDLIN( 271)			while((_g1 < _g)){
HXLINE( 271)				_g1 = (_g1 + (int)1);
HXDLIN( 271)				int i = (_g1 - (int)1);
HXLINE( 273)				 ::com::stencyl::models::scene::TerrainDef r = this->readTerrainRegion(list->getNextObject().StaticCast<  ::com::stencyl::io::mbs::scene::physics::MbsTerrainRegion >());
HXLINE( 274)				map->set(r->ID,r);
            			}
            		}
HXLINE( 277)		return map;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Scene_obj,readTerrainRegions,return )

 ::com::stencyl::models::scene::TerrainDef Scene_obj::readTerrainRegion( ::com::stencyl::io::mbs::scene::physics::MbsTerrainRegion r){
            	HX_GC_STACKFRAME(&_hx_pos_2735c5affeba8556_281_readTerrainRegion)
HXLINE( 282)		int elementID = r->getId();
HXLINE( 283)		::String name = r->getName();
HXLINE( 284)		int group = r->getGroupID();
HXLINE( 285)		 ::com::stencyl::models::scene::TerrainDef terrainRegion;
HXLINE( 287)		Float x = ::com::stencyl::Engine_obj::toPhysicalUnits(r->getX());
HXLINE( 288)		Float y = ::com::stencyl::Engine_obj::toPhysicalUnits(r->getY());
HXLINE( 289)		int fillColor = r->getColor();
HXLINE( 291)		 ::box2D::collision::shapes::B2Shape shape = null();
HXLINE( 292)		::Array< ::Dynamic> ps = ::Array_obj< ::Dynamic>::__new();
HXLINE( 293)		this->shapeList = ::Array_obj< ::Dynamic>::__new();
HXLINE( 294)		::Array< ::String > decompParams;
HXLINE( 296)		 ::Dynamic shapeData = r->getShape();
HXLINE( 298)		if (::Std_obj::is(shapeData,hx::ClassOf< ::com::stencyl::io::mbs::shape::MbsPolyRegion >())) {
HXLINE( 300)			 ::com::stencyl::io::mbs::shape::MbsPolyRegion polygon = ( ( ::com::stencyl::io::mbs::shape::MbsPolyRegion)(shapeData) );
HXLINE( 301)			this->currW = polygon->getWidth();
HXLINE( 302)			this->currH = polygon->getHeight();
HXLINE( 304)			::Array< ::Dynamic> points = ::com::stencyl::io::ShapeReader_obj::readPoints(polygon->getPoints())->copy();
HXLINE( 305)			 ::com::stencyl::utils::PolyDecompBayazit decomp =  ::com::stencyl::utils::PolyDecompBayazit_obj::__alloc( HX_CTX ,points);
HXLINE( 306)			decomp->decompose(this->addPolygonTerrain_dyn());
HXLINE( 307)			terrainRegion =  ::com::stencyl::models::scene::TerrainDef_obj::__alloc( HX_CTX ,this->shapeList,elementID,name,x,y,group,fillColor);
            		}
            		else {
HXLINE( 312)			 ::com::stencyl::io::mbs::shape::MbsCircle circle = ( ( ::com::stencyl::io::mbs::shape::MbsCircle)(shapeData) );
HXLINE( 313)			Float radius = circle->getRadius();
HXLINE( 314)			shape =  ::box2D::collision::shapes::B2CircleShape_obj::__alloc( HX_CTX ,null());
HXLINE( 315)			shape->m_radius = ::com::stencyl::Engine_obj::toPhysicalUnits(radius);
HXLINE( 316)			this->shapeList[(int)0] = shape;
HXLINE( 317)			terrainRegion =  ::com::stencyl::models::scene::TerrainDef_obj::__alloc( HX_CTX ,this->shapeList,elementID,name,x,y,group,fillColor);
            		}
HXLINE( 320)		return terrainRegion;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Scene_obj,readTerrainRegion,return )

 ::haxe::ds::IntMap Scene_obj::readJoints( ::mbs::io::MbsDynamicList list){
            	HX_GC_STACKFRAME(&_hx_pos_2735c5affeba8556_324_readJoints)
HXLINE( 325)		 ::haxe::ds::IntMap map =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXLINE( 327)		{
HXLINE( 327)			int _g1 = (int)0;
HXDLIN( 327)			int _g = list->length();
HXDLIN( 327)			while((_g1 < _g)){
HXLINE( 327)				_g1 = (_g1 + (int)1);
HXDLIN( 327)				int i = (_g1 - (int)1);
HXLINE( 329)				 ::box2D::dynamics::joints::B2JointDef j = this->readJoint(( ( ::com::stencyl::io::mbs::scene::physics::MbsJoint)(list->readObject()) ));
HXLINE( 330)				map->set(j->ID,j);
            			}
            		}
HXLINE( 333)		return map;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Scene_obj,readJoints,return )

 ::box2D::dynamics::joints::B2JointDef Scene_obj::readJoint( ::com::stencyl::io::mbs::scene::physics::MbsJoint r){
            	HX_GC_STACKFRAME(&_hx_pos_2735c5affeba8556_337_readJoint)
HXLINE( 338)		int elementID = r->getId();
HXLINE( 340)		int a1 = r->getActor1();
HXLINE( 341)		int a2 = r->getActor2();
HXLINE( 342)		bool collide = r->getCollide();
HXLINE( 344)		if (::Std_obj::is(r,hx::ClassOf< ::com::stencyl::io::mbs::scene::physics::MbsStickJoint >())) {
HXLINE( 346)			 ::box2D::dynamics::joints::B2DistanceJointDef j =  ::box2D::dynamics::joints::B2DistanceJointDef_obj::__alloc( HX_CTX );
HXLINE( 347)			 ::com::stencyl::io::mbs::scene::physics::MbsStickJoint r2 = ( ( ::com::stencyl::io::mbs::scene::physics::MbsStickJoint)(r) );
HXLINE( 349)			j->ID = elementID;
HXLINE( 350)			j->actor1 = a1;
HXLINE( 351)			j->actor2 = a2;
HXLINE( 352)			j->localAnchorA = null();
HXLINE( 353)			j->localAnchorB = null();
HXLINE( 354)			j->collideConnected = collide;
HXLINE( 358)			j->dampingRatio = r2->getDamping();
HXLINE( 359)			j->frequencyHz = r2->getFrequency();
HXLINE( 361)			return j;
            		}
            		else {
HXLINE( 364)			if (::Std_obj::is(r,hx::ClassOf< ::com::stencyl::io::mbs::scene::physics::MbsHingeJoint >())) {
HXLINE( 366)				 ::box2D::dynamics::joints::B2RevoluteJointDef j2 =  ::box2D::dynamics::joints::B2RevoluteJointDef_obj::__alloc( HX_CTX );
HXLINE( 367)				 ::com::stencyl::io::mbs::scene::physics::MbsHingeJoint r21 = ( ( ::com::stencyl::io::mbs::scene::physics::MbsHingeJoint)(r) );
HXLINE( 369)				j2->ID = elementID;
HXLINE( 370)				j2->actor1 = a1;
HXLINE( 371)				j2->actor2 = a2;
HXLINE( 372)				j2->localAnchorA = null();
HXLINE( 373)				j2->localAnchorB = null();
HXLINE( 374)				j2->collideConnected = collide;
HXLINE( 378)				j2->enableLimit = r21->getLimit();
HXLINE( 379)				j2->enableMotor = r21->getMotor();
HXLINE( 380)				j2->lowerAngle = r21->getLower();
HXLINE( 381)				j2->upperAngle = r21->getUpper();
HXLINE( 382)				j2->maxMotorTorque = r21->getTorque();
HXLINE( 383)				j2->motorSpeed = r21->getSpeed();
HXLINE( 385)				return j2;
            			}
            			else {
HXLINE( 388)				if (::Std_obj::is(r,hx::ClassOf< ::com::stencyl::io::mbs::scene::physics::MbsSlidingJoint >())) {
HXLINE( 390)					 ::box2D::dynamics::joints::B2LineJointDef j3 =  ::box2D::dynamics::joints::B2LineJointDef_obj::__alloc( HX_CTX );
HXLINE( 391)					 ::com::stencyl::io::mbs::scene::physics::MbsSlidingJoint r22 = ( ( ::com::stencyl::io::mbs::scene::physics::MbsSlidingJoint)(r) );
HXLINE( 393)					j3->ID = elementID;
HXLINE( 394)					j3->actor1 = a1;
HXLINE( 395)					j3->actor2 = a2;
HXLINE( 396)					j3->localAnchorA = null();
HXLINE( 397)					j3->localAnchorB = null();
HXLINE( 398)					j3->collideConnected = collide;
HXLINE( 402)					j3->enableLimit = r22->getLimit();
HXLINE( 403)					j3->enableMotor = r22->getMotor();
HXLINE( 404)					j3->lowerTranslation = r22->getLower();
HXLINE( 405)					j3->upperTranslation = r22->getUpper();
HXLINE( 406)					j3->maxMotorForce = r22->getForce();
HXLINE( 407)					j3->motorSpeed = r22->getSpeed();
HXLINE( 408)					j3->localAxisA->x = r22->getX();
HXLINE( 409)					j3->localAxisA->y = r22->getY();
HXLINE( 411)					return j3;
            				}
            			}
            		}
HXLINE( 414)		 ::Dynamic _hx_tmp = ::haxe::Log_obj::trace;
HXDLIN( 414)		::String _hx_tmp1 = (HX_("Error: unsuppported joint type: ",cd,12,b3,04) + ::Std_obj::string(::com::stencyl::io::mbs::scene::MbsScene_obj::type));
HXDLIN( 414)		_hx_tmp(_hx_tmp1,hx::SourceInfo(HX_("Scene.hx",12,fd,2c,9b),414,HX_("com.stencyl.models.Scene",77,59,68,94),HX_("readJoint",14,86,0f,23)));
HXLINE( 416)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Scene_obj,readJoint,return )

 ::de::polygonal::ds::IntHashTable Scene_obj::readAllLayers( ::mbs::io::MbsDynamicList list, ::de::polygonal::ds::IntHashTable rawLayers){
            	HX_GC_STACKFRAME(&_hx_pos_2735c5affeba8556_420_readAllLayers)
HXLINE( 421)		 ::de::polygonal::ds::IntHashTable map =  ::de::polygonal::ds::IntHashTable_obj::__alloc( HX_CTX ,(int)16,null());
HXLINE( 422)		map->reuseIterator = true;
HXLINE( 424)		{
HXLINE( 424)			int _g1 = (int)0;
HXDLIN( 424)			int _g = list->length();
HXDLIN( 424)			while((_g1 < _g)){
HXLINE( 424)				_g1 = (_g1 + (int)1);
HXDLIN( 424)				int i = (_g1 - (int)1);
HXLINE( 426)				 ::mbs::core::MbsObject dyn = ( ( ::mbs::core::MbsObject)(list->readObject()) );
HXLINE( 428)				bool _hx_tmp;
HXDLIN( 428)				if (!(::Std_obj::is(dyn,hx::ClassOf< ::com::stencyl::io::mbs::scene::layers::MbsColorBackground >()))) {
HXLINE( 428)					_hx_tmp = ::Std_obj::is(dyn,hx::ClassOf< ::com::stencyl::io::mbs::scene::layers::MbsGradientBackground >());
            				}
            				else {
HXLINE( 428)					_hx_tmp = true;
            				}
HXDLIN( 428)				if (_hx_tmp) {
HXLINE( 429)					this->colorBackground = this->readColorBackground(dyn);
            				}
            				else {
HXLINE( 432)					 ::com::stencyl::io::mbs::scene::layers::MbsLayer r = ( ( ::com::stencyl::io::mbs::scene::layers::MbsLayer)(dyn) );
HXLINE( 434)					int ID = r->getId();
HXLINE( 435)					::String name = r->getName();
HXLINE( 436)					int order = r->getOrder();
HXLINE( 437)					Float scrollFactorX = r->getScrollFactorX();
HXLINE( 438)					Float scrollFactorY = r->getScrollFactorY();
HXLINE( 439)					Float opacity = ((Float)r->getOpacity() / (Float)(int)100);
HXLINE( 440)					 ::Dynamic blendMode = ::com::stencyl::graphics::BlendModes_obj::get(r->getBlendmode());
HXLINE( 442)					if (::Std_obj::is(dyn,hx::ClassOf< ::com::stencyl::io::mbs::scene::layers::MbsInteractiveLayer >())) {
HXLINE( 444)						 ::de::polygonal::ds::IntIntHashTable _this = rawLayers->mH;
HXDLIN( 444)						int i1 = _this->mHash->__get(((int)(ID * (int)73856093) & (int)_this->mMask));
HXDLIN( 444)						int i2;
HXDLIN( 444)						if ((i1 == (int)-1)) {
HXLINE( 444)							i2 = (int)-2147483647;
            						}
            						else {
HXLINE( 444)							::Array< int > d = _this->mData;
HXDLIN( 444)							if ((d->__get(i1) == ID)) {
HXLINE( 444)								i2 = d->__get((i1 + (int)1));
            							}
            							else {
HXLINE( 444)								int v = (int)-2147483647;
HXDLIN( 444)								i1 = d->__get((i1 + (int)2));
HXDLIN( 444)								while((i1 != (int)-1)){
HXLINE( 444)									if ((d->__get(i1) == ID)) {
HXLINE( 444)										v = d->__get((i1 + (int)1));
HXDLIN( 444)										goto _hx_goto_15;
            									}
HXDLIN( 444)									i1 = d->__get((i1 + (int)2));
            								}
            								_hx_goto_15:;
HXDLIN( 444)								i2 = v;
            							}
            						}
HXDLIN( 444)						 ::com::stencyl::models::scene::TileLayer tileLayer;
HXDLIN( 444)						if ((i2 == (int)-2147483647)) {
HXLINE( 444)							tileLayer = ( ( ::com::stencyl::models::scene::TileLayer)(null()) );
            						}
            						else {
HXLINE( 444)							tileLayer = Dynamic( rawLayers->mVals->__get(i2)).StaticCast<  ::com::stencyl::models::scene::TileLayer >();
            						}
HXDLIN( 444)						 ::com::stencyl::models::scene::TileLayer tileLayer1 = tileLayer;
HXLINE( 445)						if (hx::IsNull( tileLayer1 )) {
HXLINE( 446)							int tileLayer2 = ::Std_obj::_hx_int(::Math_obj::floor(((Float)this->sceneWidth / (Float)this->tileWidth)));
HXDLIN( 446)							tileLayer1 =  ::com::stencyl::models::scene::TileLayer_obj::__alloc( HX_CTX ,ID,hx::ObjectPtr<OBJ_>(this),tileLayer2,::Std_obj::_hx_int(::Math_obj::floor(((Float)this->sceneHeight / (Float)this->tileHeight))));
            						}
HXLINE( 447)						tileLayer1->set_name(name);
HXLINE( 449)						 ::com::stencyl::models::scene::Layer layer =  ::com::stencyl::models::scene::Layer_obj::__alloc( HX_CTX ,ID,name,order,scrollFactorX,scrollFactorY,opacity,blendMode,tileLayer1);
HXLINE( 451)						map->set(layer->ID,layer);
            					}
            					else {
HXLINE( 453)						if (::Std_obj::is(dyn,hx::ClassOf< ::com::stencyl::io::mbs::scene::layers::MbsImageBackground >())) {
HXLINE( 456)							 ::com::stencyl::io::mbs::scene::layers::MbsImageBackground bgR = ( ( ::com::stencyl::io::mbs::scene::layers::MbsImageBackground)(dyn) );
HXLINE( 457)							int bgID = bgR->getResourceID();
HXLINE( 458)							bool customScroll = bgR->getCustomScroll();
HXLINE( 460)							 ::com::stencyl::models::scene::layers::BackgroundLayer layer1 =  ::com::stencyl::models::scene::layers::BackgroundLayer_obj::__alloc( HX_CTX ,ID,name,order,scrollFactorX,scrollFactorY,opacity,blendMode,bgID,customScroll);
HXLINE( 462)							map->set(layer1->ID,layer1);
            						}
            					}
            				}
            			}
            		}
HXLINE( 467)		return map;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Scene_obj,readAllLayers,return )

::Dynamic Scene_obj::readColorBackground( ::mbs::core::MbsObject r){
            	HX_GC_STACKFRAME(&_hx_pos_2735c5affeba8556_472_readColorBackground)
HXDLIN( 472)		if (::Std_obj::is(r,hx::ClassOf< ::com::stencyl::io::mbs::scene::layers::MbsColorBackground >())) {
HXLINE( 474)			 ::com::stencyl::io::mbs::scene::layers::MbsColorBackground r2 = ( ( ::com::stencyl::io::mbs::scene::layers::MbsColorBackground)(r) );
HXLINE( 475)			int color = r2->getColor();
HXLINE( 476)			return  ::com::stencyl::models::background::ColorBackground_obj::__alloc( HX_CTX ,color);
            		}
            		else {
HXLINE( 479)			if (::Std_obj::is(r,hx::ClassOf< ::com::stencyl::io::mbs::scene::layers::MbsGradientBackground >())) {
HXLINE( 481)				 ::com::stencyl::io::mbs::scene::layers::MbsGradientBackground r21 = ( ( ::com::stencyl::io::mbs::scene::layers::MbsGradientBackground)(r) );
HXLINE( 482)				int color1 = r21->getColor1();
HXLINE( 483)				int color2 = r21->getColor2();
HXLINE( 485)				return  ::com::stencyl::models::background::GradientBackground_obj::__alloc( HX_CTX ,color1,color2);
            			}
            			else {
HXLINE( 490)				return null();
            			}
            		}
HXLINE( 472)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Scene_obj,readColorBackground,return )

 ::de::polygonal::ds::IntHashTable Scene_obj::readRawLayers( ::openfl::utils::ByteArrayData bytes,int numTileLayers){
            	HX_GC_STACKFRAME(&_hx_pos_2735c5affeba8556_495_readRawLayers)
HXLINE( 496)		 ::de::polygonal::ds::IntHashTable map =  ::de::polygonal::ds::IntHashTable_obj::__alloc( HX_CTX ,(int)16,null());
HXLINE( 497)		map->reuseIterator = true;
HXLINE( 499)		::Array< int > layerHeaders = ::Array_obj< int >::__new();
HXLINE( 501)		if (hx::IsNotNull( bytes )) {
HXLINE( 503)			{
HXLINE( 503)				int _g1 = (int)0;
HXDLIN( 503)				int _g = numTileLayers;
HXDLIN( 503)				while((_g1 < _g)){
HXLINE( 503)					_g1 = (_g1 + (int)1);
HXDLIN( 503)					int i = (_g1 - (int)1);
HXLINE( 505)					layerHeaders[i] = bytes->readInt();
            				}
            			}
HXLINE( 508)			{
HXLINE( 508)				int _g11 = (int)0;
HXDLIN( 508)				int _g2 = numTileLayers;
HXDLIN( 508)				while((_g11 < _g2)){
HXLINE( 508)					_g11 = (_g11 + (int)1);
HXDLIN( 508)					int i1 = (_g11 - (int)1);
HXLINE( 510)					 ::com::stencyl::models::scene::TileLayer newLayer = this->readRawLayer(bytes,layerHeaders->__get(i1));
HXLINE( 511)					map->set(newLayer->layerID,newLayer);
            				}
            			}
            		}
HXLINE( 515)		return map;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Scene_obj,readRawLayers,return )

 ::com::stencyl::models::scene::TileLayer Scene_obj::readRawLayer( ::openfl::utils::ByteArrayData bytes,int length){
            	HX_GC_STACKFRAME(&_hx_pos_2735c5affeba8556_519_readRawLayer)
HXLINE( 520)		int width = ::Std_obj::_hx_int(::Math_obj::floor(((Float)this->sceneWidth / (Float)this->tileWidth)));
HXLINE( 521)		int height = ::Std_obj::_hx_int(::Math_obj::floor(((Float)this->sceneHeight / (Float)this->tileHeight)));
HXLINE( 523)		int layerID = bytes->readInt();
HXLINE( 524)		length = (length - (int)4);
HXLINE( 526)		int zOrder = bytes->readInt();
HXLINE( 527)		length = (length - (int)4);
HXLINE( 529)		 ::com::stencyl::models::scene::TileLayer layer =  ::com::stencyl::models::scene::TileLayer_obj::__alloc( HX_CTX ,layerID,hx::ObjectPtr<OBJ_>(this),width,height);
HXLINE( 531)		bool noTiles = true;
HXLINE( 532)		int row = (int)0;
HXLINE( 533)		int col = (int)0;
HXLINE( 535)		int RLETILE_BYTE_COUNT = (int)8;
HXLINE( 536)		int numChunks = ::Std_obj::_hx_int(((Float)length / (Float)RLETILE_BYTE_COUNT));
HXLINE( 539)		 ::com::stencyl::models::collision::Grid grid =  ::com::stencyl::models::collision::Grid_obj::__alloc( HX_CTX ,this->sceneWidth,this->sceneHeight,this->tileWidth,this->tileHeight,null(),null());
HXLINE( 540)		layer->grid = grid;
HXLINE( 542)		{
HXLINE( 542)			int _g1 = (int)0;
HXDLIN( 542)			int _g = numChunks;
HXDLIN( 542)			while((_g1 < _g)){
HXLINE( 542)				_g1 = (_g1 + (int)1);
HXDLIN( 542)				int i = (_g1 - (int)1);
HXLINE( 544)				int autotileFlag = bytes->readShort();
HXLINE( 545)				int tilesetID = bytes->readShort();
HXLINE( 546)				int tileID = bytes->readShort();
HXLINE( 547)				int runLength = bytes->readShort();
HXLINE( 549)				 ::com::stencyl::models::scene::Tileset tset = null();
HXLINE( 551)				if ((tilesetID != (int)-1)) {
HXLINE( 553)					tset = ( ( ::com::stencyl::models::scene::Tileset)(::com::stencyl::Data_obj::get()->resources->get(tilesetID).StaticCast<  ::com::stencyl::models::Resource >()) );
            				}
HXLINE( 556)				if ((autotileFlag < (int)0)) {
HXLINE( 557)					autotileFlag = ::Std_obj::_hx_int(::Math_obj::abs((autotileFlag + (int)1)));
            				}
HXLINE( 559)				{
HXLINE( 559)					int _g3 = (int)0;
HXDLIN( 559)					int _g2 = runLength;
HXDLIN( 559)					while((_g3 < _g2)){
HXLINE( 559)						_g3 = (_g3 + (int)1);
HXDLIN( 559)						int runIndex = (_g3 - (int)1);
HXLINE( 561)						bool _hx_tmp;
HXDLIN( 561)						if (hx::IsNotNull( tset )) {
HXLINE( 561)							_hx_tmp = (tileID < (int)0);
            						}
            						else {
HXLINE( 561)							_hx_tmp = true;
            						}
HXDLIN( 561)						if (_hx_tmp) {
HXLINE( 563)							layer->setTileAt(row,col,null(),false);
            						}
            						else {
HXLINE( 568)							 ::com::stencyl::models::scene::Tile tile = tset->tiles->__get(tileID).StaticCast<  ::com::stencyl::models::scene::Tile >();
HXLINE( 570)							if (hx::IsNull( tile )) {
HXLINE( 572)								layer->setTileAt(row,col,null(),false);
            							}
            							else {
HXLINE( 577)								layer->setTileAt(row,col,tile,false);
HXLINE( 578)								layer->autotileData->__get(row).StaticCast< ::Array< int > >()[col] = autotileFlag;
HXLINE( 580)								if ((tile->collisionID >= (int)0)) {
HXLINE( 582)									grid->setTile(col,row,true);
            								}
HXLINE( 585)								if ((tile->durations->length > (int)1)) {
HXLINE( 587)									bool inList = false;
HXLINE( 589)									{
HXLINE( 589)										int _g4 = (int)0;
HXDLIN( 589)										::Array< ::Dynamic> _g5 = this->animatedTiles;
HXDLIN( 589)										while((_g4 < _g5->length)){
HXLINE( 589)											 ::com::stencyl::models::scene::Tile checkTile = _g5->__get(_g4).StaticCast<  ::com::stencyl::models::scene::Tile >();
HXDLIN( 589)											_g4 = (_g4 + (int)1);
HXLINE( 591)											inList = hx::IsEq( checkTile,tile );
HXDLIN( 591)											if (inList) {
HXLINE( 592)												goto _hx_goto_23;
            											}
            										}
            										_hx_goto_23:;
            									}
HXLINE( 595)									if (!(inList)) {
HXLINE( 597)										this->animatedTiles->push(tile);
            									}
            								}
            							}
            						}
HXLINE( 603)						col = (col + (int)1);
HXLINE( 605)						if ((col >= width)) {
HXLINE( 607)							col = (int)0;
HXLINE( 608)							row = (row + (int)1);
            						}
            					}
            				}
            			}
            		}
HXLINE( 613)		return layer;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Scene_obj,readRawLayer,return )

::Array< int > Scene_obj::readAtlases( ::mbs::io::MbsIntList r){
            	HX_STACKFRAME(&_hx_pos_2735c5affeba8556_617_readAtlases)
HXLINE( 618)		::Array< int > members = ::Array_obj< int >::__new();
HXLINE( 620)		{
HXLINE( 620)			int _g1 = (int)0;
HXDLIN( 620)			int _g = r->length();
HXDLIN( 620)			while((_g1 < _g)){
HXLINE( 620)				_g1 = (_g1 + (int)1);
HXDLIN( 620)				int i = (_g1 - (int)1);
HXLINE( 622)				int atlasID = r->readInt();
HXLINE( 624)				if (::com::stencyl::models::GameModel_obj::get()->atlases->get(atlasID).StaticCast<  ::com::stencyl::models::Atlas >()->allScenes) {
HXLINE( 625)					continue;
            				}
HXLINE( 627)				members->push(atlasID);
            			}
            		}
HXLINE( 630)		return members;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Scene_obj,readAtlases,return )

::Array< ::Dynamic> Scene_obj::readWireframes( ::mbs::io::MbsList list){
            	HX_GC_STACKFRAME(&_hx_pos_2735c5affeba8556_636_readWireframes)
HXLINE( 637)		if (::com::stencyl::Engine_obj::NO_PHYSICS) {
HXLINE( 639)			return ::Array_obj< ::Dynamic>::__new();
            		}
HXLINE( 642)		::Array< ::Dynamic> map = ::Array_obj< ::Dynamic>::__new();
HXLINE( 644)		{
HXLINE( 644)			int _g1 = (int)0;
HXDLIN( 644)			int _g = list->length();
HXDLIN( 644)			while((_g1 < _g)){
HXLINE( 644)				_g1 = (_g1 + (int)1);
HXDLIN( 644)				int i = (_g1 - (int)1);
HXLINE( 646)				 ::com::stencyl::io::mbs::shape::MbsWireframe poly = list->getNextObject().StaticCast<  ::com::stencyl::io::mbs::shape::MbsWireframe >();
HXLINE( 648)				 ::com::stencyl::io::mbs::shape::MbsPoint r = poly->getPosition();
HXDLIN( 648)				Float position = r->getX();
HXDLIN( 648)				 ::openfl::geom::Point position1 =  ::openfl::geom::Point_obj::__alloc( HX_CTX ,position,r->getY());
HXLINE( 649)				::Array< ::Dynamic> points = ::com::stencyl::io::ShapeReader_obj::readPoints(poly->getPoints())->copy();
HXLINE( 650)				 ::haxe::ds::IntMap shapeData = ( ( ::haxe::ds::IntMap)(::com::stencyl::io::ShapeReader_obj::createPolygon(HX_("MbsWireframe",8a,2a,06,90),points,null(),null())) );
HXLINE( 656)				Float position2 = position1->x;
HXLINE( 657)				Float position3 = position1->y;
HXLINE( 658)				 ::Dynamic _hx_tmp = shapeData->get((int)1);
HXLINE( 659)				 ::Dynamic _hx_tmp1 = shapeData->get((int)2);
HXLINE( 652)				map->push( ::com::stencyl::models::scene::Wireframe_obj::__alloc( HX_CTX ,position2,position3,_hx_tmp,_hx_tmp1,shapeData->get((int)0),null()));
            			}
            		}
HXLINE( 666)		return map;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Scene_obj,readWireframes,return )

 ::haxe::ds::IntMap Scene_obj::readActors( ::mbs::io::MbsList list){
            	HX_GC_STACKFRAME(&_hx_pos_2735c5affeba8556_670_readActors)
HXLINE( 671)		 ::haxe::ds::IntMap map =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXLINE( 673)		{
HXLINE( 673)			int _g1 = (int)0;
HXDLIN( 673)			int _g = list->length();
HXDLIN( 673)			while((_g1 < _g)){
HXLINE( 673)				_g1 = (_g1 + (int)1);
HXDLIN( 673)				int i = (_g1 - (int)1);
HXLINE( 675)				 ::com::stencyl::models::scene::ActorInstance ai = this->readActorInstance(list->getNextObject().StaticCast<  ::com::stencyl::io::mbs::scene::MbsActorInstance >());
HXLINE( 677)				if (hx::IsNotNull( ai )) {
HXLINE( 679)					map->set(ai->elementID,ai);
            				}
            			}
            		}
HXLINE( 683)		return map;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Scene_obj,readActors,return )

 ::com::stencyl::models::scene::ActorInstance Scene_obj::readActorInstance( ::com::stencyl::io::mbs::scene::MbsActorInstance r){
            	HX_GC_STACKFRAME(&_hx_pos_2735c5affeba8556_687_readActorInstance)
HXLINE( 688)		int elementID = r->getAid();
HXLINE( 689)		int x = r->getX();
HXLINE( 690)		int y = r->getY();
HXLINE( 692)		Float scaleX = r->getScaleX();
HXLINE( 693)		Float scaleY = r->getScaleY();
HXLINE( 695)		int layerID = r->getZ();
HXLINE( 696)		int orderInLayer = r->getOrderInLayer();
HXLINE( 697)		int angle = ::Std_obj::_hx_int(r->getAngle());
HXLINE( 698)		int groupID = r->getGroupID();
HXLINE( 699)		int actorID = r->getId();
HXLINE( 700)		bool isCustomized = r->getCustomized();
HXLINE( 702)		 ::haxe::ds::StringMap behaviors = null();
HXLINE( 704)		if (isCustomized) {
HXLINE( 706)			behaviors = ::com::stencyl::io::AttributeValues_obj::readBehaviors(r->getSnippets());
            		}
HXLINE( 709)		bool _hx_tmp;
HXDLIN( 709)		if ((scaleX != (int)0)) {
HXLINE( 709)			_hx_tmp = (scaleY == (int)0);
            		}
            		else {
HXLINE( 709)			_hx_tmp = true;
            		}
HXDLIN( 709)		if (_hx_tmp) {
HXLINE( 711)			scaleX = (int)1;
HXLINE( 712)			scaleY = (int)1;
            		}
HXLINE( 715)		if (!(isCustomized)) {
HXLINE( 717)			behaviors = null();
            		}
HXLINE( 720)		if (hx::IsNull( ::com::stencyl::Data_obj::get()->resources->get(actorID).StaticCast<  ::com::stencyl::models::Resource >() )) {
HXLINE( 722)			return null();
            		}
HXLINE( 725)		 ::com::stencyl::models::scene::ActorInstance ai =  ::com::stencyl::models::scene::ActorInstance_obj::__alloc( HX_CTX ,elementID,x,y,scaleX,scaleY,layerID,orderInLayer,angle,groupID,actorID,behaviors,isCustomized);
HXLINE( 741)		if (hx::IsNotNull( ai->actorType )) {
HXLINE( 743)			ai->groupID = ai->actorType->groupID;
            		}
HXLINE( 746)		return ai;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Scene_obj,readActorInstance,return )

int Scene_obj::getID(){
            	HX_STACKFRAME(&_hx_pos_2735c5affeba8556_751_getID)
HXDLIN( 751)		return this->ID;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Scene_obj,getID,return )

int Scene_obj::MAX_VERTICES;


hx::ObjectPtr< Scene_obj > Scene_obj::__new(int ID,::String name) {
	hx::ObjectPtr< Scene_obj > __this = new Scene_obj();
	__this->__construct(ID,name);
	return __this;
}

hx::ObjectPtr< Scene_obj > Scene_obj::__alloc(hx::Ctx *_hx_ctx,int ID,::String name) {
	Scene_obj *__this = (Scene_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Scene_obj), true, "com.stencyl.models.Scene"));
	*(void **)__this = Scene_obj::_hx_vtable;
	__this->__construct(ID,name);
	return __this;
}

Scene_obj::Scene_obj()
{
}

void Scene_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Scene);
	HX_MARK_MEMBER_NAME(ID,"ID");
	HX_MARK_MEMBER_NAME(name,"name");
	HX_MARK_MEMBER_NAME(sceneWidth,"sceneWidth");
	HX_MARK_MEMBER_NAME(sceneHeight,"sceneHeight");
	HX_MARK_MEMBER_NAME(tileWidth,"tileWidth");
	HX_MARK_MEMBER_NAME(tileHeight,"tileHeight");
	HX_MARK_MEMBER_NAME(gravityX,"gravityX");
	HX_MARK_MEMBER_NAME(gravityY,"gravityY");
	HX_MARK_MEMBER_NAME(eventID,"eventID");
	HX_MARK_MEMBER_NAME(colorBackground,"colorBackground");
	HX_MARK_MEMBER_NAME(layers,"layers");
	HX_MARK_MEMBER_NAME(actors,"actors");
	HX_MARK_MEMBER_NAME(behaviorValues,"behaviorValues");
	HX_MARK_MEMBER_NAME(atlases,"atlases");
	HX_MARK_MEMBER_NAME(retainsAtlases,"retainsAtlases");
	HX_MARK_MEMBER_NAME(wireframes,"wireframes");
	HX_MARK_MEMBER_NAME(joints,"joints");
	HX_MARK_MEMBER_NAME(regions,"regions");
	HX_MARK_MEMBER_NAME(terrainRegions,"terrainRegions");
	HX_MARK_MEMBER_NAME(animatedTiles,"animatedTiles");
	HX_MARK_MEMBER_NAME(shapeList,"shapeList");
	HX_MARK_MEMBER_NAME(currW,"currW");
	HX_MARK_MEMBER_NAME(currH,"currH");
	HX_MARK_END_CLASS();
}

void Scene_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(ID,"ID");
	HX_VISIT_MEMBER_NAME(name,"name");
	HX_VISIT_MEMBER_NAME(sceneWidth,"sceneWidth");
	HX_VISIT_MEMBER_NAME(sceneHeight,"sceneHeight");
	HX_VISIT_MEMBER_NAME(tileWidth,"tileWidth");
	HX_VISIT_MEMBER_NAME(tileHeight,"tileHeight");
	HX_VISIT_MEMBER_NAME(gravityX,"gravityX");
	HX_VISIT_MEMBER_NAME(gravityY,"gravityY");
	HX_VISIT_MEMBER_NAME(eventID,"eventID");
	HX_VISIT_MEMBER_NAME(colorBackground,"colorBackground");
	HX_VISIT_MEMBER_NAME(layers,"layers");
	HX_VISIT_MEMBER_NAME(actors,"actors");
	HX_VISIT_MEMBER_NAME(behaviorValues,"behaviorValues");
	HX_VISIT_MEMBER_NAME(atlases,"atlases");
	HX_VISIT_MEMBER_NAME(retainsAtlases,"retainsAtlases");
	HX_VISIT_MEMBER_NAME(wireframes,"wireframes");
	HX_VISIT_MEMBER_NAME(joints,"joints");
	HX_VISIT_MEMBER_NAME(regions,"regions");
	HX_VISIT_MEMBER_NAME(terrainRegions,"terrainRegions");
	HX_VISIT_MEMBER_NAME(animatedTiles,"animatedTiles");
	HX_VISIT_MEMBER_NAME(shapeList,"shapeList");
	HX_VISIT_MEMBER_NAME(currW,"currW");
	HX_VISIT_MEMBER_NAME(currH,"currH");
}

hx::Val Scene_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"ID") ) { return hx::Val( ID ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"name") ) { return hx::Val( name ); }
		if (HX_FIELD_EQ(inName,"load") ) { return hx::Val( load_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"currW") ) { return hx::Val( currW ); }
		if (HX_FIELD_EQ(inName,"currH") ) { return hx::Val( currH ); }
		if (HX_FIELD_EQ(inName,"getID") ) { return hx::Val( getID_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"layers") ) { return hx::Val( layers ); }
		if (HX_FIELD_EQ(inName,"actors") ) { return hx::Val( actors ); }
		if (HX_FIELD_EQ(inName,"joints") ) { return hx::Val( joints ); }
		if (HX_FIELD_EQ(inName,"unload") ) { return hx::Val( unload_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"eventID") ) { return hx::Val( eventID ); }
		if (HX_FIELD_EQ(inName,"atlases") ) { return hx::Val( atlases ); }
		if (HX_FIELD_EQ(inName,"regions") ) { return hx::Val( regions ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"gravityX") ) { return hx::Val( gravityX ); }
		if (HX_FIELD_EQ(inName,"gravityY") ) { return hx::Val( gravityY ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"tileWidth") ) { return hx::Val( tileWidth ); }
		if (HX_FIELD_EQ(inName,"shapeList") ) { return hx::Val( shapeList ); }
		if (HX_FIELD_EQ(inName,"readJoint") ) { return hx::Val( readJoint_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"sceneWidth") ) { return hx::Val( sceneWidth ); }
		if (HX_FIELD_EQ(inName,"tileHeight") ) { return hx::Val( tileHeight ); }
		if (HX_FIELD_EQ(inName,"wireframes") ) { return hx::Val( wireframes ); }
		if (HX_FIELD_EQ(inName,"readRegion") ) { return hx::Val( readRegion_dyn() ); }
		if (HX_FIELD_EQ(inName,"readJoints") ) { return hx::Val( readJoints_dyn() ); }
		if (HX_FIELD_EQ(inName,"readActors") ) { return hx::Val( readActors_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"sceneHeight") ) { return hx::Val( sceneHeight ); }
		if (HX_FIELD_EQ(inName,"readRegions") ) { return hx::Val( readRegions_dyn() ); }
		if (HX_FIELD_EQ(inName,"readAtlases") ) { return hx::Val( readAtlases_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"readRawLayer") ) { return hx::Val( readRawLayer_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"animatedTiles") ) { return hx::Val( animatedTiles ); }
		if (HX_FIELD_EQ(inName,"readAllLayers") ) { return hx::Val( readAllLayers_dyn() ); }
		if (HX_FIELD_EQ(inName,"readRawLayers") ) { return hx::Val( readRawLayers_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"behaviorValues") ) { return hx::Val( behaviorValues ); }
		if (HX_FIELD_EQ(inName,"retainsAtlases") ) { return hx::Val( retainsAtlases ); }
		if (HX_FIELD_EQ(inName,"terrainRegions") ) { return hx::Val( terrainRegions ); }
		if (HX_FIELD_EQ(inName,"readWireframes") ) { return hx::Val( readWireframes_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"colorBackground") ) { return hx::Val( colorBackground ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"addPolygonRegion") ) { return hx::Val( addPolygonRegion_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"addPolygonTerrain") ) { return hx::Val( addPolygonTerrain_dyn() ); }
		if (HX_FIELD_EQ(inName,"readTerrainRegion") ) { return hx::Val( readTerrainRegion_dyn() ); }
		if (HX_FIELD_EQ(inName,"readActorInstance") ) { return hx::Val( readActorInstance_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"readTerrainRegions") ) { return hx::Val( readTerrainRegions_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"readColorBackground") ) { return hx::Val( readColorBackground_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Scene_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 12:
		if (HX_FIELD_EQ(inName,"MAX_VERTICES") ) { outValue = ( MAX_VERTICES ); return true; }
	}
	return false;
}

hx::Val Scene_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"ID") ) { ID=inValue.Cast< int >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"name") ) { name=inValue.Cast< ::String >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"currW") ) { currW=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"currH") ) { currH=inValue.Cast< int >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"layers") ) { layers=inValue.Cast<  ::de::polygonal::ds::IntHashTable >(); return inValue; }
		if (HX_FIELD_EQ(inName,"actors") ) { actors=inValue.Cast<  ::haxe::ds::IntMap >(); return inValue; }
		if (HX_FIELD_EQ(inName,"joints") ) { joints=inValue.Cast<  ::haxe::ds::IntMap >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"eventID") ) { eventID=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"atlases") ) { atlases=inValue.Cast< ::Array< int > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"regions") ) { regions=inValue.Cast<  ::haxe::ds::IntMap >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"gravityX") ) { gravityX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"gravityY") ) { gravityY=inValue.Cast< Float >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"tileWidth") ) { tileWidth=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"shapeList") ) { shapeList=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"sceneWidth") ) { sceneWidth=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"tileHeight") ) { tileHeight=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"wireframes") ) { wireframes=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"sceneHeight") ) { sceneHeight=inValue.Cast< int >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"animatedTiles") ) { animatedTiles=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"behaviorValues") ) { behaviorValues=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
		if (HX_FIELD_EQ(inName,"retainsAtlases") ) { retainsAtlases=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"terrainRegions") ) { terrainRegions=inValue.Cast<  ::haxe::ds::IntMap >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"colorBackground") ) { colorBackground=inValue.Cast< ::Dynamic >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool Scene_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 12:
		if (HX_FIELD_EQ(inName,"MAX_VERTICES") ) { MAX_VERTICES=ioValue.Cast< int >(); return true; }
	}
	return false;
}

void Scene_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("ID","\xdb","\x3f","\x00","\x00"));
	outFields->push(HX_HCSTRING("name","\x4b","\x72","\xff","\x48"));
	outFields->push(HX_HCSTRING("sceneWidth","\x1a","\x19","\x8b","\x23"));
	outFields->push(HX_HCSTRING("sceneHeight","\x53","\x56","\x7a","\xac"));
	outFields->push(HX_HCSTRING("tileWidth","\xf8","\x13","\xbe","\x55"));
	outFields->push(HX_HCSTRING("tileHeight","\xb5","\xdd","\xe2","\x66"));
	outFields->push(HX_HCSTRING("gravityX","\x4a","\x16","\x81","\x87"));
	outFields->push(HX_HCSTRING("gravityY","\x4b","\x16","\x81","\x87"));
	outFields->push(HX_HCSTRING("eventID","\x75","\xc2","\x9a","\x06"));
	outFields->push(HX_HCSTRING("colorBackground","\x31","\xc3","\x85","\x75"));
	outFields->push(HX_HCSTRING("layers","\x82","\x15","\xb1","\x58"));
	outFields->push(HX_HCSTRING("actors","\xde","\xcb","\x4a","\x16"));
	outFields->push(HX_HCSTRING("behaviorValues","\x14","\xc2","\x67","\x92"));
	outFields->push(HX_HCSTRING("atlases","\x79","\xce","\xc3","\x92"));
	outFields->push(HX_HCSTRING("retainsAtlases","\x0b","\x77","\x29","\x69"));
	outFields->push(HX_HCSTRING("wireframes","\xab","\x25","\x96","\x74"));
	outFields->push(HX_HCSTRING("joints","\xe9","\xe7","\x09","\x91"));
	outFields->push(HX_HCSTRING("regions","\xff","\x14","\x9c","\x7a"));
	outFields->push(HX_HCSTRING("terrainRegions","\xca","\xa1","\x9b","\xa2"));
	outFields->push(HX_HCSTRING("animatedTiles","\xe2","\x8b","\x7e","\x48"));
	outFields->push(HX_HCSTRING("shapeList","\x1f","\xd0","\x8f","\xe2"));
	outFields->push(HX_HCSTRING("currW","\x25","\x49","\x58","\x4e"));
	outFields->push(HX_HCSTRING("currH","\x16","\x49","\x58","\x4e"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Scene_obj_sMemberStorageInfo[] = {
	{hx::fsInt,(int)offsetof(Scene_obj,ID),HX_HCSTRING("ID","\xdb","\x3f","\x00","\x00")},
	{hx::fsString,(int)offsetof(Scene_obj,name),HX_HCSTRING("name","\x4b","\x72","\xff","\x48")},
	{hx::fsInt,(int)offsetof(Scene_obj,sceneWidth),HX_HCSTRING("sceneWidth","\x1a","\x19","\x8b","\x23")},
	{hx::fsInt,(int)offsetof(Scene_obj,sceneHeight),HX_HCSTRING("sceneHeight","\x53","\x56","\x7a","\xac")},
	{hx::fsInt,(int)offsetof(Scene_obj,tileWidth),HX_HCSTRING("tileWidth","\xf8","\x13","\xbe","\x55")},
	{hx::fsInt,(int)offsetof(Scene_obj,tileHeight),HX_HCSTRING("tileHeight","\xb5","\xdd","\xe2","\x66")},
	{hx::fsFloat,(int)offsetof(Scene_obj,gravityX),HX_HCSTRING("gravityX","\x4a","\x16","\x81","\x87")},
	{hx::fsFloat,(int)offsetof(Scene_obj,gravityY),HX_HCSTRING("gravityY","\x4b","\x16","\x81","\x87")},
	{hx::fsInt,(int)offsetof(Scene_obj,eventID),HX_HCSTRING("eventID","\x75","\xc2","\x9a","\x06")},
	{hx::fsObject /*::com::stencyl::models::Background*/ ,(int)offsetof(Scene_obj,colorBackground),HX_HCSTRING("colorBackground","\x31","\xc3","\x85","\x75")},
	{hx::fsObject /*::de::polygonal::ds::IntHashTable*/ ,(int)offsetof(Scene_obj,layers),HX_HCSTRING("layers","\x82","\x15","\xb1","\x58")},
	{hx::fsObject /*::haxe::ds::IntMap*/ ,(int)offsetof(Scene_obj,actors),HX_HCSTRING("actors","\xde","\xcb","\x4a","\x16")},
	{hx::fsObject /*::haxe::ds::StringMap*/ ,(int)offsetof(Scene_obj,behaviorValues),HX_HCSTRING("behaviorValues","\x14","\xc2","\x67","\x92")},
	{hx::fsObject /*Array< int >*/ ,(int)offsetof(Scene_obj,atlases),HX_HCSTRING("atlases","\x79","\xce","\xc3","\x92")},
	{hx::fsBool,(int)offsetof(Scene_obj,retainsAtlases),HX_HCSTRING("retainsAtlases","\x0b","\x77","\x29","\x69")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Scene_obj,wireframes),HX_HCSTRING("wireframes","\xab","\x25","\x96","\x74")},
	{hx::fsObject /*::haxe::ds::IntMap*/ ,(int)offsetof(Scene_obj,joints),HX_HCSTRING("joints","\xe9","\xe7","\x09","\x91")},
	{hx::fsObject /*::haxe::ds::IntMap*/ ,(int)offsetof(Scene_obj,regions),HX_HCSTRING("regions","\xff","\x14","\x9c","\x7a")},
	{hx::fsObject /*::haxe::ds::IntMap*/ ,(int)offsetof(Scene_obj,terrainRegions),HX_HCSTRING("terrainRegions","\xca","\xa1","\x9b","\xa2")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Scene_obj,animatedTiles),HX_HCSTRING("animatedTiles","\xe2","\x8b","\x7e","\x48")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Scene_obj,shapeList),HX_HCSTRING("shapeList","\x1f","\xd0","\x8f","\xe2")},
	{hx::fsInt,(int)offsetof(Scene_obj,currW),HX_HCSTRING("currW","\x25","\x49","\x58","\x4e")},
	{hx::fsInt,(int)offsetof(Scene_obj,currH),HX_HCSTRING("currH","\x16","\x49","\x58","\x4e")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo Scene_obj_sStaticStorageInfo[] = {
	{hx::fsInt,(void *) &Scene_obj::MAX_VERTICES,HX_HCSTRING("MAX_VERTICES","\x54","\xb0","\xd7","\xa3")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String Scene_obj_sMemberFields[] = {
	HX_HCSTRING("ID","\xdb","\x3f","\x00","\x00"),
	HX_HCSTRING("name","\x4b","\x72","\xff","\x48"),
	HX_HCSTRING("sceneWidth","\x1a","\x19","\x8b","\x23"),
	HX_HCSTRING("sceneHeight","\x53","\x56","\x7a","\xac"),
	HX_HCSTRING("tileWidth","\xf8","\x13","\xbe","\x55"),
	HX_HCSTRING("tileHeight","\xb5","\xdd","\xe2","\x66"),
	HX_HCSTRING("gravityX","\x4a","\x16","\x81","\x87"),
	HX_HCSTRING("gravityY","\x4b","\x16","\x81","\x87"),
	HX_HCSTRING("eventID","\x75","\xc2","\x9a","\x06"),
	HX_HCSTRING("colorBackground","\x31","\xc3","\x85","\x75"),
	HX_HCSTRING("layers","\x82","\x15","\xb1","\x58"),
	HX_HCSTRING("actors","\xde","\xcb","\x4a","\x16"),
	HX_HCSTRING("behaviorValues","\x14","\xc2","\x67","\x92"),
	HX_HCSTRING("atlases","\x79","\xce","\xc3","\x92"),
	HX_HCSTRING("retainsAtlases","\x0b","\x77","\x29","\x69"),
	HX_HCSTRING("wireframes","\xab","\x25","\x96","\x74"),
	HX_HCSTRING("joints","\xe9","\xe7","\x09","\x91"),
	HX_HCSTRING("regions","\xff","\x14","\x9c","\x7a"),
	HX_HCSTRING("terrainRegions","\xca","\xa1","\x9b","\xa2"),
	HX_HCSTRING("animatedTiles","\xe2","\x8b","\x7e","\x48"),
	HX_HCSTRING("load","\x26","\x9a","\xb7","\x47"),
	HX_HCSTRING("unload","\xff","\xa0","\x8c","\x65"),
	HX_HCSTRING("readRegions","\x49","\xa8","\x87","\xcd"),
	HX_HCSTRING("readRegion","\xea","\xa4","\x08","\xfa"),
	HX_HCSTRING("shapeList","\x1f","\xd0","\x8f","\xe2"),
	HX_HCSTRING("currW","\x25","\x49","\x58","\x4e"),
	HX_HCSTRING("currH","\x16","\x49","\x58","\x4e"),
	HX_HCSTRING("addPolygonRegion","\x2d","\x2c","\xc9","\x05"),
	HX_HCSTRING("addPolygonTerrain","\x5c","\x12","\xb9","\xb8"),
	HX_HCSTRING("readTerrainRegions","\xc0","\x6b","\x2d","\xd3"),
	HX_HCSTRING("readTerrainRegion","\x53","\x3d","\x08","\xb4"),
	HX_HCSTRING("readJoints","\xdf","\xcb","\x85","\x8a"),
	HX_HCSTRING("readJoint","\x14","\x86","\x0f","\x23"),
	HX_HCSTRING("readAllLayers","\x4d","\x0b","\x83","\xba"),
	HX_HCSTRING("readColorBackground","\x7b","\xb0","\x84","\xc4"),
	HX_HCSTRING("readRawLayers","\x54","\x37","\xcc","\x10"),
	HX_HCSTRING("readRawLayer","\x3f","\x00","\xb4","\x0c"),
	HX_HCSTRING("readAtlases","\xc3","\x61","\xaf","\xe5"),
	HX_HCSTRING("readWireframes","\xa1","\x3c","\xd2","\xe1"),
	HX_HCSTRING("readActors","\xd4","\xaf","\xc6","\x0f"),
	HX_HCSTRING("readActorInstance","\x74","\x4a","\xad","\x70"),
	HX_HCSTRING("getID","\xf1","\x91","\x60","\x91"),
	::String(null()) };

static void Scene_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Scene_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(Scene_obj::MAX_VERTICES,"MAX_VERTICES");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Scene_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Scene_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(Scene_obj::MAX_VERTICES,"MAX_VERTICES");
};

#endif

hx::Class Scene_obj::__mClass;

static ::String Scene_obj_sStaticFields[] = {
	HX_HCSTRING("MAX_VERTICES","\x54","\xb0","\xd7","\xa3"),
	::String(null())
};

void Scene_obj::__register()
{
	hx::Object *dummy = new Scene_obj;
	Scene_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("com.stencyl.models.Scene","\x77","\x59","\x68","\x94");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Scene_obj::__GetStatic;
	__mClass->mSetStaticField = &Scene_obj::__SetStatic;
	__mClass->mMarkFunc = Scene_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Scene_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Scene_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Scene_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Scene_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Scene_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Scene_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Scene_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_2735c5affeba8556_633_boot)
HXDLIN( 633)		MAX_VERTICES = (int)200;
            	}
}

} // end namespace com
} // end namespace stencyl
} // end namespace models
