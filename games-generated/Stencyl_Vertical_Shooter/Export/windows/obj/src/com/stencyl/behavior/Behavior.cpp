// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_Reflect
#include <Reflect.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_Type
#include <Type.h>
#endif
#ifndef INCLUDED_com_stencyl_Engine
#include <com/stencyl/Engine.h>
#endif
#ifndef INCLUDED_com_stencyl_behavior_ActorScript
#include <com/stencyl/behavior/ActorScript.h>
#endif
#ifndef INCLUDED_com_stencyl_behavior_Attribute
#include <com/stencyl/behavior/Attribute.h>
#endif
#ifndef INCLUDED_com_stencyl_behavior_Behavior
#include <com/stencyl/behavior/Behavior.h>
#endif
#ifndef INCLUDED_com_stencyl_behavior_SceneScript
#include <com/stencyl/behavior/SceneScript.h>
#endif
#ifndef INCLUDED_com_stencyl_behavior_Script
#include <com/stencyl/behavior/Script.h>
#endif
#ifndef INCLUDED_com_stencyl_models_Actor
#include <com/stencyl/models/Actor.h>
#endif
#ifndef INCLUDED_com_stencyl_models_Region
#include <com/stencyl/models/Region.h>
#endif
#ifndef INCLUDED_com_stencyl_models_actor_Group
#include <com/stencyl/models/actor/Group.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_eb1d0035aaa9ba6a_40_new,"com.stencyl.behavior.Behavior","new",0x11d5d311,"com.stencyl.behavior.Behavior.new","com/stencyl/behavior/Behavior.hx",40,0x799b1d20)
HX_LOCAL_STACK_FRAME(_hx_pos_eb1d0035aaa9ba6a_71_initScript,"com.stencyl.behavior.Behavior","initScript",0x3f28ceaa,"com.stencyl.behavior.Behavior.initScript","com/stencyl/behavior/Behavior.hx",71,0x799b1d20)
HX_LOCAL_STACK_FRAME(_hx_pos_eb1d0035aaa9ba6a_124_initAttributes,"com.stencyl.behavior.Behavior","initAttributes",0xea3064f6,"com.stencyl.behavior.Behavior.initAttributes","com/stencyl/behavior/Behavior.hx",124,0x799b1d20)
namespace com{
namespace stencyl{
namespace behavior{

void Behavior_obj::__construct( ::Dynamic parent, ::com::stencyl::Engine engine,int ID,::String name,::String classname,bool enabled,bool drawable, ::haxe::ds::StringMap attributes,::String type,bool isEvent){
            	HX_STACKFRAME(&_hx_pos_eb1d0035aaa9ba6a_40_new)
HXLINE(  41)		this->isEvent = isEvent;
HXLINE(  42)		this->parent = parent;
HXLINE(  43)		this->engine = engine;
HXLINE(  44)		this->classname = classname;
HXLINE(  46)		if (hx::IsNotNull( engine )) {
HXLINE(  48)			try {
            				HX_STACK_CATCHABLE(::String, 0);
HXLINE(  50)				this->cls = ::Type_obj::resolveClass(classname);
            			}
            			catch( ::Dynamic _hx_e){
            				if (_hx_e.IsClass< ::String >() ){
            					HX_STACK_BEGIN_CATCH
            					::String e = _hx_e;
HXLINE(  55)					 ::Dynamic _hx_tmp = ::haxe::Log_obj::trace;
HXDLIN(  55)					_hx_tmp((HX_("Could not load: ",98,08,5b,78) + classname),hx::SourceInfo(HX_("Behavior.hx",4c,71,3e,d0),55,HX_("com.stencyl.behavior.Behavior",9f,f6,b0,3b),HX_("new",60,d0,53,00)));
HXLINE(  56)					::haxe::Log_obj::trace(e,hx::SourceInfo(HX_("Behavior.hx",4c,71,3e,d0),56,HX_("com.stencyl.behavior.Behavior",9f,f6,b0,3b),HX_("new",60,d0,53,00)));
            				}
            				else {
            					HX_STACK_DO_THROW(_hx_e);
            				}
            			}
            		}
HXLINE(  60)		this->enabled = enabled;
HXLINE(  61)		this->drawable = drawable;
HXLINE(  63)		this->ID = ID;
HXLINE(  64)		this->name = name;
HXLINE(  65)		this->type = type;
HXLINE(  67)		this->attributes = attributes;
            	}

Dynamic Behavior_obj::__CreateEmpty() { return new Behavior_obj; }

void *Behavior_obj::_hx_vtable = 0;

Dynamic Behavior_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Behavior_obj > _hx_result = new Behavior_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7],inArgs[8],inArgs[9]);
	return _hx_result;
}

bool Behavior_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x4f8f95f3;
}

void Behavior_obj::initScript(hx::Null< bool >  __o_initJustScript){
bool initJustScript = __o_initJustScript.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_eb1d0035aaa9ba6a_71_initScript)
HXLINE(  72)		if (hx::IsNull( this->cls )) {
HXLINE(  74)			 ::Dynamic _hx_tmp = ::haxe::Log_obj::trace;
HXDLIN(  74)			_hx_tmp((((HX_("Could not init Behavior: ",1c,67,26,04) + this->name) + HX_(" with ",3a,5b,da,95)) + this->classname),hx::SourceInfo(HX_("Behavior.hx",4c,71,3e,d0),74,HX_("com.stencyl.behavior.Behavior",9f,f6,b0,3b),HX_("initScript",3b,a9,a5,4b)));
HXLINE(  75)			this->script =  ::com::stencyl::behavior::SceneScript_obj::__alloc( HX_CTX );
HXLINE(  76)			return;
            		}
HXLINE(  79)		if ((this->type == HX_("actor",f5,ca,a6,1b))) {
HXLINE(  81)			if (hx::IsEq( ::Type_obj::getClass(this->parent),hx::ClassOf< ::com::stencyl::Engine >() )) {
HXLINE(  83)				 ::Dynamic _hx_tmp1 = ::haxe::Log_obj::trace;
HXDLIN(  83)				_hx_tmp1(((HX_("Actor behavior ",43,e2,2a,dc) + this->name) + HX_(" failed to init because parent is scene.  Open and save the scene to resolve this error.",c0,93,76,b9)),hx::SourceInfo(HX_("Behavior.hx",4c,71,3e,d0),83,HX_("com.stencyl.behavior.Behavior",9f,f6,b0,3b),HX_("initScript",3b,a9,a5,4b)));
HXLINE(  84)				this->script =  ::com::stencyl::behavior::SceneScript_obj::__alloc( HX_CTX );
HXLINE(  85)				return;
            			}
HXLINE(  87)			this->script = ( ( ::com::stencyl::behavior::Script)(::Type_obj::createInstance(this->cls,::cpp::VirtualArray_obj::__new(3)->init(0,(int)0)->init(1,this->parent)->init(2,null()))) );
            		}
            		else {
HXLINE(  91)			if (hx::IsEq( ::Type_obj::getClass(this->parent),hx::ClassOf< ::com::stencyl::models::Actor >() )) {
HXLINE(  93)				 ::Dynamic _hx_tmp2 = ::haxe::Log_obj::trace;
HXDLIN(  93)				_hx_tmp2(((HX_("Scene behavior ",5a,e3,89,72) + this->name) + HX_(" failed to init because parent is actor.  Open and save the actor to resolve this error.",6e,93,b4,2c)),hx::SourceInfo(HX_("Behavior.hx",4c,71,3e,d0),93,HX_("com.stencyl.behavior.Behavior",9f,f6,b0,3b),HX_("initScript",3b,a9,a5,4b)));
HXLINE(  94)				this->script =  ::com::stencyl::behavior::SceneScript_obj::__alloc( HX_CTX );
HXLINE(  95)				return;
            			}
HXLINE(  97)			this->script = ( ( ::com::stencyl::behavior::Script)(::Type_obj::createInstance(this->cls,::cpp::VirtualArray_obj::__new(2)->init(0,(int)0)->init(1,null()))) );
            		}
HXLINE( 100)		this->script->wrapper = hx::ObjectPtr<OBJ_>(this);
HXLINE( 101)		this->initAttributes();
HXLINE( 103)		if (!(initJustScript)) {
HXLINE( 105)			try {
            				HX_STACK_CATCHABLE(::String, 0);
HXLINE( 107)				this->script->init();
HXLINE( 108)				this->script->scriptInit = true;
            			}
            			catch( ::Dynamic _hx_e){
            				if (_hx_e.IsClass< ::String >() ){
            					HX_STACK_BEGIN_CATCH
            					::String e = _hx_e;
HXLINE( 113)					 ::Dynamic _hx_tmp3 = ::haxe::Log_obj::trace;
HXDLIN( 113)					_hx_tmp3((((HX_("Error in when created for behavior: ",0a,8e,91,86) + this->name) + HX_("\n",0a,00,00,00)) + e),hx::SourceInfo(HX_("Behavior.hx",4c,71,3e,d0),113,HX_("com.stencyl.behavior.Behavior",9f,f6,b0,3b),HX_("initScript",3b,a9,a5,4b)));
            				}
            				else {
            					HX_STACK_DO_THROW(_hx_e);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Behavior_obj,initScript,(void))

void Behavior_obj::initAttributes(){
            	HX_GC_STACKFRAME(&_hx_pos_eb1d0035aaa9ba6a_124_initAttributes)
HXDLIN( 124)		 ::Dynamic a = this->attributes->iterator();
HXDLIN( 124)		while(( (bool)(a->__Field(HX_("hasNext",6d,a5,46,18),hx::paccDynamic)()) )){
HXDLIN( 124)			 ::com::stencyl::behavior::Attribute a1 = ( ( ::com::stencyl::behavior::Attribute)(a->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)()) );
HXLINE( 126)			try {
            				HX_STACK_CATCHABLE(::String, 0);
HXLINE( 129)				if (a1->hidden) {
HXLINE( 131)					continue;
            				}
HXLINE( 134)				bool _hx_tmp;
HXDLIN( 134)				bool _hx_tmp1;
HXDLIN( 134)				if ((a1->type == HX_("actor",f5,ca,a6,1b))) {
HXLINE( 134)					_hx_tmp1 = (a1->fieldName == HX_("actor",f5,ca,a6,1b));
            				}
            				else {
HXLINE( 134)					_hx_tmp1 = false;
            				}
HXDLIN( 134)				if (_hx_tmp1) {
HXLINE( 134)					_hx_tmp = ::Std_obj::is(this->script,hx::ClassOf< ::com::stencyl::behavior::ActorScript >());
            				}
            				else {
HXLINE( 134)					_hx_tmp = false;
            				}
HXDLIN( 134)				if (_hx_tmp) {
HXLINE( 136)					continue;
            				}
HXLINE( 139)				::String attributeName = this->script->toInternalName(a1->fieldName);
HXLINE( 141)				bool _hx_tmp2;
HXDLIN( 141)				bool _hx_tmp3;
HXDLIN( 141)				if ((a1->type != HX_("actor",f5,ca,a6,1b))) {
HXLINE( 141)					_hx_tmp3 = (a1->type == HX_("joint",4a,39,28,52));
            				}
            				else {
HXLINE( 141)					_hx_tmp3 = true;
            				}
HXDLIN( 141)				if (!(_hx_tmp3)) {
HXLINE( 141)					_hx_tmp2 = (a1->type == HX_("region",f4,c0,8c,00));
            				}
            				else {
HXLINE( 141)					_hx_tmp2 = true;
            				}
HXDLIN( 141)				if (_hx_tmp2) {
HXLINE( 143)					int eID = ::Std_obj::parseInt((HX_("",00,00,00,00) + ::Std_obj::string(a1->getRealValue())));
HXLINE( 145)					if ((a1->type == HX_("actor",f5,ca,a6,1b))) {
HXLINE( 147)						 ::com::stencyl::behavior::Script _hx_tmp4 = this->script;
HXDLIN( 147)						::Reflect_obj::setField(_hx_tmp4,attributeName,this->engine->getActor(eID));
            					}
            					else {
HXLINE( 150)						if ((a1->type != HX_("joint",4a,39,28,52))) {
HXLINE( 156)							if ((a1->type == HX_("region",f4,c0,8c,00))) {
HXLINE( 158)								 ::com::stencyl::behavior::Script _hx_tmp5 = this->script;
HXDLIN( 158)								::Reflect_obj::setField(_hx_tmp5,attributeName,this->engine->getRegion(eID));
            							}
            							else {
HXLINE( 161)								bool _hx_tmp6 = (a1->type == HX_("terrainregion",69,a2,e3,d1));
            							}
            						}
            					}
            				}
            				else {
HXLINE( 168)					if ((a1->type == HX_("actorgroup",2a,10,e1,90))) {
HXLINE( 170)						int groupID = ::Std_obj::parseInt((HX_("",00,00,00,00) + ::Std_obj::string(a1->getRealValue())));
HXLINE( 171)						 ::com::stencyl::behavior::Script _hx_tmp7 = this->script;
HXDLIN( 171)						::Reflect_obj::setField(_hx_tmp7,attributeName,this->engine->getGroup(groupID,null()));
            					}
            					else {
HXLINE( 176)						 ::Dynamic realValue = a1->getRealValue();
HXLINE( 180)						if ((a1->type == HX_("list",5e,1c,b3,47))) {
HXLINE( 182)							::cpp::VirtualArray list = null();
HXLINE( 184)							if (hx::IsNotNull( realValue )) {
HXLINE( 186)								list = hx::TCast< ::cpp::VirtualArray >::cast(realValue);
HXLINE( 187)								::cpp::VirtualArray _g = ::cpp::VirtualArray_obj::__new(0);
HXDLIN( 187)								{
HXLINE( 187)									int _g1 = (int)0;
HXDLIN( 187)									while((_g1 < list->get_length())){
HXLINE( 187)										 ::Dynamic item = list->__get(_g1);
HXDLIN( 187)										_g1 = (_g1 + (int)1);
HXDLIN( 187)										_g->push(item);
            									}
            								}
HXDLIN( 187)								list = _g;
            							}
            							else {
HXLINE( 192)								list = ::cpp::VirtualArray_obj::__new(0);
            							}
HXLINE( 195)							::Reflect_obj::setField(this->script,attributeName,list);
            						}
            						else {
HXLINE( 198)							if ((a1->type == HX_("map",9c,0a,53,00))) {
HXLINE( 200)								 ::haxe::ds::StringMap map = null();
HXLINE( 202)								if (hx::IsNotNull( realValue )) {
HXLINE( 204)									::Dynamic realMap = realValue;
HXLINE( 205)									map =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXLINE( 207)									{
HXLINE( 207)										 ::Dynamic key = ::haxe::IMap_obj::keys(realMap);
HXDLIN( 207)										while(( (bool)(key->__Field(HX_("hasNext",6d,a5,46,18),hx::paccDynamic)()) )){
HXLINE( 207)											::String key1 = ( (::String)(key->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)()) );
HXLINE( 209)											map->set(key1,::haxe::IMap_obj::get(realMap,key1));
            										}
            									}
            								}
            								else {
HXLINE( 215)									map =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
            								}
HXLINE( 218)								::Reflect_obj::setField(this->script,attributeName,map);
            							}
            							else {
HXLINE( 223)								::Reflect_obj::setField(this->script,attributeName,realValue);
            							}
            						}
            					}
            				}
            			}
            			catch( ::Dynamic _hx_e){
            				if (_hx_e.IsClass< ::String >() ){
            					HX_STACK_BEGIN_CATCH
            					::String e = _hx_e;
HXLINE( 230)					 ::Dynamic _hx_tmp8 = ::haxe::Log_obj::trace;
HXDLIN( 230)					_hx_tmp8((((HX_("Could not init attribute: ",fe,65,2e,b9) + a1->fieldName) + HX_(" - ",73,6f,18,00)) + e),hx::SourceInfo(HX_("Behavior.hx",4c,71,3e,d0),230,HX_("com.stencyl.behavior.Behavior",9f,f6,b0,3b),HX_("initAttributes",07,5c,3c,bc)));
            				}
            				else {
            					HX_STACK_DO_THROW(_hx_e);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Behavior_obj,initAttributes,(void))


hx::ObjectPtr< Behavior_obj > Behavior_obj::__new( ::Dynamic parent, ::com::stencyl::Engine engine,int ID,::String name,::String classname,bool enabled,bool drawable, ::haxe::ds::StringMap attributes,::String type,bool isEvent) {
	hx::ObjectPtr< Behavior_obj > __this = new Behavior_obj();
	__this->__construct(parent,engine,ID,name,classname,enabled,drawable,attributes,type,isEvent);
	return __this;
}

hx::ObjectPtr< Behavior_obj > Behavior_obj::__alloc(hx::Ctx *_hx_ctx, ::Dynamic parent, ::com::stencyl::Engine engine,int ID,::String name,::String classname,bool enabled,bool drawable, ::haxe::ds::StringMap attributes,::String type,bool isEvent) {
	Behavior_obj *__this = (Behavior_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Behavior_obj), true, "com.stencyl.behavior.Behavior"));
	*(void **)__this = Behavior_obj::_hx_vtable;
	__this->__construct(parent,engine,ID,name,classname,enabled,drawable,attributes,type,isEvent);
	return __this;
}

Behavior_obj::Behavior_obj()
{
}

void Behavior_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Behavior);
	HX_MARK_MEMBER_NAME(parent,"parent");
	HX_MARK_MEMBER_NAME(engine,"engine");
	HX_MARK_MEMBER_NAME(enabled,"enabled");
	HX_MARK_MEMBER_NAME(drawable,"drawable");
	HX_MARK_MEMBER_NAME(isEvent,"isEvent");
	HX_MARK_MEMBER_NAME(ID,"ID");
	HX_MARK_MEMBER_NAME(name,"name");
	HX_MARK_MEMBER_NAME(type,"type");
	HX_MARK_MEMBER_NAME(classname,"classname");
	HX_MARK_MEMBER_NAME(cls,"cls");
	HX_MARK_MEMBER_NAME(script,"script");
	HX_MARK_MEMBER_NAME(attributes,"attributes");
	HX_MARK_END_CLASS();
}

void Behavior_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(parent,"parent");
	HX_VISIT_MEMBER_NAME(engine,"engine");
	HX_VISIT_MEMBER_NAME(enabled,"enabled");
	HX_VISIT_MEMBER_NAME(drawable,"drawable");
	HX_VISIT_MEMBER_NAME(isEvent,"isEvent");
	HX_VISIT_MEMBER_NAME(ID,"ID");
	HX_VISIT_MEMBER_NAME(name,"name");
	HX_VISIT_MEMBER_NAME(type,"type");
	HX_VISIT_MEMBER_NAME(classname,"classname");
	HX_VISIT_MEMBER_NAME(cls,"cls");
	HX_VISIT_MEMBER_NAME(script,"script");
	HX_VISIT_MEMBER_NAME(attributes,"attributes");
}

hx::Val Behavior_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"ID") ) { return hx::Val( ID ); }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"cls") ) { return hx::Val( cls ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"name") ) { return hx::Val( name ); }
		if (HX_FIELD_EQ(inName,"type") ) { return hx::Val( type ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"parent") ) { return hx::Val( parent ); }
		if (HX_FIELD_EQ(inName,"engine") ) { return hx::Val( engine ); }
		if (HX_FIELD_EQ(inName,"script") ) { return hx::Val( script ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"enabled") ) { return hx::Val( enabled ); }
		if (HX_FIELD_EQ(inName,"isEvent") ) { return hx::Val( isEvent ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"drawable") ) { return hx::Val( drawable ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"classname") ) { return hx::Val( classname ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"attributes") ) { return hx::Val( attributes ); }
		if (HX_FIELD_EQ(inName,"initScript") ) { return hx::Val( initScript_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"initAttributes") ) { return hx::Val( initAttributes_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val Behavior_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"ID") ) { ID=inValue.Cast< int >(); return inValue; }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"cls") ) { cls=inValue.Cast< hx::Class >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"name") ) { name=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"type") ) { type=inValue.Cast< ::String >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"parent") ) { parent=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"engine") ) { engine=inValue.Cast<  ::com::stencyl::Engine >(); return inValue; }
		if (HX_FIELD_EQ(inName,"script") ) { script=inValue.Cast<  ::com::stencyl::behavior::Script >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"enabled") ) { enabled=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"isEvent") ) { isEvent=inValue.Cast< bool >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"drawable") ) { drawable=inValue.Cast< bool >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"classname") ) { classname=inValue.Cast< ::String >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"attributes") ) { attributes=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Behavior_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("parent","\x2a","\x05","\x7e","\xed"));
	outFields->push(HX_HCSTRING("engine","\xc2","\x47","\x84","\xfc"));
	outFields->push(HX_HCSTRING("enabled","\x81","\x04","\x31","\x7e"));
	outFields->push(HX_HCSTRING("drawable","\x9e","\xeb","\xf8","\x69"));
	outFields->push(HX_HCSTRING("isEvent","\xd0","\x6b","\x4a","\x12"));
	outFields->push(HX_HCSTRING("ID","\xdb","\x3f","\x00","\x00"));
	outFields->push(HX_HCSTRING("name","\x4b","\x72","\xff","\x48"));
	outFields->push(HX_HCSTRING("type","\xba","\xf2","\x08","\x4d"));
	outFields->push(HX_HCSTRING("classname","\x83","\x66","\x64","\xf1"));
	outFields->push(HX_HCSTRING("cls","\xaa","\x7d","\x4b","\x00"));
	outFields->push(HX_HCSTRING("script","\x0b","\x4e","\x60","\x47"));
	outFields->push(HX_HCSTRING("attributes","\xd7","\xa8","\x71","\x97"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Behavior_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*Dynamic*/ ,(int)offsetof(Behavior_obj,parent),HX_HCSTRING("parent","\x2a","\x05","\x7e","\xed")},
	{hx::fsObject /*::com::stencyl::Engine*/ ,(int)offsetof(Behavior_obj,engine),HX_HCSTRING("engine","\xc2","\x47","\x84","\xfc")},
	{hx::fsBool,(int)offsetof(Behavior_obj,enabled),HX_HCSTRING("enabled","\x81","\x04","\x31","\x7e")},
	{hx::fsBool,(int)offsetof(Behavior_obj,drawable),HX_HCSTRING("drawable","\x9e","\xeb","\xf8","\x69")},
	{hx::fsBool,(int)offsetof(Behavior_obj,isEvent),HX_HCSTRING("isEvent","\xd0","\x6b","\x4a","\x12")},
	{hx::fsInt,(int)offsetof(Behavior_obj,ID),HX_HCSTRING("ID","\xdb","\x3f","\x00","\x00")},
	{hx::fsString,(int)offsetof(Behavior_obj,name),HX_HCSTRING("name","\x4b","\x72","\xff","\x48")},
	{hx::fsString,(int)offsetof(Behavior_obj,type),HX_HCSTRING("type","\xba","\xf2","\x08","\x4d")},
	{hx::fsString,(int)offsetof(Behavior_obj,classname),HX_HCSTRING("classname","\x83","\x66","\x64","\xf1")},
	{hx::fsObject /*::hx::Class*/ ,(int)offsetof(Behavior_obj,cls),HX_HCSTRING("cls","\xaa","\x7d","\x4b","\x00")},
	{hx::fsObject /*::com::stencyl::behavior::Script*/ ,(int)offsetof(Behavior_obj,script),HX_HCSTRING("script","\x0b","\x4e","\x60","\x47")},
	{hx::fsObject /*::haxe::ds::StringMap*/ ,(int)offsetof(Behavior_obj,attributes),HX_HCSTRING("attributes","\xd7","\xa8","\x71","\x97")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Behavior_obj_sStaticStorageInfo = 0;
#endif

static ::String Behavior_obj_sMemberFields[] = {
	HX_HCSTRING("parent","\x2a","\x05","\x7e","\xed"),
	HX_HCSTRING("engine","\xc2","\x47","\x84","\xfc"),
	HX_HCSTRING("enabled","\x81","\x04","\x31","\x7e"),
	HX_HCSTRING("drawable","\x9e","\xeb","\xf8","\x69"),
	HX_HCSTRING("isEvent","\xd0","\x6b","\x4a","\x12"),
	HX_HCSTRING("ID","\xdb","\x3f","\x00","\x00"),
	HX_HCSTRING("name","\x4b","\x72","\xff","\x48"),
	HX_HCSTRING("type","\xba","\xf2","\x08","\x4d"),
	HX_HCSTRING("classname","\x83","\x66","\x64","\xf1"),
	HX_HCSTRING("cls","\xaa","\x7d","\x4b","\x00"),
	HX_HCSTRING("script","\x0b","\x4e","\x60","\x47"),
	HX_HCSTRING("attributes","\xd7","\xa8","\x71","\x97"),
	HX_HCSTRING("initScript","\x3b","\xa9","\xa5","\x4b"),
	HX_HCSTRING("initAttributes","\x07","\x5c","\x3c","\xbc"),
	::String(null()) };

static void Behavior_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Behavior_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Behavior_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Behavior_obj::__mClass,"__mClass");
};

#endif

hx::Class Behavior_obj::__mClass;

void Behavior_obj::__register()
{
	hx::Object *dummy = new Behavior_obj;
	Behavior_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("com.stencyl.behavior.Behavior","\x9f","\xf6","\xb0","\x3b");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Behavior_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Behavior_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Behavior_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Behavior_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Behavior_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Behavior_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace com
} // end namespace stencyl
} // end namespace behavior
